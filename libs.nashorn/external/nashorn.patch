diff -r 02f810c26ff9 -r 716d47361960 make/build-nasgen.xml
--- a/make/build-nasgen.xml	Wed Feb 06 12:51:09 2013 -0400
+++ b/make/build-nasgen.xml	Thu Feb 07 13:40:05 2013 +0100
@@ -25,7 +25,7 @@
     <description>Builds and runs nasgen.</description>
     <import file="build.xml"/>
 
-    <target name="build-nasgen" depends="compile-asm">
+    <target name="build-nasgen" depends="get-asm">
         <ant inheritAll="false" dir="${basedir}/buildtools/nasgen"
             antfile="build.xml" target="jar"/>
     </target>
diff -r 02f810c26ff9 -r 716d47361960 make/build.xml
--- a/make/build.xml	Wed Feb 06 12:51:09 2013 -0400
+++ b/make/build.xml	Thu Feb 07 13:40:05 2013 +0100
@@ -63,15 +63,17 @@
     <delete dir="${dynalink.dir}"/>
   </target>
 
-  <target name="clean-all" depends="clean-dynalink, clean">
+  <target name="clean-asm">
+    <delete dir="${asm.dir}"/>
+  </target>
+
+  <target name="clean-all" depends="clean-dynalink, clean-asm, clean">
     <delete dir="${build.dir}"/>
   </target>
 
-  <!-- do it only if ASM is not available -->
-  <target name="compile-asm" depends="prepare" unless="asm.available">
-    <javac srcdir="${jdk.asm.src.dir}"
+  <target name="compile-stubs" depends="prepare">
+    <javac srcdir="${stubs.src.dir}"
            destdir="${build.classes.dir}"
-           excludes="**/optimizer/* **/xml/* **/attrs/*"
            source="${javac.source}"
            target="${javac.target}"
            debug="${javac.debug}"
@@ -101,7 +103,28 @@
     <copy file="${versioned.dynalink.jar}" tofile="${dynalink.jar}" overwrite="true"/>
   </target>
 
-  <target name="compile" depends="compile-asm, get-dynalink" description="Compiles nashorn">
+  <target name="check-asm-uptodate" depends="init">
+    <property name="versioned.asm.jar" value="${dynalink.dir}/asm-all-${asm.version}.jar"/>
+    <condition property="asm.uptodate">
+      <and>
+        <available file="${versioned.asm.jar}"/>
+        <filesmatch file1="${versioned.asm.jar}" file2="${asm.jar}"/>
+      </and>
+    </condition>
+  </target>
+
+  <target name="get-asm" depends="check-asm-uptodate" unless="asm.uptodate">
+    <mkdir dir="${asm.dir}"/>
+    <!-- Delete previous snapshots, if any -->
+    <delete>
+      <fileset dir="${asm.dir}" includes="*"/>
+    </delete>
+    <property name="asm.download.base.url" value="http://repo1.maven.org/maven2/org/ow2/asm/asm-all/${asm.version}/asm-all-${asm.version}"/>
+    <get src="${asm.download.base.url}.jar" dest="${versioned.asm.jar}" usetimestamp="true"/>
+    <copy file="${versioned.asm.jar}" tofile="${asm.jar}" overwrite="true"/>
+  </target>
+
+  <target name="compile" depends="compile-stubs, get-dynalink, get-asm" description="Compiles nashorn">
     <javac srcdir="${src.dir}"
            destdir="${build.classes.dir}"
            classpath="${javac.classpath}"
@@ -131,10 +154,9 @@
     <echo message="release=${nashorn.version}" file="${build.classes.dir}/jdk/nashorn/internal/runtime/resources/version.properties" append="true"/>
   </target>
 
-  <target name="jar" depends="compile, run-nasgen" description="Creates nashorn.jar">
+  <target name="jar" depends="compile" description="Creates nashorn.jar">
     <jar jarfile="${dist.jar}" manifest="${meta.inf.dir}/MANIFEST.MF" index="true" filesetmanifest="merge">
-      <fileset dir="${build.classes.dir}"/>
-      <zipfileset src="${dynalink.jar}"/>
+      <fileset dir="${build.classes.dir}" excludes="java/**"/>
       <manifest>
         <attribute name="Archiver-Version" value="n/a"/>
         <attribute name="Build-Jdk" value="${java.runtime.version}"/>
@@ -148,11 +170,12 @@
     </jar>
   </target>
 
-  <target name="javadoc" depends="prepare">
+  <target name="javadoc" depends="prepare, get-asm">
     <javadoc destdir="${dist.javadoc.dir}" use="yes" overview="src/overview.html" windowtitle="${nashorn.product.name} ${nashorn.version}" additionalparam="-quiet" failonerror="true">
       <classpath>
         <pathelement location="${build.classes.dir}"/>
         <pathelement location="${dynalink.jar}"/>
+        <pathelement location="${asm.jar}"/>
       </classpath>
       <fileset dir="${src.dir}" includes="**/*.java"/>
       <fileset dir="${jdk.asm.src.dir}" includes="**/*.java"/>
diff -r 02f810c26ff9 -r 716d47361960 make/nbproject/nbjdk.properties
--- a/make/nbproject/nbjdk.properties	Wed Feb 06 12:51:09 2013 -0400
+++ b/make/nbproject/nbjdk.properties	Thu Feb 07 13:40:05 2013 +0100
@@ -20,5 +20,5 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
-nbjdk.active=JDK_1.8
+nbjdk.active=JDK_1.6
 
diff -r 02f810c26ff9 -r 716d47361960 make/nbproject/project.xml
--- a/make/nbproject/project.xml	Wed Feb 06 12:51:09 2013 -0400
+++ b/make/nbproject/project.xml	Thu Feb 07 13:40:05 2013 +0100
@@ -160,17 +160,17 @@
                 <package-root>../test/src</package-root>
                 <unit-tests/>
                 <classpath mode="compile">../test/lib/testng.jar:../build/classes:../src</classpath>
-                <source-level>1.7</source-level>
+                <source-level>1.6</source-level>
             </compilation-unit>
             <compilation-unit>
                 <package-root>../src</package-root>
                 <classpath mode="compile">../build/dynalink/dynalink.jar</classpath>
-                <source-level>1.7</source-level>
+                <source-level>1.6</source-level>
             </compilation-unit>
             <compilation-unit>
                 <package-root>../buildtools/nasgen/src</package-root>
                 <classpath mode="compile">../build/classes:../src</classpath>
-                <source-level>1.7</source-level>
+                <source-level>1.6</source-level>
             </compilation-unit>
         </java-data>
     </configuration>
diff -r 02f810c26ff9 -r 716d47361960 make/project.properties
--- a/make/project.properties	Wed Feb 06 12:51:09 2013 -0400
+++ b/make/project.properties	Thu Feb 07 13:40:05 2013 +0100
@@ -28,8 +28,8 @@
 
 # source and target levels
 build.compiler=modern
-javac.source=1.7
-javac.target=1.7
+javac.source=1.6
+javac.target=1.6
 
 # nashorn version information
 nashorn.version=0.1
@@ -61,6 +61,10 @@
 dist.jar=${dist.dir}/nashorn.jar
 dist.javadoc.dir=${dist.dir}/javadoc
 
+# directory where stubs project lives
+stubs.dir=stubs
+stubs.src.dir=${stubs.dir}/src
+
 # jars refererred
 file.reference.testng.jar=test/lib/testng.jar
 
@@ -95,11 +99,17 @@
 dynalink.dir=build/${dynalink.dir.name}
 dynalink.jar=${dynalink.dir}/dynalink.jar
 
+asm.version=4.0
+asm.dir.name=asm
+asm.dir=build/${asm.dir.name}
+asm.jar=${asm.dir}/asm-all.jar
+
 javac.debug=true
 javac.encoding=ascii
 javac.classpath=\
     ${build.classes.dir}:\
-    ${dynalink.jar}
+    ${dynalink.jar}:\
+    ${asm.jar}
 javac.test.classpath=\
     ${build.classes.dir}:\
     ${build.test.classes.dir}:\
diff -r 02f810c26ff9 -r 716d47361960 src/META-INF/services/javax.script.ScriptEngineFactory
--- a/src/META-INF/services/javax.script.ScriptEngineFactory	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/META-INF/services/javax.script.ScriptEngineFactory	Thu Feb 07 13:40:05 2013 +0100
@@ -22,4 +22,4 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
-jdk.nashorn.api.scripting.NashornScriptEngineFactory
+#jdk.nashorn.api.scripting.NashornScriptEngineFactory
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/api/scripting/NashornScriptEngine.java
--- a/src/jdk/nashorn/api/scripting/NashornScriptEngine.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/api/scripting/NashornScriptEngine.java	Thu Feb 07 13:40:05 2013 +0100
@@ -196,9 +196,11 @@
                     setNashornGlobal(oldGlobal);
                 }
             }
-        } catch(final RuntimeException|Error e) {
+        } catch(RuntimeException e) {
             throw e;
-        } catch(final Throwable t) {
+        } catch(Error e){
+            throw e;
+        } catch(Throwable t) {
             throw new RuntimeException(t);
         }
     }
@@ -300,10 +302,15 @@
                         }
                     });
             put(ScriptEngine.FILENAME, name);
-            try (final InputStreamReader isr = new InputStreamReader(is)) {
+            final InputStreamReader isr = new InputStreamReader(is);
+            try {
                 eval(isr);
+            } finally {
+                isr.close();
             }
-        } catch (final PrivilegedActionException | IOException e) {
+        } catch (final PrivilegedActionException e) {
+            throw new ScriptException(e);
+        } catch (final IOException e) {
             throw new ScriptException(e);
         } finally {
             put(ScriptEngine.FILENAME, null);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/api/scripting/NashornScriptEngineFactory.java
--- a/src/jdk/nashorn/api/scripting/NashornScriptEngineFactory.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/api/scripting/NashornScriptEngineFactory.java	Thu Feb 07 13:40:05 2013 +0100
@@ -104,22 +104,21 @@
 
     @Override
     public Object getParameter(final String key) {
-        switch (key) {
-        case ScriptEngine.NAME:
+        if (ScriptEngine.NAME.equals(key)) {
             return "javascript";
-        case ScriptEngine.ENGINE:
+        } else if (ScriptEngine.ENGINE.equals(key)) {
             return "Oracle Nashorn";
-        case ScriptEngine.ENGINE_VERSION:
+        } else if (ScriptEngine.ENGINE_VERSION.equals(key)) {
             return Version.version();
-        case ScriptEngine.LANGUAGE:
+        } else if (ScriptEngine.LANGUAGE.equals(key)) {
             return "ECMAScript";
-        case ScriptEngine.LANGUAGE_VERSION:
+        } else if (ScriptEngine.LANGUAGE_VERSION.equals(key)) {
             return "ECMA - 262 Edition 5.1";
-        case "THREADING":
+        } else if ("THREADING".equals(key)) {
             // The engine implementation is not thread-safe. Can't be
             // used to execute scripts concurrently on multiple threads.
             return null;
-        default:
+        } else {
             throw new IllegalArgumentException("Invalid key");
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/api/scripting/ScriptObjectMirror.java
--- a/src/jdk/nashorn/api/scripting/ScriptObjectMirror.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/api/scripting/ScriptObjectMirror.java	Thu Feb 07 13:40:05 2013 +0100
@@ -93,7 +93,7 @@
         } catch (final RuntimeException e) {
             throw e;
         } catch (final Exception e) {
-            throw new AssertionError("Cannot happen", e);
+            throw new AssertionError("Cannot happen");
         } finally {
             if (globalChanged) {
                 NashornScriptEngine.setNashornGlobal(oldGlobal);
@@ -124,7 +124,9 @@
                     NashornScriptEngine.setNashornGlobal(global);
                 }
                 return wrap(((ScriptFunction)val).invoke(sobj, modifiedArgs), global);
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
@@ -226,12 +228,12 @@
         return inGlobal(new Callable<Set<Map.Entry<String, Object>>>() {
             @Override public Set<Map.Entry<String, Object>> call() {
                 final Iterator<String>               iter    = sobj.propertyIterator();
-                final Set<Map.Entry<String, Object>> entries = new HashSet<>();
+                final Set<Map.Entry<String, Object>> entries = new HashSet<Map.Entry<String, Object>>();
 
                 while (iter.hasNext()) {
                     final String key   = iter.next();
                     final Object value = translateUndefined(wrap(sobj.get(key), global));
-                    entries.add(new AbstractMap.SimpleImmutableEntry<>(key, value));
+                    entries.add(new AbstractMap.SimpleImmutableEntry<String, Object>(key, value));
                 }
 
                 return Collections.unmodifiableSet(entries);
@@ -262,7 +264,7 @@
         return inGlobal(new Callable<Set<String>>() {
             @Override public Set<String> call() {
                 final Iterator<String> iter   = sobj.propertyIterator();
-                final Set<String>      keySet = new HashSet<>();
+                final Set<String>      keySet = new HashSet<String>();
 
                 while (iter.hasNext()) {
                     keySet.add(iter.next());
@@ -317,7 +319,7 @@
     public Collection<Object> values() {
         return inGlobal(new Callable<Collection<Object>>() {
             @Override public Collection<Object> call() {
-                final List<Object>     values = new ArrayList<>(size());
+                final List<Object>     values = new ArrayList<Object>(size());
                 final Iterator<Object> iter   = sobj.valueIterator();
 
                 while (iter.hasNext()) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/Attr.java
--- a/src/jdk/nashorn/internal/codegen/Attr.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/Attr.java	Thu Feb 07 13:40:05 2013 +0100
@@ -165,8 +165,8 @@
             // from the outer level. But we need the copies, as when we
             // leave the block the def and use sets given upon entry must
             // be restored
-            localDefs = new HashSet<>(savedLocalDefs);
-            localUses = new HashSet<>(savedLocalUses);
+            localDefs = new HashSet<String>(savedLocalDefs);
+            localUses = new HashSet<String>(savedLocalUses);
 
             for (final Node statement : block.getStatements()) {
                 statement.accept(this);
@@ -189,7 +189,7 @@
 
         callNode.getFunction().accept(this);
 
-        final List<Node> acceptedArgs = new ArrayList<>(callNode.getArgs().size());
+        final List<Node> acceptedArgs = new ArrayList<Node>(callNode.getArgs().size());
         for (final Node arg : callNode.getArgs()) {
             LOG.info("Doing call arg " + arg);
             acceptedArgs.add(arg.accept(this));
@@ -284,7 +284,7 @@
          * @see NASHORN-73
          */
 
-        final List<Symbol> declaredSymbols = new ArrayList<>();
+        final List<Symbol> declaredSymbols = new ArrayList<Symbol>();
         for (final VarNode decl : functionNode.getDeclarations()) {
             final IdentNode ident = decl.getName();
             // any declared symbols that aren't visited need to be typed as well, hence the list
@@ -330,7 +330,7 @@
         if (functionNode.getSelfSymbolInit() != null) {
             LOG.info("Accepting self symbol init " + functionNode.getSelfSymbolInit() + " for " + functionNode.getName());
             final Node init = functionNode.getSelfSymbolInit();
-            final List<Node> newStatements = new ArrayList<>();
+            final List<Node> newStatements = new ArrayList<Node>();
             newStatements.add(init);
             newStatements.addAll(functionNode.getStatements());
             functionNode.setStatements(newStatements);
@@ -659,7 +659,7 @@
 
         Request request = Request.DELETE;
         final RuntimeNode runtimeNode;
-        final List<Node> args = new ArrayList<>();
+        final List<Node> args = new ArrayList<Node>();
 
         if (rhs instanceof IdentNode) {
             // If this is a declared variable or a function parameter, delete always fails (except for globals).
@@ -729,7 +729,7 @@
 
         RuntimeNode runtimeNode;
 
-        List<Node> args = new ArrayList<>();
+        List<Node> args = new ArrayList<Node>();
         if (rhs instanceof IdentNode && !rhs.getSymbol().isParam() && !rhs.getSymbol().isVar()) {
             args.add(getCurrentFunctionNode().getScopeNode());
             args.add(LiteralNode.newInstance(rhs, ((IdentNode)rhs).getName()).accept(this)); //null
@@ -1224,7 +1224,7 @@
      */
     private static void finalizeParameters(final FunctionNode functionNode) {
         boolean nonObjectParams = false;
-        List<Type> paramSpecializations = new ArrayList<>();
+        List<Type> paramSpecializations = new ArrayList<Type>();
 
         for (final IdentNode ident : functionNode.getParameters()) {
             final Symbol paramSymbol = ident.getSymbol();
@@ -1364,7 +1364,7 @@
      * @param functionNode
      */
     private static void finalizeTypes(final FunctionNode functionNode) {
-        final Set<Node> changed = new HashSet<>();
+        final Set<Node> changed = new HashSet<Node>();
         do {
             changed.clear();
             functionNode.accept(new NodeVisitor() {
@@ -1457,7 +1457,7 @@
 
     private static List<Block> findLookupBlocksHelper(final FunctionNode currentFunction, final FunctionNode topFunction) {
         if (currentFunction.findParentFunction() == topFunction) {
-            final List<Block> blocks = new LinkedList<>();
+            final List<Block> blocks = new LinkedList<Block>();
 
             blocks.add(currentFunction.getParent());
             blocks.addAll(currentFunction.getReferencingParentBlocks());
@@ -1512,7 +1512,7 @@
     }
 
     private void clearLocalDefs() {
-        localDefs = new HashSet<>();
+        localDefs = new HashSet<String>();
     }
 
     private boolean isLocalDef(final String name) {
@@ -1530,7 +1530,7 @@
     }
 
     private void clearLocalUses() {
-        localUses = new HashSet<>();
+        localUses = new HashSet<String>();
     }
 
     private void addLocalUse(final String name) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/ClassEmitter.java
--- a/src/jdk/nashorn/internal/codegen/ClassEmitter.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/ClassEmitter.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,18 +25,18 @@
 
 package jdk.nashorn.internal.codegen;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_VARARGS;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKEINTERFACE;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESPECIAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKEVIRTUAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_NEWINVOKESPECIAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.V1_7;
+import static org.objectweb.asm.Opcodes.ACC_FINAL;
+import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ACC_STATIC;
+import static org.objectweb.asm.Opcodes.ACC_SUPER;
+import static org.objectweb.asm.Opcodes.ACC_VARARGS;
+import static org.objectweb.asm.Opcodes.H_INVOKEINTERFACE;
+import static org.objectweb.asm.Opcodes.H_INVOKESPECIAL;
+import static org.objectweb.asm.Opcodes.H_INVOKESTATIC;
+import static org.objectweb.asm.Opcodes.H_INVOKEVIRTUAL;
+import static org.objectweb.asm.Opcodes.H_NEWINVOKESPECIAL;
+import static org.objectweb.asm.Opcodes.V1_7;
 import static jdk.nashorn.internal.codegen.CompilerConstants.CLINIT;
 import static jdk.nashorn.internal.codegen.CompilerConstants.CONSTANTS;
 import static jdk.nashorn.internal.codegen.CompilerConstants.GET_ARRAY_PREFIX;
@@ -56,10 +56,10 @@
 import java.util.EnumSet;
 import java.util.HashSet;
 import java.util.Set;
-import jdk.internal.org.objectweb.asm.ClassReader;
-import jdk.internal.org.objectweb.asm.ClassWriter;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.util.TraceClassVisitor;
 import jdk.nashorn.internal.codegen.types.Type;
 import jdk.nashorn.internal.ir.FunctionNode;
 import jdk.nashorn.internal.runtime.Context;
@@ -143,7 +143,7 @@
 
         this.context        = context;
         this.cw             = cw;
-        this.methodsStarted = new HashSet<>();
+        this.methodsStarted = new HashSet<MethodEmitter>();
     }
 
     /**
@@ -185,7 +185,7 @@
             });
 
         this.unitClassName        = unitClassName;
-        this.constantMethodNeeded = new HashSet<>();
+        this.constantMethodNeeded = new HashSet<Class<?>>();
 
         cw.visit(V1_7, ACC_PUBLIC | ACC_SUPER, unitClassName, null, Compiler.pathName(jdk.nashorn.internal.scripts.JS$.class.getName()), null);
         cw.visitSource(compiler.getSource().getName(), null);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/CodeGenerator.java
--- a/src/jdk/nashorn/internal/codegen/CodeGenerator.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/CodeGenerator.java	Thu Feb 07 13:40:05 2013 +0100
@@ -156,7 +156,7 @@
     private int regexFieldCount;
 
     /** Map of shared scope call sites */
-    private final Map<SharedScopeCall, SharedScopeCall> scopeCalls = new HashMap<>();
+    private final Map<SharedScopeCall, SharedScopeCall> scopeCalls = new HashMap<SharedScopeCall, SharedScopeCall>();
 
     /** When should we stop caching regexp expressions in fields to limit bytecode size? */
     private static final int MAX_REGEX_FIELDS = 2 * 1024;
@@ -377,8 +377,8 @@
      * @param symbols list of symbols.
      */
     private void initSymbols(final Iterable<Symbol> symbols) {
-        final LinkedList<Symbol> numbers = new LinkedList<>();
-        final LinkedList<Symbol> objects = new LinkedList<>();
+        final LinkedList<Symbol> numbers = new LinkedList<Symbol>();
+        final LinkedList<Symbol> objects = new LinkedList<Symbol>();
 
         for (final Symbol symbol : symbols) {
             /*
@@ -858,13 +858,13 @@
 
             // TODO for LET we can do better: if *block* does not contain any eval/with, we don't need its vars in scope.
 
-            final List<String> nameList = new ArrayList<>();
-            final List<Symbol> locals   = new ArrayList<>();
+            final List<String> nameList = new ArrayList<String>();
+            final List<Symbol> locals   = new ArrayList<Symbol>();
 
 
             // Initalize symbols and values
-            final List<Symbol> newSymbols = new ArrayList<>();
-            final List<Symbol> values     = new ArrayList<>();
+            final List<Symbol> newSymbols = new ArrayList<Symbol>();
+            final List<Symbol> values     = new ArrayList<Symbol>();
 
             final boolean hasArguments = function.needsArguments();
             for (final Symbol symbol : symbols) {
@@ -1312,9 +1312,9 @@
         final List<Node> elements = objectNode.getElements();
         final int        size     = elements.size();
 
-        final List<String> keys    = new ArrayList<>();
-        final List<Symbol> symbols = new ArrayList<>();
-        final List<Node>   values  = new ArrayList<>();
+        final List<String> keys    = new ArrayList<String>();
+        final List<Symbol> symbols = new ArrayList<Symbol>();
+        final List<Node>   values  = new ArrayList<Node>();
 
         boolean hasGettersSetters = false;
 
@@ -1785,7 +1785,7 @@
 
         if (allInteger) {
             // Tree for sorting values.
-            final TreeMap<Integer, Label> tree = new TreeMap<>();
+            final TreeMap<Integer, Label> tree = new TreeMap<Integer, Label>();
 
             // Build up sorted tree.
             for (final CaseNode caseNode : cases) {
@@ -2595,7 +2595,7 @@
             @Override
             protected void op() {
                 method.shr();
-                method.convert(Type.LONG).load(0xffff_ffffL).and();
+                method.convert(Type.LONG).load(0xffffffffL).and();
             }
         }.store();
 
@@ -2840,7 +2840,7 @@
             @Override
             protected void op() {
                 method.shr();
-                method.convert(Type.LONG).load(0xffff_ffffL).and();
+                method.convert(Type.LONG).load(0xffffffffL).and();
             }
         }.evaluate(binaryNode);
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/Compiler.java
--- a/src/jdk/nashorn/internal/codegen/Compiler.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/Compiler.java	Thu Feb 07 13:40:05 2013 +0100
@@ -227,7 +227,7 @@
         this.errors       = errors;
         this.strict       = strict;
         this.namespace    = new Namespace(context.getNamespace());
-        this.compileUnits = new HashSet<>();
+        this.compileUnits = new HashSet<CompileUnit>();
         this.constantData = new ConstantData();
         this.state        = EnumSet.of(State.INITIALIZED);
         this.dumpClass    = context._compile_only && context._dest_dir != null;
@@ -427,7 +427,7 @@
 
             state.add(State.EMITTED);
 
-            code = new TreeMap<>();
+            code = new TreeMap<String, byte[]>();
             for (final CompileUnit compileUnit : compileUnits) {
                 final ClassEmitter classEmitter = compileUnit.getClassEmitter();
                 classEmitter.end();
@@ -485,7 +485,13 @@
                 //use reflection to write source and constants table to installed classes
                 clazz.getField(SOURCE.tag()).set(null, source);
                 clazz.getField(CONSTANTS.tag()).set(null, constantData.toArray());
-            } catch (final NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {
+            } catch (final NoSuchFieldException e) {
+                throw new RuntimeException(e);
+            } catch (final SecurityException e) {
+                throw new RuntimeException(e);
+            } catch (final IllegalArgumentException e) {
+                throw new RuntimeException(e);
+            } catch (final IllegalAccessException e) {
                 throw new RuntimeException(e);
             }
         }
@@ -703,8 +709,11 @@
 
             final byte[] bytecode = entry.getValue();
             final File outFile = new File(context._dest_dir, fileName);
-            try (final FileOutputStream fos = new FileOutputStream(outFile)) {
+            final FileOutputStream fos = new FileOutputStream(outFile);
+            try {
                 fos.write(bytecode);
+            } finally {
+                fos.close();
             }
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/ConstantData.java
--- a/src/jdk/nashorn/internal/codegen/ConstantData.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/ConstantData.java	Thu Feb 07 13:40:05 2013 +0100
@@ -113,9 +113,9 @@
      * Constructor
      */
     ConstantData() {
-        this.constants = new ArrayList<>();
-        this.stringMap = new HashMap<>();
-        this.objectMap = new HashMap<>();
+        this.constants = new ArrayList<Object>();
+        this.stringMap = new HashMap<String, Integer>();
+        this.objectMap = new HashMap<Object, Integer>();
     }
 
     /**
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/FinalizeTypes.java
--- a/src/jdk/nashorn/internal/codegen/FinalizeTypes.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/FinalizeTypes.java	Thu Feb 07 13:40:05 2013 +0100
@@ -674,7 +674,7 @@
      * @param to   which primitive type to use for tagging
      */
     private static void setCanBePrimitive(final Node node, final Type to) {
-        final HashSet<Node> exclude = new HashSet<>();
+        final HashSet<Node> exclude = new HashSet<Node>();
 
         node.accept(new NodeVisitor() {
             private void setCanBePrimitive(final Symbol symbol) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/FoldConstants.java
--- a/src/jdk/nashorn/internal/codegen/FoldConstants.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/FoldConstants.java	Thu Feb 07 13:40:05 2013 +0100
@@ -232,7 +232,7 @@
                 value = lhs.getNumber() - rhs.getNumber();
                 break;
             case SHR:
-                return LiteralNode.newInstance(source, token, finish, (lhs.getInt32() >>> rhs.getInt32()) & 0xffff_ffffL);
+                return LiteralNode.newInstance(source, token, finish, (lhs.getInt32() >>> rhs.getInt32()) & 0xffffffffL);
             case SAR:
                 return LiteralNode.newInstance(source, token, finish, lhs.getInt32() >> rhs.getInt32());
             case SHL:
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/Frame.java
--- a/src/jdk/nashorn/internal/codegen/Frame.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/Frame.java	Thu Feb 07 13:40:05 2013 +0100
@@ -54,7 +54,7 @@
      */
     public Frame(final Frame previous) {
         this.previous  = previous;
-        this.symbols   = new ArrayList<>();
+        this.symbols   = new ArrayList<Symbol>();
         this.baseCount = getBaseCount();
         this.count     = 0;
     }
@@ -66,7 +66,7 @@
      */
     private Frame(final Frame frame, final List<Symbol> symbols) {
         this.previous  = frame.getPrevious() == null ? null : new Frame(frame.getPrevious(), frame.getPrevious().getSymbols());
-        this.symbols   = new ArrayList<>(frame.getSymbols());
+        this.symbols   = new ArrayList<Symbol>(frame.getSymbols());
         this.baseCount = frame.getBaseCount();
         this.count     = frame.getCount();
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/Lower.java
--- a/src/jdk/nashorn/internal/codegen/Lower.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/Lower.java	Thu Feb 07 13:40:05 2013 +0100
@@ -114,8 +114,8 @@
     Lower(final Compiler compiler) {
         this.compiler   = compiler;
         this.source     = compiler.getSource();
-        this.nesting    = new ArrayDeque<>();
-        this.statements = new ArrayList<>();
+        this.nesting    = new ArrayDeque<Node>();
+        this.statements = new ArrayList<Node>();
     }
 
     @Override
@@ -124,7 +124,7 @@
         final List<Node> savedStatements    = statements;
 
         try {
-            this.statements = new ArrayList<>();
+            this.statements = new ArrayList<Node>();
             for (final Node statement : block.getStatements()) {
                 statement.accept(this);
                 /*
@@ -268,7 +268,7 @@
         final List<Node> savedStatements = statements;
         final Node savedLastStatement = lastStatement;
 
-        statements    = new ArrayList<>();
+        statements    = new ArrayList<Node>();
         lastStatement = null;
 
         // for initial eval result is the last declared function
@@ -566,7 +566,7 @@
         catchBlock.addStatement(catchAllNode);
 
         // replace all catches of outer tryNode with the catch-all
-        tryNode.setCatchBlocks(new ArrayList<>(Arrays.asList(catchBlock)));
+        tryNode.setCatchBlocks(new ArrayList<Block>(Arrays.asList(catchBlock)));
 
         /*
          * We leave the finally block for the original try in place for now
@@ -764,7 +764,7 @@
      * @return true if control flow may escape the loop
      */
     private boolean controlFlowEscapes(final Node loopBody) {
-        final List<Node> escapes = new ArrayList<>();
+        final List<Node> escapes = new ArrayList<Node>();
 
         loopBody.accept(new NodeVisitor() {
             @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/MethodEmitter.java
--- a/src/jdk/nashorn/internal/codegen/MethodEmitter.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/MethodEmitter.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,38 +25,38 @@
 
 package jdk.nashorn.internal.codegen;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.ATHROW;
-import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP2;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.GOTO;
-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFEQ;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFGE;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFGT;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFLE;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFLT;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFNE;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFNONNULL;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFNULL;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ACMPEQ;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ACMPNE;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ICMPEQ;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ICMPGE;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ICMPGT;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ICMPLE;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ICMPLT;
-import static jdk.internal.org.objectweb.asm.Opcodes.IF_ICMPNE;
-import static jdk.internal.org.objectweb.asm.Opcodes.INSTANCEOF;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEINTERFACE;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.NEW;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;
-import static jdk.internal.org.objectweb.asm.Opcodes.PUTSTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
+import static org.objectweb.asm.Opcodes.ATHROW;
+import static org.objectweb.asm.Opcodes.CHECKCAST;
+import static org.objectweb.asm.Opcodes.DUP2;
+import static org.objectweb.asm.Opcodes.GETFIELD;
+import static org.objectweb.asm.Opcodes.GETSTATIC;
+import static org.objectweb.asm.Opcodes.GOTO;
+import static org.objectweb.asm.Opcodes.H_INVOKESTATIC;
+import static org.objectweb.asm.Opcodes.IFEQ;
+import static org.objectweb.asm.Opcodes.IFGE;
+import static org.objectweb.asm.Opcodes.IFGT;
+import static org.objectweb.asm.Opcodes.IFLE;
+import static org.objectweb.asm.Opcodes.IFLT;
+import static org.objectweb.asm.Opcodes.IFNE;
+import static org.objectweb.asm.Opcodes.IFNONNULL;
+import static org.objectweb.asm.Opcodes.IFNULL;
+import static org.objectweb.asm.Opcodes.IF_ACMPEQ;
+import static org.objectweb.asm.Opcodes.IF_ACMPNE;
+import static org.objectweb.asm.Opcodes.IF_ICMPEQ;
+import static org.objectweb.asm.Opcodes.IF_ICMPGE;
+import static org.objectweb.asm.Opcodes.IF_ICMPGT;
+import static org.objectweb.asm.Opcodes.IF_ICMPLE;
+import static org.objectweb.asm.Opcodes.IF_ICMPLT;
+import static org.objectweb.asm.Opcodes.IF_ICMPNE;
+import static org.objectweb.asm.Opcodes.INSTANCEOF;
+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;
+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
+import static org.objectweb.asm.Opcodes.INVOKESTATIC;
+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
+import static org.objectweb.asm.Opcodes.NEW;
+import static org.objectweb.asm.Opcodes.PUTFIELD;
+import static org.objectweb.asm.Opcodes.PUTSTATIC;
+import static org.objectweb.asm.Opcodes.RETURN;
 import static jdk.nashorn.internal.codegen.CompilerConstants.CONSTANTS;
 import static jdk.nashorn.internal.codegen.CompilerConstants.THIS;
 import static jdk.nashorn.internal.codegen.CompilerConstants.THIS_DEBUGGER;
@@ -71,8 +71,8 @@
 import java.util.ArrayDeque;
 import java.util.EnumSet;
 import java.util.Iterator;
-import jdk.internal.org.objectweb.asm.Handle;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
 import jdk.nashorn.internal.codegen.ClassEmitter.Flag;
 import jdk.nashorn.internal.codegen.CompilerConstants.Call;
 import jdk.nashorn.internal.codegen.CompilerConstants.FieldAccess;
@@ -189,7 +189,7 @@
     @Override
     public void begin() {
         classEmitter.beginMethod(this);
-        stack = new ArrayDeque<>();
+        stack = new ArrayDeque<Type>();
         method.visitCode();
     }
 
@@ -711,7 +711,7 @@
      */
     public MethodEmitter loadType(final String className) {
         debug("load type", className);
-        method.visitLdcInsn(jdk.internal.org.objectweb.asm.Type.getObjectType(className));
+        method.visitLdcInsn(org.objectweb.asm.Type.getObjectType(className));
         pushType(Type.OBJECT);
         return this;
     }
@@ -1613,7 +1613,7 @@
         if (stack == null) {
             stack = label.getStack();
             if (stack == null) {
-                stack = new ArrayDeque<>(); //we don't have a stack at this point.
+                stack = new ArrayDeque<Type>(); //we don't have a stack at this point.
             }
         }
         debug_label(label);
@@ -1968,27 +1968,22 @@
 
      @SuppressWarnings("fallthrough")
      private static Type fieldType(final String desc) {
-         switch (desc) {
-         case "Z":
-         case "B":
-         case "C":
-         case "S":
-         case "I":
+         if ("Z".equals(desc) || "B".equals(desc) || "C".equals(desc) || "S".equals(desc) || "I".equals(desc)) {
              return Type.INT;
-         case "F":
+         } else if ("F".equals(desc)) {
              assert false;
-         case "D":
              return Type.NUMBER;
-         case "J":
+         } else if ("D".equals(desc)) {
+             return Type.NUMBER;
+         } else if ("J".equals(desc)) {
              return Type.LONG;
-         default:
+         } else {
              assert desc.startsWith("[") || desc.startsWith("L") : desc + " is not an object type";
-             switch (desc.charAt(0)) {
-             case 'L':
+             if (desc.charAt(0) == 'L') {
                  return Type.OBJECT;
-             case '[':
+             } else if (desc.charAt(0) == '[') {
                  return Type.typeFor(Array.newInstance(fieldType(desc.substring(1)).getTypeClass(), 0).getClass());
-             default:
+             } else {
                  assert false;
              }
              return Type.OBJECT;
@@ -2249,7 +2244,7 @@
      *
      * see -Dnashorn.codegen.debug, --log=codegen
      */
-    public static class Label extends jdk.internal.org.objectweb.asm.Label {
+    public static class Label extends org.objectweb.asm.Label {
         /** Name of this label */
         private final String name;
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/Namespace.java
--- a/src/jdk/nashorn/internal/codegen/Namespace.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/Namespace.java	Thu Feb 07 13:40:05 2013 +0100
@@ -53,7 +53,7 @@
      */
     public Namespace(final Namespace parent) {
         this.parent    = parent;
-        directory = new HashMap<>();
+        directory = new HashMap<String, Integer>();
     }
 
     /**
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/RuntimeCallSite.java
--- a/src/jdk/nashorn/internal/codegen/RuntimeCallSite.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/RuntimeCallSite.java	Thu Feb 07 13:40:05 2013 +0100
@@ -366,7 +366,7 @@
     private static final Map<String, MethodHandle> METHODS;
 
     /** Generic method cache */
-    private static final Map<String, MethodHandle> GENERIC_METHODS;
+    private static final Map<String, MethodHandle> GENERIC_METHODS = new HashMap<String, MethodHandle>();;
 
     /** Unbox cache */
     private static final Map<Class<?>, MethodHandle> UNBOX;
@@ -379,13 +379,13 @@
      * Build maps of correct boxing operations
      */
     static {
-        UNBOX = new HashMap<>();
+        UNBOX = new HashMap<Class<?>, MethodHandle>();
         UNBOX.put(Boolean.class, findOwnMH("unboxZ", int.class, Object.class));
         UNBOX.put(Integer.class, findOwnMH("unboxI", int.class, Object.class));
         UNBOX.put(Long.class,    findOwnMH("unboxJ", long.class, Object.class));
         UNBOX.put(Number.class,  findOwnMH("unboxD", double.class, Object.class));
 
-        METHODS = new HashMap<>();
+        METHODS = new HashMap<String, MethodHandle>();
 
         for (final Request req : Request.values()) {
             if (req.canSpecialize()) {
@@ -401,7 +401,6 @@
             }
         }
 
-        GENERIC_METHODS = new HashMap<>();
         for (final Request req : Request.values()) {
             if (req.canSpecialize()) {
                 GENERIC_METHODS.put(req.name(), MH.findStatic(MethodHandles.lookup(), ScriptRuntime.class, req.name(),
@@ -664,7 +663,7 @@
      * @return an int value for the boolean, 1 is true, 0 is false
      */
     public static int unboxZ(final Object obj) {
-        return (boolean)obj ? 1 : 0;
+        return (Boolean)obj ? 1 : 0;
     }
 
     /**
@@ -673,7 +672,7 @@
      * @return an int
      */
     public static int unboxI(final Object obj) {
-        return (int)obj;
+        return (Integer)obj;
     }
 
     /**
@@ -682,7 +681,7 @@
      * @return a long
      */
     public static long unboxJ(final Object obj) {
-        return (long)obj;
+        return (Long)obj;
     }
 
     /**
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/Splitter.java
--- a/src/jdk/nashorn/internal/codegen/Splitter.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/Splitter.java	Thu Feb 07 13:40:05 2013 +0100
@@ -66,7 +66,7 @@
     private final CompileUnit scriptCompileUnit;
 
     /** Cache for calculated block weights. */
-    private final Map<Node, Long> weightCache = new HashMap<>();
+    private final Map<Node, Long> weightCache = new HashMap<Node, Long>();
 
     /** Weight threshold for when to start a split. */
     public static final long SPLIT_THRESHOLD = Options.getIntProperty("nashorn.compiler.splitter.threshold", 32 * 1024);
@@ -147,8 +147,8 @@
     private long splitBlock(final Block block) {
         functionNode.setIsSplit();
 
-        final List<Node> splits = new ArrayList<>();
-        List<Node> statements = new ArrayList<>();
+        final List<Node> splits = new ArrayList<Node>();
+        List<Node> statements = new ArrayList<Node>();
         long statementsWeight = 0;
 
         for (final Node statement : block.getStatements()) {
@@ -157,7 +157,7 @@
             if (statementsWeight + weight >= SPLIT_THRESHOLD || statement.isTerminal()) {
                 if (!statements.isEmpty()) {
                     splits.add(createBlockSplitNode(block, statements, statementsWeight));
-                    statements = new ArrayList<>();
+                    statements = new ArrayList<Node>();
                     statementsWeight = 0;
                 }
 
@@ -251,7 +251,7 @@
             final ArrayLiteralNode arrayLiteralNode = (ArrayLiteralNode) literal;
             final Node[]           value            = arrayLiteralNode.getValue();
             final int[]            postsets         = arrayLiteralNode.getPostsets();
-            final List<ArrayUnit>  units            = new ArrayList<>();
+            final List<ArrayUnit>  units            = new ArrayList<ArrayUnit>();
 
             long totalWeight = 0;
             int  lo          = 0;
@@ -299,10 +299,10 @@
         private final Deque<SplitNode> splitStack;
 
         /** Map of possible jump targets to containing split node */
-        private final Map<Node,SplitNode> targetNodes = new HashMap<>();
+        private final Map<Node,SplitNode> targetNodes = new HashMap<Node,SplitNode>();
 
         SplitFlowAnalyzer() {
-            this.splitStack = new LinkedList<>();
+            this.splitStack = new LinkedList<SplitNode>();
         }
 
         @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/objects/MapCreator.java
--- a/src/jdk/nashorn/internal/codegen/objects/MapCreator.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/objects/MapCreator.java	Thu Feb 07 13:40:05 2013 +0100
@@ -77,7 +77,7 @@
      * @return New map populated with accessor properties.
      */
     public PropertyMap makeMap(final boolean isVarArg) {
-        final List<Property> properties = new ArrayList<>();
+        final List<Property> properties = new ArrayList<Property>();
 
         assert keys != null;
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/objects/ObjectClassGenerator.java
--- a/src/jdk/nashorn/internal/codegen/objects/ObjectClassGenerator.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/objects/ObjectClassGenerator.java	Thu Feb 07 13:40:05 2013 +0100
@@ -92,7 +92,7 @@
     public static final boolean OBJECT_FIELDS_ONLY = !Options.getBooleanProperty("nashorn.fields.dual");
 
     /** The field types in the system */
-    private static final List<Type> FIELD_TYPES = new LinkedList<>();
+    private static final List<Type> FIELD_TYPES = new LinkedList<Type>();
 
     /** What type is the primitive type in dual representation */
     public static final Type PRIMITIVE_TYPE = Type.LONG;
@@ -347,7 +347,7 @@
      * @return List fields that need to be initialized.
      */
     private static List<String> addFields(final ClassEmitter classEmitter, final int fieldCount) {
-        final List<String> initFields = new LinkedList<>();
+        final List<String> initFields = new LinkedList<String>();
 
         for (int i = 0; i < fieldCount; i++) {
             for (final Type type : FIELD_TYPES) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/ArrayType.java
--- a/src/jdk/nashorn/internal/codegen/types/ArrayType.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/ArrayType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,13 +25,13 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.AALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.AASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ANEWARRAY;
-import static jdk.internal.org.objectweb.asm.Opcodes.ARRAYLENGTH;
+import static org.objectweb.asm.Opcodes.AALOAD;
+import static org.objectweb.asm.Opcodes.AASTORE;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.ANEWARRAY;
+import static org.objectweb.asm.Opcodes.ARRAYLENGTH;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 
 /**
  * This is an array type, i.e. OBJECT_ARRAY, NUMBER_ARRAY.
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/BooleanType.java
--- a/src/jdk/nashorn/internal/codegen/types/BooleanType.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/BooleanType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -50,14 +50,14 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;
-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.IRETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.ISTORE;
+import static org.objectweb.asm.Opcodes.ICONST_0;
+import static org.objectweb.asm.Opcodes.ICONST_1;
+import static org.objectweb.asm.Opcodes.ILOAD;
+import static org.objectweb.asm.Opcodes.IRETURN;
+import static org.objectweb.asm.Opcodes.ISTORE;
 import static jdk.nashorn.internal.codegen.CompilerConstants.staticCallNoLookup;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 import jdk.nashorn.internal.codegen.CompilerConstants;
 import jdk.nashorn.internal.codegen.objects.ObjectClassGenerator;
 import jdk.nashorn.internal.runtime.JSType;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/BytecodeArrayOps.java
--- a/src/jdk/nashorn/internal/codegen/types/BytecodeArrayOps.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/BytecodeArrayOps.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,7 +25,7 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 
 /**
  * Array operations, not supported by all ops
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/BytecodeBitwiseOps.java
--- a/src/jdk/nashorn/internal/codegen/types/BytecodeBitwiseOps.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/BytecodeBitwiseOps.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,7 +25,7 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 
 /**
  * Bitwise operations not supported by all types
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/BytecodeNumericOps.java
--- a/src/jdk/nashorn/internal/codegen/types/BytecodeNumericOps.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/BytecodeNumericOps.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,7 +25,7 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 
 /**
  * Numeric operations, not supported by all types
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/BytecodeOps.java
--- a/src/jdk/nashorn/internal/codegen/types/BytecodeOps.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/BytecodeOps.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,7 +25,7 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 
 
 /**
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/IntType.java
--- a/src/jdk/nashorn/internal/codegen/types/IntType.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/IntType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,35 +25,35 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;
-import static jdk.internal.org.objectweb.asm.Opcodes.I2D;
-import static jdk.internal.org.objectweb.asm.Opcodes.I2L;
-import static jdk.internal.org.objectweb.asm.Opcodes.IADD;
-import static jdk.internal.org.objectweb.asm.Opcodes.IAND;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_3;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_4;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_5;
-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_M1;
-import static jdk.internal.org.objectweb.asm.Opcodes.IDIV;
-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.IMUL;
-import static jdk.internal.org.objectweb.asm.Opcodes.INEG;
-import static jdk.internal.org.objectweb.asm.Opcodes.IOR;
-import static jdk.internal.org.objectweb.asm.Opcodes.IREM;
-import static jdk.internal.org.objectweb.asm.Opcodes.IRETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.ISHL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ISHR;
-import static jdk.internal.org.objectweb.asm.Opcodes.ISTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ISUB;
-import static jdk.internal.org.objectweb.asm.Opcodes.IUSHR;
-import static jdk.internal.org.objectweb.asm.Opcodes.IXOR;
-import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;
+import static org.objectweb.asm.Opcodes.BIPUSH;
+import static org.objectweb.asm.Opcodes.I2D;
+import static org.objectweb.asm.Opcodes.I2L;
+import static org.objectweb.asm.Opcodes.IADD;
+import static org.objectweb.asm.Opcodes.IAND;
+import static org.objectweb.asm.Opcodes.ICONST_0;
+import static org.objectweb.asm.Opcodes.ICONST_1;
+import static org.objectweb.asm.Opcodes.ICONST_2;
+import static org.objectweb.asm.Opcodes.ICONST_3;
+import static org.objectweb.asm.Opcodes.ICONST_4;
+import static org.objectweb.asm.Opcodes.ICONST_5;
+import static org.objectweb.asm.Opcodes.ICONST_M1;
+import static org.objectweb.asm.Opcodes.IDIV;
+import static org.objectweb.asm.Opcodes.ILOAD;
+import static org.objectweb.asm.Opcodes.IMUL;
+import static org.objectweb.asm.Opcodes.INEG;
+import static org.objectweb.asm.Opcodes.IOR;
+import static org.objectweb.asm.Opcodes.IREM;
+import static org.objectweb.asm.Opcodes.IRETURN;
+import static org.objectweb.asm.Opcodes.ISHL;
+import static org.objectweb.asm.Opcodes.ISHR;
+import static org.objectweb.asm.Opcodes.ISTORE;
+import static org.objectweb.asm.Opcodes.ISUB;
+import static org.objectweb.asm.Opcodes.IUSHR;
+import static org.objectweb.asm.Opcodes.IXOR;
+import static org.objectweb.asm.Opcodes.SIPUSH;
 import static jdk.nashorn.internal.codegen.CompilerConstants.staticCallNoLookup;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 import jdk.nashorn.internal.codegen.CompilerConstants;
 import jdk.nashorn.internal.codegen.objects.ObjectClassGenerator;
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/LongType.java
--- a/src/jdk/nashorn/internal/codegen/types/LongType.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/LongType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,29 +25,29 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.L2D;
-import static jdk.internal.org.objectweb.asm.Opcodes.L2I;
-import static jdk.internal.org.objectweb.asm.Opcodes.LADD;
-import static jdk.internal.org.objectweb.asm.Opcodes.LAND;
-import static jdk.internal.org.objectweb.asm.Opcodes.LCMP;
-import static jdk.internal.org.objectweb.asm.Opcodes.LCONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.LCONST_1;
-import static jdk.internal.org.objectweb.asm.Opcodes.LDIV;
-import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.LMUL;
-import static jdk.internal.org.objectweb.asm.Opcodes.LNEG;
-import static jdk.internal.org.objectweb.asm.Opcodes.LOR;
-import static jdk.internal.org.objectweb.asm.Opcodes.LREM;
-import static jdk.internal.org.objectweb.asm.Opcodes.LRETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.LSHL;
-import static jdk.internal.org.objectweb.asm.Opcodes.LSHR;
-import static jdk.internal.org.objectweb.asm.Opcodes.LSTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.LSUB;
-import static jdk.internal.org.objectweb.asm.Opcodes.LUSHR;
-import static jdk.internal.org.objectweb.asm.Opcodes.LXOR;
+import static org.objectweb.asm.Opcodes.L2D;
+import static org.objectweb.asm.Opcodes.L2I;
+import static org.objectweb.asm.Opcodes.LADD;
+import static org.objectweb.asm.Opcodes.LAND;
+import static org.objectweb.asm.Opcodes.LCMP;
+import static org.objectweb.asm.Opcodes.LCONST_0;
+import static org.objectweb.asm.Opcodes.LCONST_1;
+import static org.objectweb.asm.Opcodes.LDIV;
+import static org.objectweb.asm.Opcodes.LLOAD;
+import static org.objectweb.asm.Opcodes.LMUL;
+import static org.objectweb.asm.Opcodes.LNEG;
+import static org.objectweb.asm.Opcodes.LOR;
+import static org.objectweb.asm.Opcodes.LREM;
+import static org.objectweb.asm.Opcodes.LRETURN;
+import static org.objectweb.asm.Opcodes.LSHL;
+import static org.objectweb.asm.Opcodes.LSHR;
+import static org.objectweb.asm.Opcodes.LSTORE;
+import static org.objectweb.asm.Opcodes.LSUB;
+import static org.objectweb.asm.Opcodes.LUSHR;
+import static org.objectweb.asm.Opcodes.LXOR;
 import static jdk.nashorn.internal.codegen.CompilerConstants.staticCallNoLookup;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 import jdk.nashorn.internal.codegen.CompilerConstants;
 import jdk.nashorn.internal.codegen.objects.ObjectClassGenerator;
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/NumberType.java
--- a/src/jdk/nashorn/internal/codegen/types/NumberType.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/NumberType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,22 +25,22 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.DADD;
-import static jdk.internal.org.objectweb.asm.Opcodes.DCMPG;
-import static jdk.internal.org.objectweb.asm.Opcodes.DCMPL;
-import static jdk.internal.org.objectweb.asm.Opcodes.DCONST_0;
-import static jdk.internal.org.objectweb.asm.Opcodes.DCONST_1;
-import static jdk.internal.org.objectweb.asm.Opcodes.DDIV;
-import static jdk.internal.org.objectweb.asm.Opcodes.DLOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.DMUL;
-import static jdk.internal.org.objectweb.asm.Opcodes.DNEG;
-import static jdk.internal.org.objectweb.asm.Opcodes.DREM;
-import static jdk.internal.org.objectweb.asm.Opcodes.DRETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.DSTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.DSUB;
+import static org.objectweb.asm.Opcodes.DADD;
+import static org.objectweb.asm.Opcodes.DCMPG;
+import static org.objectweb.asm.Opcodes.DCMPL;
+import static org.objectweb.asm.Opcodes.DCONST_0;
+import static org.objectweb.asm.Opcodes.DCONST_1;
+import static org.objectweb.asm.Opcodes.DDIV;
+import static org.objectweb.asm.Opcodes.DLOAD;
+import static org.objectweb.asm.Opcodes.DMUL;
+import static org.objectweb.asm.Opcodes.DNEG;
+import static org.objectweb.asm.Opcodes.DREM;
+import static org.objectweb.asm.Opcodes.DRETURN;
+import static org.objectweb.asm.Opcodes.DSTORE;
+import static org.objectweb.asm.Opcodes.DSUB;
 import static jdk.nashorn.internal.codegen.CompilerConstants.staticCallNoLookup;
 
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 import jdk.nashorn.internal.codegen.CompilerConstants;
 import jdk.nashorn.internal.codegen.objects.ObjectClassGenerator;
 import jdk.nashorn.internal.runtime.JSType;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/ObjectType.java
--- a/src/jdk/nashorn/internal/codegen/types/ObjectType.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/ObjectType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,18 +25,18 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.ACONST_NULL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;
-import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;
+import static org.objectweb.asm.Opcodes.ACONST_NULL;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.ARETURN;
+import static org.objectweb.asm.Opcodes.ASTORE;
+import static org.objectweb.asm.Opcodes.CHECKCAST;
+import static org.objectweb.asm.Opcodes.GETSTATIC;
 import static jdk.nashorn.internal.codegen.CompilerConstants.className;
 import static jdk.nashorn.internal.codegen.CompilerConstants.typeDescriptor;
 
 import java.lang.invoke.MethodHandle;
-import jdk.internal.org.objectweb.asm.Handle;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
 import jdk.nashorn.internal.codegen.CompilerConstants;
 import jdk.nashorn.internal.runtime.JSType;
 import jdk.nashorn.internal.runtime.ScriptRuntime;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/codegen/types/Type.java
--- a/src/jdk/nashorn/internal/codegen/types/Type.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/codegen/types/Type.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,30 +25,30 @@
 
 package jdk.nashorn.internal.codegen.types;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.DALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.DASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP2;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP2_X1;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP2_X2;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP_X1;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP_X2;
-import static jdk.internal.org.objectweb.asm.Opcodes.IALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.IASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;
-import static jdk.internal.org.objectweb.asm.Opcodes.POP;
-import static jdk.internal.org.objectweb.asm.Opcodes.POP2;
-import static jdk.internal.org.objectweb.asm.Opcodes.SWAP;
-import static jdk.internal.org.objectweb.asm.Opcodes.T_DOUBLE;
-import static jdk.internal.org.objectweb.asm.Opcodes.T_INT;
+import static org.objectweb.asm.Opcodes.DALOAD;
+import static org.objectweb.asm.Opcodes.DASTORE;
+import static org.objectweb.asm.Opcodes.DUP;
+import static org.objectweb.asm.Opcodes.DUP2;
+import static org.objectweb.asm.Opcodes.DUP2_X1;
+import static org.objectweb.asm.Opcodes.DUP2_X2;
+import static org.objectweb.asm.Opcodes.DUP_X1;
+import static org.objectweb.asm.Opcodes.DUP_X2;
+import static org.objectweb.asm.Opcodes.IALOAD;
+import static org.objectweb.asm.Opcodes.IASTORE;
+import static org.objectweb.asm.Opcodes.INVOKESTATIC;
+import static org.objectweb.asm.Opcodes.LASTORE;
+import static org.objectweb.asm.Opcodes.NEWARRAY;
+import static org.objectweb.asm.Opcodes.POP;
+import static org.objectweb.asm.Opcodes.POP2;
+import static org.objectweb.asm.Opcodes.SWAP;
+import static org.objectweb.asm.Opcodes.T_DOUBLE;
+import static org.objectweb.asm.Opcodes.T_INT;
 
 import java.lang.invoke.MethodHandle;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
-import jdk.internal.org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.MethodVisitor;
 import jdk.nashorn.internal.codegen.CompilerConstants.Call;
 
 
@@ -119,7 +119,7 @@
      * @return descriptor string
      */
     public static String getDescriptor(final Class<?> type) {
-        return jdk.internal.org.objectweb.asm.Type.getDescriptor(type);
+        return org.objectweb.asm.Type.getDescriptor(type);
     }
 
     /**
@@ -166,11 +166,11 @@
      * @return a descriptor string
      */
     public static String getMethodDescriptor(final Type returnType, final Type... types) {
-        final jdk.internal.org.objectweb.asm.Type[] itypes = new jdk.internal.org.objectweb.asm.Type[types.length];
+        final org.objectweb.asm.Type[] itypes = new org.objectweb.asm.Type[types.length];
         for (int i = 0; i < types.length; i++) {
             itypes[i] = types[i].getInternalType();
         }
-        return jdk.internal.org.objectweb.asm.Type.getMethodDescriptor(returnType.getInternalType(), itypes);
+        return org.objectweb.asm.Type.getMethodDescriptor(returnType.getInternalType(), itypes);
     }
 
     /**
@@ -182,11 +182,11 @@
      * @return a descriptor string
      */
     public static String getMethodDescriptor(final Class<?> returnType, final Class<?>... types) {
-        final jdk.internal.org.objectweb.asm.Type[] itypes = new jdk.internal.org.objectweb.asm.Type[types.length];
+        final org.objectweb.asm.Type[] itypes = new org.objectweb.asm.Type[types.length];
         for (int i = 0; i < types.length; i++) {
             itypes[i] = getInternalType(types[i]);
         }
-        return jdk.internal.org.objectweb.asm.Type.getMethodDescriptor(getInternalType(returnType), itypes);
+        return org.objectweb.asm.Type.getMethodDescriptor(getInternalType(returnType), itypes);
     }
 
     /**
@@ -197,31 +197,31 @@
      * @return Nashorn type
      */
     @SuppressWarnings("fallthrough")
-    static Type typeFor(final jdk.internal.org.objectweb.asm.Type itype) {
+    static Type typeFor(final org.objectweb.asm.Type itype) {
         switch (itype.getSort()) {
-        case jdk.internal.org.objectweb.asm.Type.BOOLEAN:
+        case org.objectweb.asm.Type.BOOLEAN:
             return BOOLEAN;
-        case jdk.internal.org.objectweb.asm.Type.INT:
+        case org.objectweb.asm.Type.INT:
             return INT;
-        case jdk.internal.org.objectweb.asm.Type.LONG:
+        case org.objectweb.asm.Type.LONG:
             return LONG;
-        case jdk.internal.org.objectweb.asm.Type.DOUBLE:
+        case org.objectweb.asm.Type.DOUBLE:
             return NUMBER;
-        case jdk.internal.org.objectweb.asm.Type.OBJECT:
+        case org.objectweb.asm.Type.OBJECT:
             return OBJECT;
-        case jdk.internal.org.objectweb.asm.Type.VOID:
+        case org.objectweb.asm.Type.VOID:
             return null;
-        case jdk.internal.org.objectweb.asm.Type.ARRAY:
+        case org.objectweb.asm.Type.ARRAY:
             switch (itype.getElementType().getSort()) {
-            case jdk.internal.org.objectweb.asm.Type.DOUBLE:
+            case org.objectweb.asm.Type.DOUBLE:
                 return NUMBER_ARRAY;
-            case jdk.internal.org.objectweb.asm.Type.INT:
+            case org.objectweb.asm.Type.INT:
                 return INT_ARRAY;
-            case jdk.internal.org.objectweb.asm.Type.LONG:
+            case org.objectweb.asm.Type.LONG:
                 return LONG_ARRAY;
             default:
                 assert false;
-            case jdk.internal.org.objectweb.asm.Type.OBJECT:
+            case org.objectweb.asm.Type.OBJECT:
                 return OBJECT_ARRAY;
             }
 
@@ -239,7 +239,7 @@
      * @return return type
      */
     public static Type getMethodReturnType(final String methodDescriptor) {
-        return Type.typeFor(jdk.internal.org.objectweb.asm.Type.getReturnType(methodDescriptor));
+        return Type.typeFor(org.objectweb.asm.Type.getReturnType(methodDescriptor));
     }
 
     /**
@@ -249,7 +249,7 @@
      * @return parameter type array
      */
     public static Type[] getMethodArguments(final String methodDescriptor) {
-        final jdk.internal.org.objectweb.asm.Type itypes[] = jdk.internal.org.objectweb.asm.Type.getArgumentTypes(methodDescriptor);
+        final org.objectweb.asm.Type itypes[] = org.objectweb.asm.Type.getArgumentTypes(methodDescriptor);
         final Type types[] = new Type[itypes.length];
         for (int i = 0; i < itypes.length; i++) {
             types[i] = Type.typeFor(itypes[i]);
@@ -257,16 +257,16 @@
         return types;
     }
 
-    static jdk.internal.org.objectweb.asm.Type getInternalType(final String className) {
-        return jdk.internal.org.objectweb.asm.Type.getType(className);
+    static org.objectweb.asm.Type getInternalType(final String className) {
+        return org.objectweb.asm.Type.getType(className);
     }
 
-    private jdk.internal.org.objectweb.asm.Type getInternalType() {
-        return jdk.internal.org.objectweb.asm.Type.getType(getTypeClass());
+    private org.objectweb.asm.Type getInternalType() {
+        return org.objectweb.asm.Type.getType(getTypeClass());
     }
 
-    private static jdk.internal.org.objectweb.asm.Type getInternalType(final Class<?> type) {
-        return jdk.internal.org.objectweb.asm.Type.getType(type);
+    private static org.objectweb.asm.Type getInternalType(final Class<?> type) {
+        return org.objectweb.asm.Type.getType(type);
     }
 
     static void invokeStatic(final MethodVisitor method, final Call call) {
@@ -278,7 +278,7 @@
      * @return the internal name
      */
     public String getInternalName() {
-        return jdk.internal.org.objectweb.asm.Type.getInternalName(getTypeClass());
+        return org.objectweb.asm.Type.getInternalName(getTypeClass());
     }
 
     /**
@@ -287,7 +287,7 @@
      * @return the internal name
      */
     public static String getInternalName(final Class<?> clazz) {
-        return jdk.internal.org.objectweb.asm.Type.getInternalName(clazz);
+        return org.objectweb.asm.Type.getInternalName(clazz);
     }
 
     /**
@@ -779,7 +779,7 @@
     };
 
     /** Singleton for method handle arrays used for properties etc. */
-    public static final ArrayType METHODHANDLE_ARRAY = new ArrayType(MethodHandle[].class);
+    public static final ArrayType METHODHANDLE_ARRAY = null; //new ArrayType(MethodHandle[].class);
 
     /** This is the singleton for string arrays */
     public static final ArrayType STRING_ARRAY = new ArrayType(String[].class);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/compat/Objects.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/jdk/nashorn/internal/compat/Objects.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.nashorn.internal.compat;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public final class Objects {
+
+    public Objects() {
+        super();
+    }
+
+    public static int hashCode(Object o) {
+        if (o == null) {
+            return 0;
+        }
+        return o.hashCode();
+    }
+
+    public static String toString(Object o) {
+        return String.valueOf(o);
+    }
+
+    public static boolean equals(Object o1, Object o2) {
+        if (o1 == o2) {
+            return true;
+        }
+        return o1 != null && o1.equals(o2);
+    }
+}
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/Block.java
--- a/src/jdk/nashorn/internal/ir/Block.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/Block.java	Thu Feb 07 13:40:05 2013 +0100
@@ -93,8 +93,8 @@
 
         this.parent     = parent;
         this.function   = function;
-        this.statements = new ArrayList<>();
-        this.symbols    = new HashMap<>();
+        this.statements = new ArrayList<Node>();
+        this.symbols    = new HashMap<String, Symbol>();
         this.frame      = null;
         this.entryLabel = new Label("block_entry");
         this.breakLabel = new Label("block_break");
@@ -111,11 +111,11 @@
 
         parent     = block.parent;
         function   = block.function;
-        statements = new ArrayList<>();
+        statements = new ArrayList<Node>();
         for (final Node statement : block.getStatements()) {
             statements.add(cs.existingOrCopy(statement));
         }
-        symbols    = new HashMap<>();
+        symbols    = new HashMap<String, Symbol>();
         frame      = block.frame == null ? null : block.frame.copy();
         entryLabel = new Label(block.entryLabel);
         breakLabel = new Label(block.breakLabel);
@@ -197,7 +197,7 @@
      */
     public void prependStatement(final Node statement) {
         if (statement != null) {
-            final List<Node> newStatements = new ArrayList<>();
+            final List<Node> newStatements = new ArrayList<Node>();
             newStatements.add(statement);
             newStatements.addAll(statements);
             setStatements(newStatements);
@@ -466,7 +466,7 @@
      * @return true if symbols were found
      */
     public boolean printSymbols(final PrintWriter stream) {
-        final List<Symbol> values = new ArrayList<>(symbols.values());
+        final List<Symbol> values = new ArrayList<Symbol>(symbols.values());
 
         Collections.sort(values, new Comparator<Symbol>() {
             @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/CallNode.java
--- a/src/jdk/nashorn/internal/ir/CallNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/CallNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -159,7 +159,7 @@
     private CallNode(final CallNode callNode, final CopyState cs) {
         super(callNode);
 
-        final List<Node> newArgs = new ArrayList<>();
+        final List<Node> newArgs = new ArrayList<Node>();
 
         for (final Node arg : callNode.args) {
             newArgs.add(cs.existingOrCopy(arg));
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/FunctionNode.java
--- a/src/jdk/nashorn/internal/ir/FunctionNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/FunctionNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -151,31 +151,31 @@
     private int flags;
 
     /** Is anonymous function flag. */
-    private static final int IS_ANONYMOUS                = 0b0000_0000_0000_0001;
+    private static final int IS_ANONYMOUS                = 0x0001; //0b0000_0000_0000_0001;
     /** Is statement flag */
-    private static final int IS_STATEMENT                = 0b0000_0000_0000_0010;
+    private static final int IS_STATEMENT                = 0x0002; //0b0000_0000_0000_0010;
     /** is this a strict mode function? */
-    private static final int IS_STRICT_MODE              = 0b0000_0000_0000_0100;
+    private static final int IS_STRICT_MODE              = 0x0004; //0b0000_0000_0000_0100;
     /** Does the function use the "arguments" identifier ? */
-    private static final int USES_ARGUMENTS              = 0b0000_0000_0000_1000;
+    private static final int USES_ARGUMENTS              = 0x0008; //0b0000_0000_0000_1000;
     /** Are we lowered ? */
-    private static final int IS_LOWERED                  = 0b0000_0000_0001_0000;
+    private static final int IS_LOWERED                  = 0x0010; //0b0000_0000_0001_0000;
     /** Has this node been split because it was too large? */
-    private static final int IS_SPLIT                    = 0b0000_0000_0010_0000;
+    private static final int IS_SPLIT                    = 0x0020; //0b0000_0000_0010_0000;
     /** Is this function lazily compiled? */
-    private static final int IS_LAZY                     = 0b0000_0000_0100_0000;
+    private static final int IS_LAZY                     = 0x0040; //0b0000_0000_0100_0000;
     /** Does the function call eval? */
-    private static final int HAS_EVAL                    = 0b0000_0000_1000_0000;
+    private static final int HAS_EVAL                    = 0x0080; //0b0000_0000_1000_0000;
     /** Does the function contain a with block ? */
-    private static final int HAS_WITH                    = 0b0000_0001_0000_0000;
+    private static final int HAS_WITH                    = 0x0100; //0b0000_0001_0000_0000;
     /** Does a descendant function contain a with or eval? */
-    private static final int HAS_DESCENDANT_WITH_OR_EVAL = 0b0000_0010_0000_0000;
+    private static final int HAS_DESCENDANT_WITH_OR_EVAL = 0x0200; //0b0000_0010_0000_0000;
     /** Does the function define "arguments" identifier as a parameter of nested function name? */
-    private static final int DEFINES_ARGUMENTS           = 0b0000_0100_0000_0000;
+    private static final int DEFINES_ARGUMENTS           = 0x0400; //0b0000_0100_0000_0000;
     /** Does the function need a self symbol? */
-    private static final int NEEDS_SELF_SYMBOL           = 0b0000_1000_0000_0000;
+    private static final int NEEDS_SELF_SYMBOL           = 0x0800; //0b0000_1000_0000_0000;
     /** Does this function or any of its descendants use variables from an ancestor function's scope (incl. globals)? */
-    private static final int USES_ANCESTOR_SCOPE         = 0b0001_0000_0000_0000;
+    private static final int USES_ANCESTOR_SCOPE         = 0x1000; //0b0001_0000_0000_0000;
 
     /** Does this function or any nested functions contain a with or an eval? */
     private static final int HAS_DEEP_WITH_OR_EVAL = HAS_EVAL | HAS_WITH | HAS_DESCENDANT_WITH_OR_EVAL;
@@ -215,14 +215,14 @@
         this.ident             = ident;
         this.name              = name;
         this.kind              = Kind.NORMAL;
-        this.parameters        = new ArrayList<>();
-        this.functions         = new ArrayList<>();
+        this.parameters        = new ArrayList<IdentNode>();
+        this.functions         = new ArrayList<FunctionNode>();
         this.firstToken        = token;
         this.lastToken         = token;
         this.namespace         = new Namespace(compiler.getNamespace().getParent());
-        this.labelStack        = new Stack<>();
-        this.controlStack      = new Stack<>();
-        this.declarations      = new ArrayList<>();
+        this.labelStack        = new Stack<LabelNode>();
+        this.controlStack      = new Stack<Node>();
+        this.declarations      = new ArrayList<VarNode>();
         // my block -> function is this. We added @SuppressWarnings("LeakingThisInConstructor") as NetBeans identifies
         // it as such a leak - this is a false positive as we're setting this into a field of the object being
         // constructed, so it can't be seen from other threads.
@@ -237,12 +237,12 @@
         this.name  = functionNode.name;
         this.kind  = functionNode.kind;
 
-        this.parameters = new ArrayList<>();
+        this.parameters = new ArrayList<IdentNode>();
         for (final IdentNode param : functionNode.getParameters()) {
             this.parameters.add((IdentNode) cs.existingOrCopy(param));
         }
 
-        this.functions         = new ArrayList<>();
+        this.functions         = new ArrayList<FunctionNode>();
         this.firstToken        = functionNode.firstToken;
         this.lastToken         = functionNode.lastToken;
         this.namespace         = functionNode.getNamespace();
@@ -252,9 +252,9 @@
         this.argumentsNode     = (IdentNode)cs.existingOrCopy(functionNode.argumentsNode);
         this.varArgsNode       = (IdentNode)cs.existingOrCopy(functionNode.varArgsNode);
         this.calleeNode        = (IdentNode)cs.existingOrCopy(functionNode.calleeNode);
-        this.labelStack        = new Stack<>();
-        this.controlStack      = new Stack<>();
-        this.declarations      = new ArrayList<>();
+        this.labelStack        = new Stack<LabelNode>();
+        this.controlStack      = new Stack<Node>();
+        this.declarations      = new ArrayList<VarNode>();
 
         for (final VarNode decl : functionNode.getDeclarations()) {
             declarations.add((VarNode) cs.existingOrCopy(decl)); //TODO same?
@@ -1192,7 +1192,7 @@
         assert parentBlock.getFunction() == function.findParentFunction(); // all parent blocks must be in the same function
         if (parentBlock != function.getParent()) {
             if (referencingParentBlocks == null) {
-                referencingParentBlocks = new LinkedList<>();
+                referencingParentBlocks = new LinkedList<Block>();
             }
             referencingParentBlocks.add(parentBlock);
         }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/Location.java
--- a/src/jdk/nashorn/internal/ir/Location.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/Location.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,7 +25,7 @@
 
 package jdk.nashorn.internal.ir;
 
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.parser.Token;
 import jdk.nashorn.internal.parser.TokenType;
 import jdk.nashorn.internal.runtime.Source;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/Node.java
--- a/src/jdk/nashorn/internal/ir/Node.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/Node.java	Thu Feb 07 13:40:05 2013 +0100
@@ -184,7 +184,7 @@
      * Helper class used for node cloning
      */
     public static final class CopyState {
-        private final IdentityHashMap<Node, Node> cloneMap = new IdentityHashMap<>();
+        private final IdentityHashMap<Node, Node> cloneMap = new IdentityHashMap<Node, Node>();
 
         /**
          * Find existing or create new copy of the node.
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/ObjectNode.java
--- a/src/jdk/nashorn/internal/ir/ObjectNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/ObjectNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -62,7 +62,7 @@
     private ObjectNode(final ObjectNode objectNode, final CopyState cs) {
         super(objectNode);
 
-        final List<Node> newElements = new ArrayList<>();
+        final List<Node> newElements = new ArrayList<Node>();
 
         for (final Node element : objectNode.elements) {
             newElements.add(cs.existingOrCopy(element));
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/ReturnNode.java
--- a/src/jdk/nashorn/internal/ir/ReturnNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/ReturnNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -137,7 +137,7 @@
 
     @Override
     public int hashCode() {
-        return 0x4711_17 ^ (expression == null ? 0 : expression.hashCode());
+        return 0x471117 ^ (expression == null ? 0 : expression.hashCode());
     }
 
     /**
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/RuntimeNode.java
--- a/src/jdk/nashorn/internal/ir/RuntimeNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/RuntimeNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -337,7 +337,7 @@
     private RuntimeNode(final RuntimeNode runtimeNode, final CopyState cs) {
         super(runtimeNode);
 
-        final List<Node> newArgs = new ArrayList<>();
+        final List<Node> newArgs = new ArrayList<Node>();
 
         for (final Node arg : runtimeNode.args) {
             newArgs.add(cs.existingOrCopy(arg));
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/SplitNode.java
--- a/src/jdk/nashorn/internal/ir/SplitNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/SplitNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -79,7 +79,7 @@
         this.name         = name;
         this.functionNode = functionNode;
         this.body         = body;
-        this.externalTargets = new ArrayList<>();
+        this.externalTargets = new ArrayList<MethodEmitter.Label>();
     }
 
     private SplitNode(final SplitNode splitNode, final CopyState cs) {
@@ -88,7 +88,7 @@
         name         = splitNode.name;
         functionNode = (FunctionNode)cs.existingOrSame(splitNode.functionNode);
         body         = cs.existingOrCopy(splitNode.body);
-        externalTargets = new ArrayList<>();
+        externalTargets = new ArrayList<MethodEmitter.Label>();
     }
 
     @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/SwitchNode.java
--- a/src/jdk/nashorn/internal/ir/SwitchNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/SwitchNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -70,7 +70,7 @@
     private SwitchNode(final SwitchNode switchNode, final CopyState cs) {
         super(switchNode);
 
-        final List<CaseNode> newCases = new ArrayList<>();
+        final List<CaseNode> newCases = new ArrayList<CaseNode>();
 
         for (final CaseNode caseNode : switchNode.getCases()) {
            newCases.add((CaseNode)cs.existingOrCopy(caseNode));
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/Symbol.java
--- a/src/jdk/nashorn/internal/ir/Symbol.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/Symbol.java	Thu Feb 07 13:40:05 2013 +0100
@@ -40,30 +40,30 @@
 
 public final class Symbol implements Comparable<Symbol> {
     /** Symbol flags. Kind ordered by precedence. */
-    public static final int IS_TEMP     = 0b0000_0001;
+    public static final int IS_TEMP     = 0x01; //0b0000_0001;
     /** Is this Global */
-    public static final int IS_GLOBAL   = 0b0000_0010;
+    public static final int IS_GLOBAL   = 0x02; //0b0000_0010;
     /** Is this a variable */
-    public static final int IS_VAR      = 0b0000_0011;
+    public static final int IS_VAR      = 0x03; //0b0000_0011;
     /** Is this a parameter */
-    public static final int IS_PARAM    = 0b0000_0100;
+    public static final int IS_PARAM    = 0x04; //0b0000_0100;
     /** Is this a constant */
-    public static final int IS_CONSTANT = 0b0000_0101;
+    public static final int IS_CONSTANT = 0x05; //0b0000_0101;
 
-    static final int KINDMASK = 0b0000_1111;
+    static final int KINDMASK = 0x0F; //0b0000_1111;
 
     /** Is this scope */
-    public static final int IS_SCOPE         = 0b0000_0001_0000;
+    public static final int IS_SCOPE         = 0x010; //0b0000_0001_0000;
     /** Is this a this symbol */
-    public static final int IS_THIS          = 0b0000_0010_0000;
+    public static final int IS_THIS          = 0x020; //0b0000_0010_0000;
     /** Can this symbol ever be undefined */
-    public static final int CAN_BE_UNDEFINED = 0b0000_0100_0000;
+    public static final int CAN_BE_UNDEFINED = 0x040; //0b0000_0100_0000;
     /** Can this symbol ever have primitive types */
-    public static final int CAN_BE_PRIMITIVE = 0b0000_1000_0000;
+    public static final int CAN_BE_PRIMITIVE = 0x080; //0b0000_1000_0000;
     /** Is this a let */
-    public static final int IS_LET           = 0b0001_0000_0000;
+    public static final int IS_LET           = 0x100; //0b0001_0000_0000;
     /** Is this an internal symbol, never represented explicitly in source code */
-    public static final int IS_INTERNAL      = 0b0010_0000_0000;
+    public static final int IS_INTERNAL      = 0x200; //0b0010_0000_0000;
 
     /** Null or name identifying symbol. */
     private final String name;
@@ -98,7 +98,7 @@
         final String trace;
         if (stacktrace != null) {
             trace = stacktrace; //stacktrace always implies trace as well
-            TRACE_SYMBOLS_STACKTRACE = new HashSet<>();
+            TRACE_SYMBOLS_STACKTRACE = new HashSet<String>();
             for (StringTokenizer st = new StringTokenizer(stacktrace, ","); st.hasMoreTokens(); ) {
                 TRACE_SYMBOLS_STACKTRACE.add(st.nextToken());
             }
@@ -108,7 +108,7 @@
         }
 
         if (trace != null) {
-            TRACE_SYMBOLS = new HashSet<>();
+            TRACE_SYMBOLS = new HashSet<String>();
             for (StringTokenizer st = new StringTokenizer(trace, ","); st.hasMoreTokens(); ) {
                 TRACE_SYMBOLS.add(st.nextToken());
             }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/TryNode.java
--- a/src/jdk/nashorn/internal/ir/TryNode.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/TryNode.java	Thu Feb 07 13:40:05 2013 +0100
@@ -77,7 +77,7 @@
     private TryNode(final TryNode tryNode, final CopyState cs) {
         super(tryNode);
 
-        final List<Block> newCatchBlocks = new ArrayList<>();
+        final List<Block> newCatchBlocks = new ArrayList<Block>();
 
         for (final Block block : tryNode.catchBlocks) {
             newCatchBlocks.add((Block)cs.existingOrCopy(block));
@@ -109,7 +109,7 @@
 
             body = (Block)body.accept(visitor);
 
-            final List<Block> newCatchBlocks = new ArrayList<>(catchBlocks.size());
+            final List<Block> newCatchBlocks = new ArrayList<Block>(catchBlocks.size());
             for (final Block catchBlock : catchBlocks) {
                 newCatchBlocks.add((Block)catchBlock.accept(visitor));
             }
@@ -147,7 +147,7 @@
      * @return a list of catch nodes
      */
     public List<CatchNode> getCatches() {
-        final List<CatchNode> catches = new ArrayList<>(catchBlocks.size());
+        final List<CatchNode> catches = new ArrayList<CatchNode>(catchBlocks.size());
         for (final Block catchBlock : catchBlocks) {
             catches.add((CatchNode)catchBlock.getStatements().get(0));
         }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/debug/ASTWriter.java
--- a/src/jdk/nashorn/internal/ir/debug/ASTWriter.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/debug/ASTWriter.java	Thu Feb 07 13:40:05 2013 +0100
@@ -93,7 +93,7 @@
         type = type.substring(type.lastIndexOf('.') + 1, type.length());
 //        type += "@" + Debug.id(node) + "#" + node.getSymbol();
 
-        final List<Field> children = new LinkedList<>();
+        final List<Field> children = new LinkedList<Field>();
 
         if (!isReference) {
             enqueueChildren(node, clazz, children);
@@ -162,7 +162,10 @@
                 Object value;
                 try {
                     value = child.get(node);
-                } catch (final IllegalArgumentException | IllegalAccessException e) {
+                } catch (final IllegalArgumentException e) {
+                    Context.printStackTrace(e);
+                    return;
+                } catch (final IllegalAccessException e) {
                     Context.printStackTrace(e);
                     return;
                 }
@@ -188,7 +191,7 @@
     }
 
     private static void enqueueChildren(final Node node, final Class<?> nodeClass, final List<Field> children) {
-        final Deque<Class<?>> stack = new ArrayDeque<>();
+        final Deque<Class<?>> stack = new ArrayDeque<Class<?>>();
 
         /**
          * Here is some ugliness that can be overcome by proper ChildNode annotations
@@ -232,7 +235,9 @@
                             children.add(f);
                         }
                     }
-                } catch (final IllegalArgumentException | IllegalAccessException e) {
+                } catch (final IllegalArgumentException e) {
+                    return;
+                } catch (final IllegalAccessException e) {
                     return;
                 }
             }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/ir/debug/PrintVisitor.java
--- a/src/jdk/nashorn/internal/ir/debug/PrintVisitor.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/ir/debug/PrintVisitor.java	Thu Feb 07 13:40:05 2013 +0100
@@ -91,7 +91,7 @@
      * @param printLineNumbers  should line number nodes be included in the output?
      */
     public PrintVisitor(final boolean printLineNumbers) {
-        this.EOLN             = System.lineSeparator();
+        this.EOLN             = "\n";
         this.sb               = new StringBuilder();
         this.printLineNumbers = printLineNumbers;
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/AccessorPropertyDescriptor.java
--- a/src/jdk/nashorn/internal/objects/AccessorPropertyDescriptor.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/AccessorPropertyDescriptor.java	Thu Feb 07 13:40:05 2013 +0100
@@ -29,7 +29,7 @@
 import static jdk.nashorn.internal.runtime.ScriptRuntime.UNDEFINED;
 import static jdk.nashorn.internal.runtime.ScriptRuntime.sameValue;
 
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.objects.annotations.Property;
 import jdk.nashorn.internal.objects.annotations.ScriptClass;
 import jdk.nashorn.internal.runtime.JSType;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/ArrayBufferView.java
--- a/src/jdk/nashorn/internal/objects/ArrayBufferView.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/ArrayBufferView.java	Thu Feb 07 13:40:05 2013 +0100
@@ -310,7 +310,7 @@
             dst = factory.construct(length);
         } else if (arg0 instanceof NativeArray) {
             // Constructor(type[] array)
-            length = (int) (((NativeArray) arg0).getArray().length() & 0x7fff_ffff);
+            length = (int) (((NativeArray) arg0).getArray().length() & 0x7fffffff);
             dst = factory.construct(length);
         } else {
             // Constructor(unsigned long length)
@@ -330,7 +330,7 @@
             length = ((ArrayBufferView)array).elementLength();
         } else if (array instanceof NativeArray) {
             // void set(type[] array, optional unsigned long offset)
-            length = (int) (((NativeArray) array).getArray().length() & 0x7fff_ffff);
+            length = (int) (((NativeArray) array).getArray().length() & 0x7fffffff);
         } else {
             throw new RuntimeException("argument is not of array type");
         }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/DataPropertyDescriptor.java
--- a/src/jdk/nashorn/internal/objects/DataPropertyDescriptor.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/DataPropertyDescriptor.java	Thu Feb 07 13:40:05 2013 +0100
@@ -28,7 +28,7 @@
 import static jdk.nashorn.internal.runtime.ScriptRuntime.UNDEFINED;
 import static jdk.nashorn.internal.runtime.ScriptRuntime.sameValue;
 
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.objects.annotations.Property;
 import jdk.nashorn.internal.objects.annotations.ScriptClass;
 import jdk.nashorn.internal.runtime.JSType;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/DateParser.java
--- a/src/jdk/nashorn/internal/objects/DateParser.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/DateParser.java	Thu Feb 07 13:40:05 2013 +0100
@@ -77,7 +77,7 @@
     private int yearSign = 0;
     private boolean namedMonth = false;
 
-    private final static HashMap<String,Name> names = new HashMap<>();
+    private final static HashMap<String,Name> names = new HashMap<String,Name>();
 
     static {
         addName("monday", Name.DAY_OF_WEEK, 0);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/GenericPropertyDescriptor.java
--- a/src/jdk/nashorn/internal/objects/GenericPropertyDescriptor.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/GenericPropertyDescriptor.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,7 +25,7 @@
 
 package jdk.nashorn.internal.objects;
 
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.objects.annotations.Property;
 import jdk.nashorn.internal.objects.annotations.ScriptClass;
 import jdk.nashorn.internal.runtime.JSType;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/Global.java
--- a/src/jdk/nashorn/internal/objects/Global.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/Global.java	Thu Feb 07 13:40:05 2013 +0100
@@ -494,7 +494,9 @@
 
                 typeError(this, "cannot.get.default.number");
             }
-        } catch (final RuntimeException | Error e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable t) {
             throw new RuntimeException(t);
@@ -1614,7 +1616,11 @@
 
             return res;
 
-        } catch (final ClassNotFoundException | InstantiationException | IllegalAccessException e) {
+        } catch (final ClassNotFoundException e) {
+            throw new RuntimeException(e);
+        } catch (final InstantiationException e) {
+            throw new RuntimeException(e);
+        } catch (final IllegalAccessException e) {
             throw new RuntimeException(e);
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeArray.java
--- a/src/jdk/nashorn/internal/objects/NativeArray.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeArray.java	Thu Feb 07 13:40:05 2013 +0100
@@ -344,7 +344,9 @@
                 if (join instanceof ScriptFunction) {
                     return JOIN.getInvoker().invokeExact(join, sobj);
                 }
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
@@ -383,7 +385,9 @@
                             typeError("not.a.function", "toLocaleString");
                         }
                     }
-                } catch (final Error|RuntimeException t) {
+                } catch (final RuntimeException t) {
+                    throw t;
+                } catch (final Error t) {
                     throw t;
                 } catch (final Throwable t) {
                     throw new RuntimeException(t);
@@ -417,7 +421,7 @@
                 long length;
                 if (len instanceof Integer || len instanceof Long) {
                     length = ((Number) len).longValue();
-                    if (length >= 0 && length < 0xffff_ffffL) {
+                    if (length >= 0 && length < 0xffffffffL) {
                         return new NativeArray(length);
                     }
                 }
@@ -532,7 +536,7 @@
      */
     @Function(attributes = Attribute.NOT_ENUMERABLE, arity = 1)
     public static Object concat(final Object self, final Object... args) {
-        final ArrayList<Object> list = new ArrayList<>();
+        final ArrayList<Object> list = new ArrayList<Object>();
         final Object selfToObject = Global.toObject(self);
 
         if (isArray(selfToObject)) {
@@ -622,7 +626,10 @@
             sobj.set("length", index, strict);
 
             return element;
-        } catch (final ClassCastException | NullPointerException e) {
+        } catch (final ClassCastException e) {
+            typeError(Global.instance(), "not.an.object", ScriptRuntime.safeToString(self));
+            return ScriptRuntime.UNDEFINED;
+        } catch (final NullPointerException e) {
             typeError("not.an.object", ScriptRuntime.safeToString(self));
             return ScriptRuntime.UNDEFINED;
         }
@@ -658,7 +665,10 @@
             sobj.set("length", len, strict);
 
             return len;
-        } catch (final ClassCastException | NullPointerException e) {
+        } catch (final ClassCastException e) {
+            typeError(Global.instance(), "not.an.object", ScriptRuntime.safeToString(self));
+            return ScriptRuntime.UNDEFINED;
+        } catch (final NullPointerException e) {
             typeError("not.an.object", ScriptRuntime.safeToString(self));
             return ScriptRuntime.UNDEFINED;
         }
@@ -697,7 +707,10 @@
                 }
             }
             return sobj;
-        } catch (final ClassCastException | NullPointerException e) {
+        } catch (final ClassCastException e) {
+            typeError(Global.instance(), "not.an.object", ScriptRuntime.safeToString(self));
+            return ScriptRuntime.UNDEFINED;
+        } catch (final NullPointerException e) {
             typeError("not.an.object", ScriptRuntime.safeToString(self));
             return ScriptRuntime.UNDEFINED;
         }
@@ -819,8 +832,10 @@
 
                 if (cmp != null) {
                     try {
-                        return (int)CALL_CMP.invokeExact(cmp, cmpThis, x, y);
-                    } catch (final RuntimeException | Error e) {
+                        return (Integer)CALL_CMP.invokeExact(cmp, cmpThis, x, y);
+                    } catch (final RuntimeException e) {
+                        throw e;
+                    } catch (final Error e) {
                         throw e;
                     } catch (final Throwable t) {
                         throw new RuntimeException(t);
@@ -863,7 +878,10 @@
             }
 
             return sobj;
-        } catch (final ClassCastException | NullPointerException e) {
+        } catch (final ClassCastException e) {
+            typeError(Global.instance(), "not.an.object", ScriptRuntime.safeToString(self));
+            return ScriptRuntime.UNDEFINED;
+        } catch (final NullPointerException e) {
             typeError("not.an.object", ScriptRuntime.safeToString(self));
             return ScriptRuntime.UNDEFINED;
         }
@@ -1044,7 +1062,9 @@
                     }
                 }
             }
-        } catch (final ClassCastException | NullPointerException e) {
+        } catch (final ClassCastException e) {
+            //fallthru
+        } catch (final NullPointerException e) {
             //fallthru
         }
 
@@ -1078,7 +1098,9 @@
                     }
                 }
             }
-        } catch (final ClassCastException | NullPointerException e) {
+        } catch (final ClassCastException e) {
+            typeError(Global.instance(), "not.an.object", ScriptRuntime.safeToString(self));
+        } catch (final NullPointerException e) {
             typeError("not.an.object", ScriptRuntime.safeToString(self));
         }
 
@@ -1102,7 +1124,7 @@
         return new IteratorAction<Boolean>(Global.toObject(self), callbackfn, thisArg, true) {
             @Override
             protected boolean forEach(final Object val, final int i) throws Throwable {
-                return (result = (boolean)EVERY_CALLBACK_INVOKER.invokeExact(callbackfn, thisArg, val, i, self));
+                return (result = (Boolean)EVERY_CALLBACK_INVOKER.invokeExact(callbackfn, thisArg, val, i, self));
             }
         }.apply();
     }
@@ -1120,7 +1142,7 @@
         return new IteratorAction<Boolean>(Global.toObject(self), callbackfn, thisArg, false) {
             @Override
             protected boolean forEach(final Object val, final int i) throws Throwable {
-                return !(result = (boolean)SOME_CALLBACK_INVOKER.invokeExact(callbackfn, thisArg, val, i, self));
+                return !(result = (Boolean)SOME_CALLBACK_INVOKER.invokeExact(callbackfn, thisArg, val, i, self));
             }
         }.apply();
     }
@@ -1186,7 +1208,7 @@
 
             @Override
             protected boolean forEach(final Object val, final int i) throws Throwable {
-                if ((boolean)FILTER_CALLBACK_INVOKER.invokeExact(callbackfn, thisArg, val, i, self)) {
+                if ((Boolean)FILTER_CALLBACK_INVOKER.invokeExact(callbackfn, thisArg, val, i, self)) {
                     result.defineOwnProperty(to++, val);
                 }
                 return true;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeBoolean.java
--- a/src/jdk/nashorn/internal/objects/NativeBoolean.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeBoolean.java	Thu Feb 07 13:40:05 2013 +0100
@@ -175,7 +175,9 @@
     private static MethodHandle findWrapFilter() {
         try {
             return MethodHandles.lookup().findStatic(NativeBoolean.class, "wrapFilter", MH.type(NativeBoolean.class, Object.class));
-        } catch (NoSuchMethodException | IllegalAccessException e) {
+        } catch (NoSuchMethodException e) {
+            throw new AssertionError(e);
+        } catch (IllegalAccessException e) {
             throw new MethodHandleFactory.LookupException(e);
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeDate.java
--- a/src/jdk/nashorn/internal/objects/NativeDate.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeDate.java	Thu Feb 07 13:40:05 2013 +0100
@@ -75,10 +75,10 @@
     private static final double hoursPerDay      = 24;
     private static final double minutesPerHour   = 60;
     private static final double secondsPerMinute = 60;
-    private static final double msPerSecond   = 1_000;
-    private static final double msPerMinute  = 60_000;
-    private static final double msPerHour = 3_600_000;
-    private static final double msPerDay = 86_400_000;
+    private static final double msPerSecond   = 1000;
+    private static final double msPerMinute  = 60000;
+    private static final double msPerHour = 3600000;
+    private static final double msPerDay = 86400000;
 
     private static int[][] firstDayInMonth = {
             {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}, // normal year
@@ -868,7 +868,9 @@
                 return TO_ISO_STRING.getInvoker().invokeExact(func, sobj, key);
             }
             typeError("not.a.function", ScriptRuntime.safeToString(func));
-        } catch (final RuntimeException | Error e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable t) {
             throw new RuntimeException(t);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeDebug.java
--- a/src/jdk/nashorn/internal/objects/NativeDebug.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeDebug.java	Thu Feb 07 13:40:05 2013 +0100
@@ -28,7 +28,7 @@
 import static jdk.nashorn.internal.runtime.ScriptRuntime.UNDEFINED;
 
 import java.io.PrintWriter;
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.objects.annotations.Attribute;
 import jdk.nashorn.internal.objects.annotations.Function;
 import jdk.nashorn.internal.objects.annotations.ScriptClass;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeError.java
--- a/src/jdk/nashorn/internal/objects/NativeError.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeError.java	Thu Feb 07 13:40:05 2013 +0100
@@ -244,7 +244,7 @@
         Object[] res;
         if (exception instanceof Throwable) {
             final StackTraceElement[] frames = ((Throwable)exception).getStackTrace();
-            final List<StackTraceElement> filtered = new ArrayList<>();
+            final List<StackTraceElement> filtered = new ArrayList<StackTraceElement>();
             for (final StackTraceElement st : frames) {
                 if (ECMAException.isScriptFrame(st)) {
                     filtered.add(st);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeFloat32Array.java
--- a/src/jdk/nashorn/internal/objects/NativeFloat32Array.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeFloat32Array.java	Thu Feb 07 13:40:05 2013 +0100
@@ -64,10 +64,10 @@
         protected double getDoubleImpl(final int index) {
             final int byteIndex = byteIndex(index);
             final byte[] byteArray = buffer.getByteArray();
-            final int bits = byteArray[byteIndex  ]       & 0x0000_00ff |
-                             byteArray[byteIndex+1] <<  8 & 0x0000_ff00 |
-                             byteArray[byteIndex+2] << 16 & 0x00ff_0000 |
-                             byteArray[byteIndex+3] << 24 & 0xff00_0000 ;
+            final int bits = byteArray[byteIndex  ]       & 0x000000ff |
+                             byteArray[byteIndex+1] <<  8 & 0x0000ff00 |
+                             byteArray[byteIndex+2] << 16 & 0x00ff0000 |
+                             byteArray[byteIndex+3] << 24 & 0xff000000 ;
             return Float.intBitsToFloat(bits);
         }
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeFloat64Array.java
--- a/src/jdk/nashorn/internal/objects/NativeFloat64Array.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeFloat64Array.java	Thu Feb 07 13:40:05 2013 +0100
@@ -66,14 +66,14 @@
             final int byteIndex = byteIndex(index);
             final byte[] byteArray = buffer.getByteArray();
             final long bits;
-            bits =       byteArray[byteIndex  ]       & 0x0000_0000_0000_00ffL |
-                   (long)byteArray[byteIndex+1] <<  8 & 0x0000_0000_0000_ff00L |
-                   (long)byteArray[byteIndex+2] << 16 & 0x0000_0000_00ff_0000L |
-                   (long)byteArray[byteIndex+3] << 24 & 0x0000_0000_ff00_0000L |
-                   (long)byteArray[byteIndex+4] << 32 & 0x0000_00ff_0000_0000L |
-                   (long)byteArray[byteIndex+5] << 40 & 0x0000_ff00_0000_0000L |
-                   (long)byteArray[byteIndex+6] << 48 & 0x00ff_0000_0000_0000L |
-                   (long)byteArray[byteIndex+7] << 56 & 0xff00_0000_0000_0000L ;
+            bits =       byteArray[byteIndex  ]       & 0x00000000000000ffL |
+                   (long)byteArray[byteIndex+1] <<  8 & 0x000000000000ff00L |
+                   (long)byteArray[byteIndex+2] << 16 & 0x0000000000ff0000L |
+                   (long)byteArray[byteIndex+3] << 24 & 0x00000000ff000000L |
+                   (long)byteArray[byteIndex+4] << 32 & 0x000000ff00000000L |
+                   (long)byteArray[byteIndex+5] << 40 & 0x0000ff0000000000L |
+                   (long)byteArray[byteIndex+6] << 48 & 0x00ff000000000000L |
+                   (long)byteArray[byteIndex+7] << 56 & 0xff00000000000000L ;
             return Double.longBitsToDouble(bits);
         }
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeInt32Array.java
--- a/src/jdk/nashorn/internal/objects/NativeInt32Array.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeInt32Array.java	Thu Feb 07 13:40:05 2013 +0100
@@ -63,10 +63,10 @@
         protected int getIntImpl(final int index) {
             final int byteIndex = byteIndex(index);
             final byte[] byteArray = buffer.getByteArray();
-            return byteArray[byteIndex  ]       & 0x0000_00ff |
-                   byteArray[byteIndex+1] <<  8 & 0x0000_ff00 |
-                   byteArray[byteIndex+2] << 16 & 0x00ff_0000 |
-                   byteArray[byteIndex+3] << 24 & 0xff00_0000 ;
+            return byteArray[byteIndex  ]       & 0x000000ff |
+                   byteArray[byteIndex+1] <<  8 & 0x0000ff00 |
+                   byteArray[byteIndex+2] << 16 & 0x00ff0000 |
+                   byteArray[byteIndex+3] << 24 & 0xff000000 ;
         }
 
         @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeJSAdapter.java
--- a/src/jdk/nashorn/internal/objects/NativeJSAdapter.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeJSAdapter.java	Thu Feb 07 13:40:05 2013 +0100
@@ -478,7 +478,7 @@
             obj = new NativeArray(0);
         }
 
-        final List<String> array = new ArrayList<>();
+        final List<String> array = new ArrayList<String>();
         for (final Iterator<Object> iter = ArrayLikeIterator.arrayLikeIterator(obj); iter.hasNext(); ) {
             array.add((String)iter.next());
         }
@@ -610,11 +610,9 @@
             }
         }
 
-        switch(operation) {
-        case "getProp":
-        case "getElem":
+        if ("getProp".equals(operation) || "getElem".equals(operation)) {
             return findHook(desc, __get__);
-        case "getMethod":
+        } else if ("getMethod".equals(operation)) {
             final FindProperty find = adaptee.findProperty(__call__, true);
             if (find != null) {
                 final ScriptFunction func = (ScriptFunction)getObjectValue(find);
@@ -625,9 +623,6 @@
                         adaptee.getMap().getProtoGetSwitchPoint(__call__), testJSAdaptor(adaptee, null, null, null));
             }
             typeError("no.such.function", desc.getNameToken(2), ScriptRuntime.safeToString(this));
-            break;
-        default:
-            break;
         }
 
         throw new AssertionError("should not reach here");
@@ -695,11 +690,10 @@
             }
         }
 
-        switch (hook) {
-        case __call__:
+        if (__call__.equals(hook)) {
             typeError("no.such.function", desc.getNameToken(2), ScriptRuntime.safeToString(this));
             throw new AssertionError("should not reach here");
-        default:
+        } else {
             final MethodHandle methodHandle = hook.equals(__put__) ?
             MH.asType(Lookup.EMPTY_SETTER, type) :
             Lookup.emptyGetter(type.returnType());
@@ -717,7 +711,9 @@
         if (res && getter != null) {
             try {
                 return getter.invokeExact(where) == func;
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
@@ -738,7 +734,9 @@
     private static MethodHandle findOwnMH(final String name, final Class<?> rtype, final Class<?>... types) {
         try {
             return MethodHandles.lookup().findStatic(NativeJSAdapter.class, name, MH.type(rtype, types));
-        } catch (final NoSuchMethodException | IllegalAccessException e) {
+        } catch (final NoSuchMethodException e) {
+            throw new MethodHandleFactory.LookupException(e);
+        } catch (final IllegalAccessException e) {
             throw new MethodHandleFactory.LookupException(e);
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeJSON.java
--- a/src/jdk/nashorn/internal/objects/NativeJSON.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeJSON.java	Thu Feb 07 13:40:05 2013 +0100
@@ -138,7 +138,7 @@
                 replacer instanceof Iterable ||
                 (replacer != null && replacer.getClass().isArray())) {
 
-            state.propertyList = new ArrayList<>();
+            state.propertyList = new ArrayList<String>();
 
             final Iterator<Object> iter = ArrayLikeIterator.arrayLikeIterator(replacer);
 
@@ -252,7 +252,9 @@
             try {
                 // Object.class, ScriptFunction.class, ScriptObject.class, String.class, Object.class);
                 return REVIVER_INVOKER.invokeExact(reviver, holder, JSType.toString(name), val);
-            } catch(Error|RuntimeException t) {
+            } catch(RuntimeException t) {
+                throw t;
+            } catch(Error t) {
                 throw t;
             } catch(final Throwable t) {
                 throw new RuntimeException(t);
@@ -331,7 +333,7 @@
     // stringify helpers.
 
     private static class StringifyState {
-        final Map<ScriptObject, ScriptObject> stack = new IdentityHashMap<>();
+        final Map<ScriptObject, ScriptObject> stack = new IdentityHashMap<ScriptObject, ScriptObject>();
 
         StringBuilder  indent = new StringBuilder();
         String         gap = "";
@@ -355,7 +357,9 @@
             if (state.replacerFunction != null) {
                 value = REPLACER_INVOKER.invokeExact(state.replacerFunction, holder, key, value);
             }
-        } catch(Error|RuntimeException t) {
+        } catch(RuntimeException t) {
+            throw t;
+        } catch(Error t) {
             throw t;
         } catch(final Throwable t) {
             throw new RuntimeException(t);
@@ -412,7 +416,7 @@
         state.indent.append(state.gap);
 
         final StringBuilder finalStr = new StringBuilder();
-        final List<Object>  partial  = new ArrayList<>();
+        final List<Object>  partial  = new ArrayList<Object>();
         final List<String>  k        = state.propertyList == null ? Arrays.asList(value.getOwnKeys(false)) : state.propertyList;
 
         for (final Object p : k) {
@@ -486,7 +490,7 @@
         state.stack.put(value, value);
         final StringBuilder stepback = new StringBuilder(state.indent.toString());
         state.indent.append(state.gap);
-        final List<Object> partial = new ArrayList<>();
+        final List<Object> partial = new ArrayList<Object>();
 
         final int length = JSType.toInteger(value.getLength());
         int index = 0;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeNumber.java
--- a/src/jdk/nashorn/internal/objects/NativeNumber.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeNumber.java	Thu Feb 07 13:40:05 2013 +0100
@@ -382,7 +382,9 @@
     private static MethodHandle findWrapFilter() {
         try {
             return MethodHandles.lookup().findStatic(NativeNumber.class, "wrapFilter", MH.type(NativeNumber.class, Object.class));
-        } catch (final NoSuchMethodException | IllegalAccessException e) {
+        } catch (final NoSuchMethodException e) {
+            throw new AssertionError(e);
+        } catch (final IllegalAccessException e) {
             throw new MethodHandleFactory.LookupException(e);
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeObject.java
--- a/src/jdk/nashorn/internal/objects/NativeObject.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeObject.java	Thu Feb 07 13:40:05 2013 +0100
@@ -325,7 +325,9 @@
                 if (toString instanceof ScriptFunction) {
                     return TO_STRING.getInvoker().invokeExact(toString, sobj);
                 }
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeRegExp.java
--- a/src/jdk/nashorn/internal/objects/NativeRegExp.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeRegExp.java	Thu Feb 07 13:40:05 2013 +0100
@@ -477,19 +477,13 @@
             }
 
             // misc. "static" properties supported
-            switch (propName) {
-                case "input": {
-                    return lastMatch.input;
-                }
-
-                case "lastMatch": {
-                    return lastMatch.get(0);
-                }
-
-                case "lastParen": {
-                    final int len = ((Number)NativeRegExpExecResult.length(lastMatch)).intValue();
-                    return (len > 0)? lastMatch.get(len - 1) : UNDEFINED;
-                }
+            if ("input".equals(propName)) {
+                return lastMatch.input;
+            } else if ("lastMatch".equals(propName)) {
+                return lastMatch.get(0);
+            } else if ("lastParen".equals(propName)) {
+                final int len = ((Number)NativeRegExpExecResult.length(lastMatch)).intValue();
+                return (len > 0)? lastMatch.get(len - 1) : UNDEFINED;
             }
         }
 
@@ -683,7 +677,7 @@
     }
 
     private static Object split(final NativeRegExp regexp0, final String input, final long limit) {
-        final List<Object> matches = new ArrayList<>();
+        final List<Object> matches = new ArrayList<Object>();
 
         final NativeRegExp regexp = new NativeRegExp(regexp0);
         regexp.setGlobal(true);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeString.java
--- a/src/jdk/nashorn/internal/objects/NativeString.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeString.java	Thu Feb 07 13:40:05 2013 +0100
@@ -134,7 +134,9 @@
             try {
                 MethodHandle mh = MethodHandles.lookup().findStatic(NativeString.class, "get", desc.getMethodType());
                 return new GuardedInvocation(mh, NashornGuards.getInstanceOf2Guard(String.class, ConsString.class));
-            } catch (final NoSuchMethodException | IllegalAccessException e) {
+            } catch (final NoSuchMethodException e) {
+                // Shouldn't happen. Fall back to super
+            } catch (final IllegalAccessException e) {
                 // Shouldn't happen. Fall back to super
             }
         }
@@ -369,7 +371,7 @@
      */
     @Override
     public String[] getOwnKeys(final boolean all) {
-        final List<Object> keys = new ArrayList<>();
+        final List<Object> keys = new ArrayList<Object>();
 
         // add string index keys
         for (int i = 0; i < value.length(); i++) {
@@ -676,7 +678,7 @@
         nativeRegExp.setLastIndex(0);
 
         int previousLastIndex = 0;
-        final List<Object> matches = new ArrayList<>();
+        final List<Object> matches = new ArrayList<Object>();
 
         Object result;
         while ((result = nativeRegExp.exec(str)) != null) {
@@ -853,7 +855,7 @@
             return new NativeArray(array);
         }
 
-        final List<String> elements = new LinkedList<>();
+        final List<String> elements = new LinkedList<String>();
         final int strLength = str.length();
         final int sepLength = separator.length();
         int pos = 0;
@@ -1186,7 +1188,9 @@
     private static MethodHandle findWrapFilter() {
         try {
             return MethodHandles.lookup().findStatic(NativeString.class, "wrapFilter", MH.type(NativeString.class, Object.class));
-        } catch (final NoSuchMethodException | IllegalAccessException e) {
+        } catch (final NoSuchMethodException e) {
+            throw new AssertionError(e);
+        } catch (final IllegalAccessException e) {
             throw new MethodHandleFactory.LookupException(e);
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeUint16Array.java
--- a/src/jdk/nashorn/internal/objects/NativeUint16Array.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeUint16Array.java	Thu Feb 07 13:40:05 2013 +0100
@@ -63,8 +63,8 @@
         protected int getIntImpl(final int index) {
             final int byteIndex = byteIndex(index);
             final byte[] byteArray = buffer.getByteArray();
-            return byteArray[byteIndex  ]       & 0x0000_00ff |
-                   byteArray[byteIndex+1] <<  8 & 0x0000_ff00 ;
+            return byteArray[byteIndex  ]       & 0x000000ff |
+                   byteArray[byteIndex+1] <<  8 & 0x0000ff00 ;
         }
 
         @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeUint32Array.java
--- a/src/jdk/nashorn/internal/objects/NativeUint32Array.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeUint32Array.java	Thu Feb 07 13:40:05 2013 +0100
@@ -63,25 +63,25 @@
         protected int getIntImpl(final int index) {
             final int byteIndex = byteIndex(index);
             final byte[] byteArray = buffer.getByteArray();
-            return byteArray[byteIndex  ]       & 0x0000_00ff |
-                   byteArray[byteIndex+1] <<  8 & 0x0000_ff00 |
-                   byteArray[byteIndex+2] << 16 & 0x00ff_0000 |
-                   byteArray[byteIndex+3] << 24 & 0xff00_0000 ;
+            return byteArray[byteIndex  ]       & 0x000000ff |
+                   byteArray[byteIndex+1] <<  8 & 0x0000ff00 |
+                   byteArray[byteIndex+2] << 16 & 0x00ff0000 |
+                   byteArray[byteIndex+3] << 24 & 0xff000000 ;
         }
 
         @Override
         protected long getLongImpl(final int key) {
-            return getIntImpl(key) & 0xffff_ffffL;
+            return getIntImpl(key) & 0xffffffffL;
         }
 
         @Override
         protected double getDoubleImpl(final int key) {
-            return getIntImpl(key) & 0xffff_ffffL;
+            return getIntImpl(key) & 0xffffffffL;
         }
 
         @Override
         protected Object getObjectImpl(final int key) {
-            return getIntImpl(key) & 0xffff_ffffL;
+            return getIntImpl(key) & 0xffffffffL;
         }
 
         @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/NativeUint8ClampedArray.java
--- a/src/jdk/nashorn/internal/objects/NativeUint8ClampedArray.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/NativeUint8ClampedArray.java	Thu Feb 07 13:40:05 2013 +0100
@@ -68,7 +68,7 @@
         @Override
         protected void setImpl(final int index, final int value) {
             final byte clamped;
-            if ((value & 0xffff_ff00) == 0) {
+            if ((value & 0xffffff00) == 0) {
                 clamped = (byte) value;
             } else {
                 clamped = value < 0 ? 0 : (byte)0xff;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/objects/ScriptFunctionImpl.java
--- a/src/jdk/nashorn/internal/objects/ScriptFunctionImpl.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/objects/ScriptFunctionImpl.java	Thu Feb 07 13:40:05 2013 +0100
@@ -293,7 +293,9 @@
     private static MethodHandle findOwnMH(final String name, final Class<?> rtype, final Class<?>... types) {
         try {
             return MethodHandles.lookup().findStatic(ScriptFunctionImpl.class, name, MH.type(rtype, types));
-        } catch (final NoSuchMethodException | IllegalAccessException e) {
+        } catch (final NoSuchMethodException e) {
+            throw new MethodHandleFactory.LookupException(e);
+        } catch (final IllegalAccessException e) {
             throw new MethodHandleFactory.LookupException(e);
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/parser/JSONParser.java
--- a/src/jdk/nashorn/internal/parser/JSONParser.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/parser/JSONParser.java	Thu Feb 07 13:40:05 2013 +0100
@@ -246,7 +246,7 @@
 
         Node result = null;
         // Prepare to accummulating elements.
-        final List<Node> elements = new ArrayList<>();
+        final List<Node> elements = new ArrayList<Node>();
 
 loop:
         while (true) {
@@ -285,7 +285,7 @@
         next();
 
         // Prepare to accumulate elements.
-        final List<Node> elements = new ArrayList<>();
+        final List<Node> elements = new ArrayList<Node>();
 
         // Create a block for the object literal.
 loop:
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/parser/Parser.java
--- a/src/jdk/nashorn/internal/parser/Parser.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/parser/Parser.java	Thu Feb 07 13:40:05 2013 +0100
@@ -535,7 +535,7 @@
     }
 
     private <T extends Node> List<T> findControls(final Class<T> ctype, final Node to) {
-        final List<T> nodes = new ArrayList<>();
+        final List<T> nodes = new ArrayList<T>();
         final Stack<Node> controlStack = function.getControlStack();
         for (int i = controlStack.size() - 1; i >= 0; i--) {
             final Node node = controlStack.get(i);
@@ -678,7 +678,7 @@
                         if (checkDirective) {
                             if (!oldStrictMode) {
                                 if (directiveStmts == null) {
-                                    directiveStmts = new ArrayList<>();
+                                    directiveStmts = new ArrayList<Node>();
                                 }
                                 directiveStmts.add(lastStatement);
                             }
@@ -888,12 +888,8 @@
     @SuppressWarnings("fallthrough")
     private void verifyStrictIdent(final IdentNode ident, final String contextString) {
         if (isStrictMode) {
-            switch (ident.getName()) {
-            case "eval":
-            case "arguments":
+            if ("eval".equals(ident.getName()) || "arguments".equals(ident.getName())) {
                 error(AbstractParser.message("strict.name", ident.getName(), contextString), ident.getToken());
-            default:
-                break;
             }
         }
     }
@@ -921,7 +917,7 @@
         // VAR tested in caller.
         next();
 
-        final List<VarNode> vars = new ArrayList<>();
+        final List<VarNode> vars = new ArrayList<VarNode>();
 
         while (true) {
             // Get starting token.
@@ -1558,7 +1554,7 @@
             expect(LBRACE);
 
             // Prepare to accumulate cases.
-            final List<CaseNode> cases = new ArrayList<>();
+            final List<CaseNode> cases = new ArrayList<CaseNode>();
             CaseNode defaultCase = null;
 
             while (type != RBRACE) {
@@ -1724,7 +1720,7 @@
             final Block tryBody = getBlock(true);
 
             // Prepare to accumulate catches.
-            final List<Block> catchBlocks = new ArrayList<>();
+            final List<Block> catchBlocks = new ArrayList<Block>();
 
             while (type == CATCH) {
                 // Capture CATCH token.
@@ -1914,7 +1910,7 @@
         // Skip over EXECSTRING.
         next();
         // Set up argument list for call.
-        final List<Node> arguments = new ArrayList<>();
+        final List<Node> arguments = new ArrayList<Node>();
         // Skip beginning of edit string expression.
         expect(LBRACE);
         // Add the following expression to arguments.
@@ -1952,7 +1948,7 @@
         next();
 
         // Prepare to accummulating elements.
-        final List<Node> elements = new ArrayList<>();
+        final List<Node> elements = new ArrayList<Node>();
         // Track elisions.
         boolean elision = true;
 loop:
@@ -2019,8 +2015,8 @@
         // Object context.
         Block objectContext = null;
         // Prepare to accumulate elements.
-        final List<Node> elements = new ArrayList<>();
-        final Map<Object, PropertyNode> map = new HashMap<>();
+        final List<Node> elements = new ArrayList<Node>();
+        final Map<Object, PropertyNode> map = new HashMap<Object, PropertyNode>();
 
         try {
             // Create a block for the object literal.
@@ -2198,20 +2194,18 @@
             if (type != COLON) {
                 final long getSetToken = token;
 
-                switch (ident) {
-                case "get":
+                if ("get".equals(ident)) {
                     final PropertyKey getIdent = propertyName();
                     final String getterName = getIdent.getPropertyName();
                     final IdentNode getNameNode = new IdentNode(source, ((Node)getIdent).getToken(), finish, "get " + getterName);
                     expect(LPAREN);
                     expect(RPAREN);
-                    parameters = new ArrayList<>();
+                    parameters = new ArrayList<IdentNode>();
                     functionNode = functionBody(getSetToken, getNameNode, parameters, FunctionNode.Kind.GETTER);
                     propertyNode = new PropertyNode(source, propertyToken, finish, getIdent, null);
                     propertyNode.setGetter(new ReferenceNode(source, propertyToken, finish, functionNode));
                     return propertyNode;
-
-                case "set":
+                } else if ("set".equals(ident)) {
                     final PropertyKey setIdent = propertyName();
                     final String setterName = setIdent.getPropertyName();
                     final IdentNode setNameNode = new IdentNode(source, ((Node)setIdent).getToken(), finish, "set " + setterName);
@@ -2219,15 +2213,12 @@
                     final IdentNode argIdent = getIdent();
                     verifyStrictIdent(argIdent, "setter argument");
                     expect(RPAREN);
-                    parameters = new ArrayList<>();
+                    parameters = new ArrayList<IdentNode>();
                     parameters.add(argIdent);
                     functionNode = functionBody(getSetToken, setNameNode, parameters, FunctionNode.Kind.SETTER);
                     propertyNode = new PropertyNode(source, propertyToken, finish, setIdent, null);
                     propertyNode.setSetter(new ReferenceNode(source, propertyToken, finish, functionNode));
                     return propertyNode;
-
-                default:
-                    break;
                 }
             }
 
@@ -2354,7 +2345,7 @@
         if (type == LPAREN) {
             arguments = argumentList();
         } else {
-            arguments = new ArrayList<>();
+            arguments = new ArrayList<Node>();
         }
 
         // Nashorn extension: This is to support the following interface implementation
@@ -2471,7 +2462,7 @@
      */
     private List<Node> argumentList() {
         // Prepare to accumulate list of arguments.
-        final List<Node> nodeList = new ArrayList<>();
+        final List<Node> nodeList = new ArrayList<Node>();
         // LPAREN tested in caller.
         next();
 
@@ -2561,7 +2552,7 @@
 
         final boolean strict = functionNode.isStrictMode();
         if (arity > 1) {
-            final HashSet<String> parametersSet = new HashSet<>(arity);
+            final HashSet<String> parametersSet = new HashSet<String>(arity);
 
             for (int i = arity - 1; i >= 0; i--) {
                 final IdentNode parameter = parameters.get(i);
@@ -2617,7 +2608,7 @@
      */
     private List<IdentNode> formalParameterList() {
         // Prepare to gather parameters.
-        final List<IdentNode> parameters = new ArrayList<>();
+        final List<IdentNode> parameters = new ArrayList<IdentNode>();
         // Track commas.
         boolean first = true;
 
@@ -2703,7 +2694,7 @@
     }
 
     private RuntimeNode referenceError(final Node lhs, final Node rhs) {
-        final ArrayList<Node> args = new ArrayList<>();
+        final ArrayList<Node> args = new ArrayList<Node>();
         args.add(lhs);
         if (rhs == null) {
             args.add(LiteralNode.newInstance(source, lhs.getToken(), lhs.getFinish()));
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/parser/RegExp.java
--- a/src/jdk/nashorn/internal/parser/RegExp.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/parser/RegExp.java	Thu Feb 07 13:40:05 2013 +0100
@@ -69,7 +69,7 @@
      */
     public RegExp(final String input, final String flagString) throws ParserException {
         this.input = input;
-        final HashSet<Character> usedFlags = new HashSet<>();
+        final HashSet<Character> usedFlags = new HashSet<Character>();
         int flags = 0;
 
         for (final char ch : flagString.toCharArray()) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/parser/RegExpScanner.java
--- a/src/jdk/nashorn/internal/parser/RegExpScanner.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/parser/RegExpScanner.java	Thu Feb 07 13:40:05 2013 +0100
@@ -57,13 +57,13 @@
     private String javaPattern;
 
     /** Expected token table */
-    private final Map<Character, Integer> expected = new HashMap<>();
+    private final Map<Character, Integer> expected = new HashMap<Character, Integer>();
 
     /** Capturing parenthesis that have been found so far. */
-    private final List<Capture> caps = new LinkedList<>();
+    private final List<Capture> caps = new LinkedList<Capture>();
 
     /** Forward references to capturing parenthesis to be resolved later.*/
-    private final Map<Integer, Token> forwardReferences = new LinkedHashMap<>();
+    private final Map<Integer, Token> forwardReferences = new LinkedHashMap<Integer, Token>();
 
     /** Current level of zero-width negative lookahead assertions. */
     private int negativeLookaheadLevel;
@@ -154,7 +154,7 @@
          */
         private boolean isDead;
 
-        private static final Map<Type, ToString> toStringMap = new HashMap<>();
+        private static final Map<Type, ToString> toStringMap = new HashMap<Type, ToString>();
         private static final ToString DEFAULT_TOSTRING = new ToString();
 
         private static String unicode(final int value) {
@@ -230,18 +230,12 @@
 
                 //perform global substitutions that hold true for any evaluated form
                 String str = sb.toString();
-                switch (str) {
-                case "\\s":
+                if ("\\s".equals(str)) {
                     str = "[" + Lexer.getWhitespaceRegExp() + "]";
-                    break;
-                case "\\S":
+                } else if ("\\S".equals(str)) {
                     str = "[^" + Lexer.getWhitespaceRegExp() + "]";
-                    break;
-                case "[^]":
+                } else if ("[^]".equals(str)) {
                     str = "[\\s\\S]";
-                    break;
-                default:
-                    break;
                 }
                 return str;
             }
@@ -265,7 +259,7 @@
             }
 
             TokenIterator(final Token root) {
-                preorder = new ArrayList<>();
+                preorder = new ArrayList<Token>();
                 init(root);
             }
 
@@ -291,7 +285,7 @@
          */
         Token(final Token.Type type) {
             this.type = type;
-            children = new ArrayList<>();
+            children = new ArrayList<Object>();
         }
 
         /**
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/ConsString.java
--- a/src/jdk/nashorn/internal/runtime/ConsString.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/ConsString.java	Thu Feb 07 13:40:05 2013 +0100
@@ -92,7 +92,7 @@
         // to be very unbalanced, with mostly single string elements on the right and a long
         // linear list on the left. Traversing from right to left helps to keep the stack small
         // in this scenario.
-        final Deque<CharSequence> stack = new ArrayDeque<>();
+        final Deque<CharSequence> stack = new ArrayDeque<CharSequence>();
         stack.addFirst(left);
         CharSequence cs = right;
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/Context.java
--- a/src/jdk/nashorn/internal/runtime/Context.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/Context.java	Thu Feb 07 13:40:05 2013 +0100
@@ -44,8 +44,8 @@
 import java.security.PrivilegedAction;
 import java.util.Locale;
 import java.util.TimeZone;
-import jdk.internal.org.objectweb.asm.ClassReader;
-import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.util.CheckClassAdapter;
 import jdk.nashorn.internal.codegen.ClassEmitter;
 import jdk.nashorn.internal.codegen.Compiler;
 import jdk.nashorn.internal.codegen.Namespace;
@@ -553,7 +553,16 @@
             // because eval code may start with "use strict" directive.
             try {
                 strictFlag = clazz.getField(STRICT_MODE.tag()).getBoolean(null);
-            } catch (final NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {
+            } catch (final NoSuchFieldException e) {
+                //ignored
+                strictFlag = false;
+            } catch (final SecurityException e) {
+                //ignored
+                strictFlag = false;
+            } catch (final IllegalArgumentException e) {
+                //ignored
+                strictFlag = false;
+            } catch (final IllegalAccessException e) {
                 //ignored
                 strictFlag = false;
             }
@@ -879,7 +888,13 @@
 
         try {
             strict = script.getField(STRICT_MODE.tag()).getBoolean(null);
-        } catch (final NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {
+        } catch (final NoSuchFieldException e) {
+            strict = false;
+        } catch (final SecurityException e) {
+            strict = false;
+        } catch (final IllegalArgumentException e) {
+            strict = false;
+        } catch (final IllegalAccessException e) {
             strict = false;
         }
 
@@ -954,7 +969,19 @@
         try {
             final Class<?> clazz = Class.forName("jdk.nashorn.internal.objects.Global", true, scriptLoader);
             return (ScriptObject) clazz.newInstance();
-        } catch (final ClassNotFoundException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {
+        } catch (final ClassNotFoundException e) {
+            printStackTrace(e);
+            throw new RuntimeException(e);
+        } catch (final SecurityException e) {
+            printStackTrace(e);
+            throw new RuntimeException(e);
+        } catch (final InstantiationException e) {
+            printStackTrace(e);
+            throw new RuntimeException(e);
+        } catch (final IllegalAccessException e) {
+            printStackTrace(e);
+            throw new RuntimeException(e);
+        } catch (final IllegalArgumentException e) {
             printStackTrace(e);
             throw new RuntimeException(e);
         }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/ErrorManager.java
--- a/src/jdk/nashorn/internal/runtime/ErrorManager.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/ErrorManager.java	Thu Feb 07 13:40:05 2013 +0100
@@ -93,7 +93,7 @@
      * @return formatted string
      */
     public static String format(final String message, final Source source, final int line, final int column, final long token) {
-        final String        eoln     = System.lineSeparator();
+        final String        eoln     = "\n";
         final int           position = Token.descPosition(token);
         final StringBuilder sb       = new StringBuilder();
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/JSType.java
--- a/src/jdk/nashorn/internal/runtime/JSType.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/JSType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -58,49 +58,49 @@
     FUNCTION;
 
     /** Max value for an uint32 in JavaScript */
-    public static final long MAX_UINT = 0xFFFF_FFFFL;
+    public static final long MAX_UINT = 0xFFFFFFFFL;
 
     /** JavaScript compliant conversion function from Object to boolean */
-    public static final Call TO_BOOLEAN = staticCall(JSType.class, "toBoolean", boolean.class, Object.class);
+    public static final Call TO_BOOLEAN = null; //staticCall(JSType.class, "toBoolean", boolean.class, Object.class);
 
     /** JavaScript compliant conversion function from number to boolean */
-    public static final Call TO_BOOLEAN_D = staticCall(JSType.class, "toBoolean", boolean.class, double.class);
+    public static final Call TO_BOOLEAN_D = null; //staticCall(JSType.class, "toBoolean", boolean.class, double.class);
 
     /** JavaScript compliant conversion function from Object to integer */
-    public static final Call TO_INTEGER = staticCall(JSType.class, "toInteger", int.class, Object.class);
+    public static final Call TO_INTEGER = null; //staticCall(JSType.class, "toInteger", int.class, Object.class);
 
     /** JavaScript compliant conversion function from Object to long */
-    public static final Call TO_LONG = staticCall(JSType.class, "toLong", long.class, Object.class);
+    public static final Call TO_LONG = null; //staticCall(JSType.class, "toLong", long.class, Object.class);
 
     /** JavaScript compliant conversion function from Object to number */
-    public static final Call TO_NUMBER = staticCall(JSType.class, "toNumber", double.class, Object.class);
+    public static final Call TO_NUMBER = null; //staticCall(JSType.class, "toNumber", double.class, Object.class);
 
     /** JavaScript compliant conversion function from Object to int32 */
-    public static final Call TO_INT32 = staticCall(JSType.class, "toInt32", int.class, Object.class);
+    public static final Call TO_INT32 = null; //staticCall(JSType.class, "toInt32", int.class, Object.class);
 
     /** JavaScript compliant conversion function from double to int32 */
-    public static final Call TO_INT32_D = staticCall(JSType.class, "toInt32", int.class, double.class);
+    public static final Call TO_INT32_D = null; //staticCall(JSType.class, "toInt32", int.class, double.class);
 
     /** JavaScript compliant conversion function from Object to uint32 */
-    public static final Call TO_UINT32 = staticCall(JSType.class, "toUint32", long.class, Object.class);
+    public static final Call TO_UINT32 = null; //staticCall(JSType.class, "toUint32", long.class, Object.class);
 
     /** JavaScript compliant conversion function from number to uint32 */
-    public static final Call TO_UINT32_D = staticCall(JSType.class, "toUint32", long.class, double.class);
+    public static final Call TO_UINT32_D = null; //staticCall(JSType.class, "toUint32", long.class, double.class);
 
     /** JavaScript compliant conversion function from Object to int64 */
-    public static final Call TO_INT64 = staticCall(JSType.class, "toInt64", long.class, Object.class);
+    public static final Call TO_INT64 = null; //staticCall(JSType.class, "toInt64", long.class, Object.class);
 
     /** JavaScript compliant conversion function from number to int64 */
-    public static final Call TO_INT64_D = staticCall(JSType.class, "toInt64", long.class, double.class);
+    public static final Call TO_INT64_D = null; //staticCall(JSType.class, "toInt64", long.class, double.class);
 
     /** JavaScript compliant conversion function from Object to String */
-    public static final Call TO_STRING = staticCall(JSType.class, "toString", String.class, Object.class);
+    public static final Call TO_STRING = null; //staticCall(JSType.class, "toString", String.class, Object.class);
 
     /** JavaScript compliant conversion function from number to String */
-    public static final Call TO_STRING_D = staticCall(JSType.class, "toString", String.class, double.class);
+    public static final Call TO_STRING_D = null; //staticCall(JSType.class, "toString", String.class, double.class);
 
     /** JavaScript compliant conversion function from Object to primitive */
-    public static final Call TO_PRIMITIVE = staticCall(JSType.class, "toPrimitive", Object.class,  Object.class);
+    public static final Call TO_PRIMITIVE = null; //staticCall(JSType.class, "toPrimitive", Object.class,  Object.class);
 
     /**
      * The external type name as returned by ECMAScript "typeof" operator
@@ -661,7 +661,7 @@
         if (Double.isInfinite(num)) {
             return 0L;
         }
-        return ((long)num) & 0xffff_ffffL;
+        return ((long)num) & 0xffffffffL;
     }
 
     /**
@@ -873,6 +873,8 @@
             return toString(toPrimitive(obj, String.class));
         }
 
+        // netbeans - this would be true only if there would be descendant of StaticClass
+        // so there would be CNFE much earlier
         if (obj instanceof StaticClass) {
             return "[JavaClass " + ((StaticClass)obj).getRepresentedClass().getName() + "]";
         }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/Logging.java
--- a/src/jdk/nashorn/internal/runtime/Logging.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/Logging.java	Thu Feb 07 13:40:05 2013 +0100
@@ -58,7 +58,7 @@
     }
 
     /** Maps logger name to loggers. Names are typically per package */
-    private static final Map<String, Logger> loggers = new HashMap<>();
+    private static final Map<String, Logger> loggers = new HashMap<String, Logger>();
 
     private static String lastPart(final String packageName) {
         final String[] parts = packageName.split("\\.");
@@ -125,7 +125,9 @@
 
                 Logging.loggers.put(name, logger);
             }
-        } catch (final IllegalArgumentException | SecurityException e) {
+        } catch (final IllegalArgumentException e) {
+            throw e;
+        } catch (final SecurityException e) {
             throw e;
         }
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/NumberToString.java
--- a/src/jdk/nashorn/internal/runtime/NumberToString.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/NumberToString.java	Thu Feb 07 13:40:05 2013 +0100
@@ -52,9 +52,9 @@
 
     //private static final long   signMask           = 0x8000000000000000L;
     private static final int    expMask            = 0x7FF;
-    private static final long   fractMask          = 0x000F_FFFF_FFFF_FFFFL;
+    private static final long   fractMask          = 0x000FFFFFFFFFFFFFL;
     private static final int    expShift           = 52;
-    private static final int    expBias            = 1_023;
+    private static final int    expBias            = 1023;
     private static final long   fractHOB           = (1L << expShift);
     private static final long   expOne             = ((long)expBias) << expShift;
     private static final int    maxSmallBinExp     = 62;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/Property.java
--- a/src/jdk/nashorn/internal/runtime/Property.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/Property.java	Thu Feb 07 13:40:05 2013 +0100
@@ -30,7 +30,7 @@
 import static jdk.nashorn.internal.runtime.PropertyDescriptor.WRITABLE;
 
 import java.lang.invoke.MethodHandle;
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.codegen.objects.ObjectClassGenerator;
 import jdk.nashorn.internal.codegen.types.Type;
 
@@ -54,30 +54,30 @@
      */
 
     /** ECMA 8.6.1 - Is this property not writable? */
-    public static final int NOT_WRITABLE     = 0b0000_0000_0001;
+    public static final int NOT_WRITABLE     = 0x001; //0b0000_0000_0001;
 
     /** ECMA 8.6.1 - Is this property not enumerable? */
-    public static final int NOT_ENUMERABLE   = 0b0000_0000_0010;
+    public static final int NOT_ENUMERABLE   = 0x002; //0b0000_0000_0010;
 
     /** ECMA 8.6.1 - Is this property not configurable? */
-    public static final int NOT_CONFIGURABLE = 0b0000_0000_0100;
+    public static final int NOT_CONFIGURABLE = 0x004; //0b0000_0000_0100;
 
-    private static final int MODIFY_MASK     = 0b0000_0000_1111;
+    private static final int MODIFY_MASK     = 0x00F; //0b0000_0000_1111;
 
     /** Is this a spill property? See {@link SpillProperty} */
-    public static final int IS_SPILL         = 0b0000_0001_0000;
+    public static final int IS_SPILL         = 0x010; //0b0000_0001_0000;
 
     /** Is this a function parameter ? */
-    public static final int IS_PARAMETER     = 0b0000_0010_0000;
+    public static final int IS_PARAMETER     = 0x020; //0b0000_0010_0000;
 
     /** Is this property always represented as an Object? See {@link ObjectClassGenerator} and dual fields flag. */
-    public static final int IS_ALWAYS_OBJECT = 0b0000_0100_0000;
+    public static final int IS_ALWAYS_OBJECT = 0x040; //0b0000_0100_0000;
 
     /** Can this property be primitive? */
-    public static final int CAN_BE_PRIMITIVE = 0b0000_1000_0000;
+    public static final int CAN_BE_PRIMITIVE = 0x080; //0b0000_1000_0000;
 
     /** Can this property be undefined? */
-    public static final int CAN_BE_UNDEFINED = 0b0001_0000_0000;
+    public static final int CAN_BE_UNDEFINED = 0x100; //0b0001_0000_0000;
 
     /** Property key. */
     private final String key;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/PropertyHashMap.java
--- a/src/jdk/nashorn/internal/runtime/PropertyHashMap.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/PropertyHashMap.java	Thu Feb 07 13:40:05 2013 +0100
@@ -547,7 +547,7 @@
 
     @Override
     public Set<String> keySet() {
-        final HashSet<String> set = new HashSet<>();
+        final HashSet<String> set = new HashSet<String>();
         for (Element element = list; element != null; element = element.getLink()) {
             set.add(element.getKey());
         }
@@ -561,7 +561,7 @@
 
     @Override
     public Set<Entry<String, Property>> entrySet() {
-        final HashSet<Entry<String, Property>> set = new HashSet<>();
+        final HashSet<Entry<String, Property>> set = new HashSet<Entry<String, Property>>();
         for (Element element = list; element != null; element = element.getLink()) {
             set.add(element);
         }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/PropertyListenerManager.java
--- a/src/jdk/nashorn/internal/runtime/PropertyListenerManager.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/PropertyListenerManager.java	Thu Feb 07 13:40:05 2013 +0100
@@ -73,12 +73,12 @@
      */
     public final void addPropertyListener(final PropertyListener listener) {
         if (listeners == null) {
-            listeners = new ArrayList<>();
+            listeners = new ArrayList<WeakReference<PropertyListener>>();
         }
         if (Context.DEBUG) {
             listenersAdded++;
         }
-        listeners.add(new WeakReference<>(listener));
+        listeners.add(new WeakReference<PropertyListener>(listener));
     }
 
     /**
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/PropertyMap.java
--- a/src/jdk/nashorn/internal/runtime/PropertyMap.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/PropertyMap.java	Thu Feb 07 13:40:05 2013 +0100
@@ -50,13 +50,13 @@
  */
 public final class PropertyMap implements Iterable<Object>, PropertyListener {
     /** Is this a prototype PropertyMap? */
-    public static final int IS_PROTOTYPE          = 0b0000_0001;
+    public static final int IS_PROTOTYPE          = 0x01; //0b0000_0001;
     /** Used for non extensible PropertyMaps, negative logic as the normal case is extensible. See {@link ScriptObject#preventExtensions()} */
-    public static final int NOT_EXTENSIBLE        = 0b0000_0010;
+    public static final int NOT_EXTENSIBLE        = 0x02; //0b0000_0010;
     /** This mask is used to preserve certain flags when cloning the PropertyMap. Others should not be copied */
-    private static final int CLONEABLE_FLAGS_MASK = 0b0000_1111;
+    private static final int CLONEABLE_FLAGS_MASK = 0x0F; //0b0000_1111;
     /** Has a listener been added to this property map. This flag is not copied when cloning a map. See {@link PropertyListener} */
-    public static final int IS_LISTENER_ADDED     = 0b0001_0000;
+    public static final int IS_LISTENER_ADDED     = 0x10; //0b0001_0000;
 
     /** Map status flags. */
     private int flags;
@@ -205,7 +205,7 @@
         }
 
         if (protoGetSwitches == null) {
-            protoGetSwitches = new HashMap<>();
+            protoGetSwitches = new HashMap<String, SwitchPoint>();
             if (! isListenerAdded()) {
                 proto.addPropertyListener(this);
                 setIsListenerAdded();
@@ -526,10 +526,10 @@
      */
     private void addToProtoHistory(final ScriptObject newProto, final PropertyMap newMap) {
         if (protoHistory == null) {
-            protoHistory = new WeakHashMap<>();
+            protoHistory = new WeakHashMap<ScriptObject, WeakReference<PropertyMap>>();
         }
 
-        protoHistory.put(newProto, new WeakReference<>(newMap));
+        protoHistory.put(newProto, new WeakReference<PropertyMap>(newMap));
     }
 
     /**
@@ -540,7 +540,7 @@
      */
     private void addToHistory(final Property property, final PropertyMap newMap) {
         if (history == null) {
-            history = new LinkedHashMap<>();
+            history = new LinkedHashMap<Property, PropertyMap>();
         }
 
         history.put(property, newMap);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/QuotedStringTokenizer.java
--- a/src/jdk/nashorn/internal/runtime/QuotedStringTokenizer.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/QuotedStringTokenizer.java	Thu Feb 07 13:40:05 2013 +0100
@@ -84,7 +84,7 @@
         }
 
         final StringTokenizer st = new StringTokenizer(str, delim);
-        tokens = new LinkedList<>();
+        tokens = new LinkedList<String>();
         while (st.hasMoreTokens()) {
             String token = st.nextToken();
 
@@ -133,7 +133,7 @@
     }
 
     private boolean unmatchedQuotesIn(final String str) {
-        final Stack<Character> quoteStack = new Stack<>();
+        final Stack<Character> quoteStack = new Stack<Character>();
         for (int i = 0; i < str.length(); i++) {
             final char c = str.charAt(i);
             for (final char q : this.quotes) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/ScriptFunction.java
--- a/src/jdk/nashorn/internal/runtime/ScriptFunction.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/ScriptFunction.java	Thu Feb 07 13:40:05 2013 +0100
@@ -346,7 +346,9 @@
         if (data.getAllocator() != null) {
             try {
                 object = (ScriptObject)data.getAllocator().invokeExact(data.getAllocatorMap());
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/ScriptFunctionData.java
--- a/src/jdk/nashorn/internal/runtime/ScriptFunctionData.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/ScriptFunctionData.java	Thu Feb 07 13:40:05 2013 +0100
@@ -42,10 +42,10 @@
 public class ScriptFunctionData {
 
     // per-function object flags
-    private static final int IS_STRICT  = 0b0000_0001;
-    private static final int IS_BUILTIN = 0b0000_0010;
-    private static final int HAS_CALLEE = 0b0000_0100;
-    private static final int IS_VARARGS = 0b0000_1000;
+    private static final int IS_STRICT  = 0x01; //0b0000_0001;
+    private static final int IS_BUILTIN = 0x02; //0b0000_0010;
+    private static final int HAS_CALLEE = 0x04; //0b0000_0100;
+    private static final int IS_VARARGS = 0x08; //0b0000_1000;
 
     /** Name of the function or "" */
     private final String name;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/ScriptObject.java
--- a/src/jdk/nashorn/internal/runtime/ScriptObject.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/ScriptObject.java	Thu Feb 07 13:40:05 2013 +0100
@@ -95,13 +95,13 @@
     public static final String NO_SUCH_PROPERTY_NAME = "__noSuchProperty__";
 
     /** Per ScriptObject flag - is this a scope object? */
-    public static final int IS_SCOPE       = 0b0000_0001;
+    public static final int IS_SCOPE       = 0x01; //0b0000_0001;
 
     /** Per ScriptObject flag - is this an array object? */
-    public static final int IS_ARRAY       = 0b0000_0010;
+    public static final int IS_ARRAY       = 0x02; //0b0000_0010;
 
     /** Per ScriptObject flag - is this an arguments object? */
-    public static final int IS_ARGUMENTS   = 0b0000_0100;
+    public static final int IS_ARGUMENTS   = 0x04; //0b0000_0100;
 
     /** Spill growth rate - by how many elements does {@link ScriptObject#spill} when full */
     public static final int SPILL_RATE = 8;
@@ -704,7 +704,9 @@
 
         try {
             setter.invokeExact((Object)this, value);
-        } catch (final Error|RuntimeException e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable e) {
             throw new RuntimeException(e);
@@ -749,7 +751,9 @@
                 // make the property value to be undefined
                 //TODO specproperties
                 property.getSetter(Object.class, getMap()).invokeExact((Object)this, (Object)UNDEFINED);
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
@@ -900,8 +904,10 @@
         final MethodHandle getter = find.getGetter(int.class);
         if (getter != null) {
             try {
-                return (int)getter.invokeExact((Object)find.getOwner());
-            } catch (final Error|RuntimeException e) {
+                return (Integer)getter.invokeExact((Object)find.getOwner());
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable e) {
                 throw new RuntimeException(e);
@@ -915,8 +921,10 @@
         final MethodHandle getter = find.getGetter(long.class);
         if (getter != null) {
             try {
-                return (long)getter.invokeExact((Object)find.getOwner());
-            } catch (final Error|RuntimeException e) {
+                return (Long)getter.invokeExact((Object)find.getOwner());
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable e) {
                 throw new RuntimeException(e);
@@ -930,8 +938,10 @@
         final MethodHandle getter = find.getGetter(double.class);
         if (getter != null) {
             try {
-                return (double)getter.invokeExact((Object)find.getOwner());
-            } catch (final Error|RuntimeException e) {
+                return (Double)getter.invokeExact((Object)find.getOwner());
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable e) {
                 throw new RuntimeException(e);
@@ -953,7 +963,9 @@
         if (getter != null) {
             try {
                 return getter.invokeExact((Object)find.getOwner());
-            } catch (final Error|RuntimeException e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable e) {
                 throw new RuntimeException(e);
@@ -1162,7 +1174,7 @@
      * @return Array of keys.
      */
     public String[] getOwnKeys(final boolean all) {
-        final List<Object> keys    = new ArrayList<>();
+        final List<Object> keys    = new ArrayList<Object>();
         final PropertyMap  selfMap = this.getMap();
 
         final ArrayData array  = getArray();
@@ -1470,10 +1482,10 @@
      */
     public Set<Map.Entry<Object, Object>> entrySet() {
         final Iterator<String> iter = propertyIterator();
-        final Set<Map.Entry<Object, Object>> entries = new HashSet<>();
+        final Set<Map.Entry<Object, Object>> entries = new HashSet<Map.Entry<Object, Object>>();
         while (iter.hasNext()) {
             final Object key = iter.next();
-            entries.add(new AbstractMap.SimpleImmutableEntry<>(key, get(key)));
+            entries.add(new AbstractMap.SimpleImmutableEntry<Object, Object>(key, get(key)));
         }
         return Collections.unmodifiableSet(entries);
     }
@@ -1497,7 +1509,7 @@
      */
     public Set<Object> keySet() {
         final Iterator<String> iter = propertyIterator();
-        final Set<Object> keySet = new HashSet<>();
+        final Set<Object> keySet = new HashSet<Object>();
         while (iter.hasNext()) {
             keySet.add(iter.next());
         }
@@ -1567,7 +1579,7 @@
      * @return collection of values for the properties in this ScriptObject
      */
     public Collection<Object> values() {
-        final List<Object>     values = new ArrayList<>(size());
+        final List<Object>     values = new ArrayList<Object>(size());
         final Iterator<Object> iter   = valueIterator();
         while (iter.hasNext()) {
             values.add(iter.next());
@@ -1595,21 +1607,17 @@
         // emits "dyn:getProp:identifier" for "<expr>.<identifier>" and "dyn:getElem" for "<expr>[<expr>]", but we are
         // more flexible here and dispatch not on operation name (getProp vs. getElem), but rather on whether the
         // operation has an associated name or not.
-        switch (operator) {
-        case "getProp":
-        case "getElem":
-        case "getMethod":
+        if ("getProp".equals(operator) || "getElem".equals(operator) || "getMethod".equals(operator)) {
             return c > 2 ? findGetMethod(desc, request, operator) : findGetIndexMethod(desc, request);
-        case "setProp":
-        case "setElem":
+        } else if ("setProp".equals(operator) || "setElem".equals(operator)) {
             return c > 2 ? findSetMethod(desc, request) : findSetIndexMethod(desc);
-        case "call":
+        } else if ("call".equals(operator)) {
             return findCallMethod(desc, request);
-        case "new":
+        } else if ("new".equals(operator)) {
             return findNewMethod(desc);
-        case "callMethod":
+        } else if ("callMethod".equals(operator)) {
             return findCallMethodMethod(desc, request);
-        default:
+        } else {
             return null;
         }
     }
@@ -2019,7 +2027,7 @@
 
         @Override
         protected void init() {
-            final Set<String> keys = new LinkedHashSet<>();
+            final Set<String> keys = new LinkedHashSet<String>();
             for (ScriptObject self = object; self != null; self = self.getProto()) {
                 keys.addAll(Arrays.asList(self.getOwnKeys(false)));
             }
@@ -2034,7 +2042,7 @@
 
         @Override
         protected void init() {
-            final ArrayList<Object> valueList = new ArrayList<>();
+            final ArrayList<Object> valueList = new ArrayList<Object>();
             for (ScriptObject self = object; self != null; self = self.getProto()) {
                 for (final String key : self.getOwnKeys(false)) {
                     valueList.add(self.get(key));
@@ -2555,7 +2563,7 @@
      */
     private void doesNotHave(final int index, final Object value, final boolean strict) {
         final long oldLength = getArray().length();
-        final long longIndex = index & 0xffff_ffffL;
+        final long longIndex = index & 0xffffffffL;
 
         if (!getArray().has(index)) {
             final String key = convertKey(longIndex);
@@ -2578,11 +2586,11 @@
         }
 
         if (value instanceof Integer) {
-            setArray(getArray().set(index, (int)value, strict));
+            setArray(getArray().set(index, (Integer)value, strict));
         } else if (value instanceof Long) {
-            setArray(getArray().set(index, (long)value, strict));
+            setArray(getArray().set(index, (Long)value, strict));
         } else if (value instanceof Double) {
-            setArray(getArray().set(index, (double)value, strict));
+            setArray(getArray().set(index, (Double)value, strict));
         } else {
             setArray(getArray().set(index, value, strict));
         }
@@ -2628,7 +2636,9 @@
             setter = f.getSetter(Object.class, strict); //TODO specfields
             try {
                 setter.invokeExact((Object)f.getOwner(), value);
-            } catch (final Error|RuntimeException e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable e) {
                 throw new RuntimeException(e);
@@ -2645,7 +2655,9 @@
     private void spill(final String key, final Object value) {
         try {
             addSpill(key).invokeExact((Object)this, value);
-        } catch (final Error|RuntimeException e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable e) {
             throw new RuntimeException(e);
@@ -3268,7 +3280,9 @@
         if (func instanceof ScriptFunction) {
             try {
                 return INVOKE_UA_GETTER.invokeExact(func, self);
-            } catch(final Error|RuntimeException t) {
+            } catch(final RuntimeException t) {
+                throw t;
+            } catch(final Error t) {
                 throw t;
             } catch(final Throwable t) {
                 throw new RuntimeException(t);
@@ -3286,7 +3300,9 @@
         if (func instanceof ScriptFunction) {
             try {
                 INVOKE_UA_SETTER.invokeExact(func, self, value);
-            } catch(final Error|RuntimeException t) {
+            } catch(final RuntimeException t) {
+                throw t;
+            } catch(final Error t) {
                 throw t;
             } catch(final Throwable t) {
                 throw new RuntimeException(t);
@@ -3315,7 +3331,9 @@
         if (self instanceof ScriptObject && ((ScriptObject)self).getMap() == map) {
             try {
                 return getter.invokeExact(where) == func;
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/ScriptRuntime.java
--- a/src/jdk/nashorn/internal/runtime/ScriptRuntime.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/ScriptRuntime.java	Thu Feb 07 13:40:05 2013 +0100
@@ -36,7 +36,7 @@
 import java.lang.reflect.Array;
 import java.util.Collections;
 import java.util.Iterator;
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.codegen.CompilerConstants.Call;
 import jdk.nashorn.internal.runtime.linker.Bootstrap;
 import org.dynalang.dynalink.beans.StaticClass;
@@ -238,7 +238,7 @@
             };
         }
 
-        return Collections.emptyIterator();
+        return Collections.<String>emptySet().iterator();
     }
 
     /**
@@ -279,7 +279,7 @@
             return ((Iterable<?>)obj).iterator();
         }
 
-        return Collections.emptyIterator();
+        return Collections.emptySet().iterator();
     }
 
     /**
@@ -308,7 +308,9 @@
     public static Object apply(final ScriptFunction target, final Object self, final Object... args) {
         try {
             return target.invoke(self, args);
-        } catch (final RuntimeException | Error e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable t) {
             throw new RuntimeException(t);
@@ -326,7 +328,9 @@
             final ScriptObject allocation = (ScriptObject)target.allocate();
             final Object result = target.construct(allocation, args);
             return result instanceof ScriptObject ? result : allocation;
-        } catch (final RuntimeException | Error e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable t) {
             throw new RuntimeException(t);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/ScriptingFunctions.java
--- a/src/jdk/nashorn/internal/runtime/ScriptingFunctions.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/ScriptingFunctions.java	Thu Feb 07 13:40:05 2013 +0100
@@ -156,10 +156,13 @@
         final Process process = processBuilder.start();
 
         // If input is present, pass on to process.
-        try (OutputStream outputStream = process.getOutputStream()) {
+        OutputStream outputStream = process.getOutputStream();
+        try {
             if (input != UNDEFINED) {
                 outputStream.write(JSType.toString(input).getBytes());
             }
+        } finally {
+            outputStream.close();
         }
 
         // Wait for the process to complete.
@@ -167,22 +170,28 @@
 
         // Collect output.
         String out;
-         try (InputStream inputStream = process.getInputStream()) {
+        InputStream inputStream = process.getInputStream();
+        try {
             final StringBuilder outBuffer = new StringBuilder();
             for (int ch; (ch = inputStream.read()) != -1; ) {
                 outBuffer.append((char)ch);
             }
             out = outBuffer.toString();
+        } finally {
+            inputStream.close();
         }
 
         // Collect errors.
         String err;
-        try (InputStream errorStream = process.getErrorStream()) {
+        InputStream errorStream = process.getErrorStream();
+        try {
             final StringBuilder errBuffer = new StringBuilder();
             for (int ch; (ch = errorStream.read()) != -1; ) {
                 errBuffer.append((char)ch);
             }
             err = errBuffer.toString();
+        } finally {
+            errorStream.close();
         }
 
         // Set globals for secondary results.
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/Source.java
--- a/src/jdk/nashorn/internal/runtime/Source.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/Source.java	Thu Feb 07 13:40:05 2013 +0100
@@ -35,12 +35,10 @@
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.Arrays;
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
 import jdk.nashorn.internal.parser.Token;
 
 /**
@@ -335,7 +333,7 @@
         if (!file.isFile()) {
             throw new IOException(file + " is not a file"); //TODO localize?
         }
-        return byteToCharArray(Files.readAllBytes(file.toPath()));
+        return readFully(new BufferedInputStream(new FileInputStream(file)));
     }
 
     /**
@@ -350,10 +348,14 @@
     private static String baseURL(final URL url, final String defaultValue) {
         if (url.getProtocol().equals("file")) {
             try {
-                final Path path = Paths.get(url.toURI());
-                final Path parent = path.getParent();
+                final File path = new File(url.toURI());
+                final File parent = path.getParentFile();
                 return (parent != null) ? (parent + File.separator) : defaultValue;
-            } catch (final SecurityException | URISyntaxException | IOError e) {
+            } catch (final SecurityException e) {
+                return defaultValue;
+            } catch (final URISyntaxException e) {
+                return defaultValue;
+            } catch (final IOError e) {
                 return defaultValue;
             }
         }
@@ -391,18 +393,18 @@
     }
 
     private static char[] byteToCharArray(final byte[] bytes) {
-        Charset cs = StandardCharsets.UTF_8;
+        Charset cs = Charset.forName("UTF-8");
         int start = 0;
         // BOM detection.
         if (bytes.length > 1 && bytes[0] == (byte)0xFE && bytes[1] == (byte)0xFF) {
             start = 2;
-            cs = StandardCharsets.UTF_16BE;
+            cs = Charset.forName("UTF-16BE");
         } else if (bytes.length > 1 && bytes[0] == (byte)0xFF && bytes[1] == (byte)0xFE) {
             start = 2;
-            cs = StandardCharsets.UTF_16LE;
+            cs = Charset.forName("UTF-16LE");
         } else if (bytes.length > 2 && bytes[0] == (byte)0xEF && bytes[1] == (byte)0xBB && bytes[2] == (byte)0xBF) {
             start = 3;
-            cs = StandardCharsets.UTF_8;
+            cs = Charset.forName("UTF-8");
         } else if (bytes.length > 3 && bytes[0] == (byte)0xFF && bytes[1] == (byte)0xFE && bytes[2] == 0 && bytes[3] == 0) {
             start = 4;
             cs = Charset.forName("UTF-32LE");
@@ -417,12 +419,17 @@
     static byte[] readBytes(final InputStream is) throws IOException {
         final byte[] arr = new byte[BUFSIZE];
         try {
-            try (ByteArrayOutputStream buf = new ByteArrayOutputStream()) {
+            ByteArrayOutputStream buf = new ByteArrayOutputStream();
+            try {
                 int numBytes;
                 while ((numBytes = is.read(arr, 0, arr.length)) > 0) {
                     buf.write(arr, 0, numBytes);
                 }
                 return buf.toByteArray();
+            } finally {
+                if (buf != null) {
+                    buf.close();
+                }
             }
         } finally {
             is.close();
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/StructureLoader.java
--- a/src/jdk/nashorn/internal/runtime/StructureLoader.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/StructureLoader.java	Thu Feb 07 13:40:05 2013 +0100
@@ -76,7 +76,8 @@
                     public Class<?> run() throws ClassNotFoundException {
                         final String      source  = name.replace('.','/') + ".clazz";
                         final URL         url     = getResource(source);
-                        try (final InputStream is = getResourceAsStream(source)) {
+                        final InputStream is = getResourceAsStream(source);
+                        try {
                             if (is == null) {
                                 throw new ClassNotFoundException(name);
                             }
@@ -94,8 +95,12 @@
                                 resolveClass(cl);
                             }
                             return cl;
-                        } catch (final IOException e) {
-                            throw new RuntimeException(e);
+                        } finally {
+                            try {
+                                is.close();
+                            } catch (final IOException e) {
+                                throw new RuntimeException(e);
+                            }
                         }
                     }
                 });
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/Undefined.java
--- a/src/jdk/nashorn/internal/runtime/Undefined.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/Undefined.java	Thu Feb 07 13:40:05 2013 +0100
@@ -94,35 +94,24 @@
     public static GuardedInvocation lookup(final CallSiteDescriptor desc) {
         final String operator = CallSiteDescriptorFactory.tokenizeOperators(desc).get(0);
 
-        switch (operator) {
-        case "new":
-        case "call":
+        if ("new".equals(operator) || "call".equals(operator)) {
             lookupTypeError("cant.call.undefined", desc);
-            break;
-        case "callMethod":
+        } else if ("callMethod".equals(operator)) {
             lookupTypeError("cant.read.property.of.undefined", desc);
         // NOTE: we support getElem and setItem as JavaScript doesn't distinguish items from properties. Nashorn itself
         // emits "dyn:getProp:identifier" for "<expr>.<identifier>" and "dyn:getElem" for "<expr>[<expr>]", but we are
         // more flexible here and dispatch not on operation name (getProp vs. getElem), but rather on whether the
         // operation has an associated name or not.
-            break;
-        case "getProp":
-        case "getElem":
-        case "getMethod":
+        } else if ("getProp".equals(operator) || "getElem".equals(operator) || "getMethod".equals(operator)) {
             if (desc.getNameTokenCount() < 3) {
                 return findGetIndexMethod(desc);
             }
             lookupTypeError("cant.read.property.of.undefined", desc);
-            break;
-        case "setProp":
-        case "setElem":
+        } else if ("setProp".equals(operator) || "setElem".equals(operator)) {
             if (desc.getNameTokenCount() < 3) {
                 return findSetIndexMethod(desc);
             }
             lookupTypeError("cant.set.property.of.undefined", desc);
-            break;
-        default:
-            break;
         }
 
         return null;
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/WithObject.java
--- a/src/jdk/nashorn/internal/runtime/WithObject.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/WithObject.java	Thu Feb 07 13:40:05 2013 +0100
@@ -136,34 +136,23 @@
 
             final String operator = CallSiteDescriptorFactory.tokenizeOperators(desc).get(0);
 
-            switch (operator) {
-            case "callMethod":
+            if ("callMethod".equals(operator)) {
                 throw new AssertionError(); // Nashorn never emits callMethod
-            case "getMethod":
+            } else if ("getMethod".equals(operator)) {
                 fallBack = NO_SUCH_METHOD_NAME;
-                break;
-            case "getProp":
-            case "getElem":
+            } else if ("getProp".equals(operator) || "getElem".equals(operator)) {
                 fallBack = NO_SUCH_PROPERTY_NAME;
-                break;
-            default:
+            } else {
                 fallBack = null;
-                break;
             }
 
             if (fallBack != null) {
                 find = self.findProperty(fallBack, true);
                 if (find != null) {
-                    switch (operator) {
-                    case "getMethod":
+                    if ("getMethod".equals(operator)) {
                         link = self.noSuchMethod(desc, request);
-                        break;
-                    case "getProp":
-                    case "getElem":
+                    } else if ("getProp".equals(operator) || "getElem".equals(operator)) {
                         link = self.noSuchProperty(desc, request);
-                        break;
-                    default:
-                        break;
                     }
                 }
             }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/arrays/ArrayData.java
--- a/src/jdk/nashorn/internal/runtime/arrays/ArrayData.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/arrays/ArrayData.java	Thu Feb 07 13:40:05 2013 +0100
@@ -199,7 +199,9 @@
             for (int i = 0; i < src.length; i++) {
                 Array.set(dst, i, invoke(converter, src[i]));
             }
-        } catch (final RuntimeException | Error e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable t) {
             throw new RuntimeException(t);
@@ -498,7 +500,9 @@
     static Object invoke(final MethodHandle mh, final Object arg) {
         try {
             return mh.invoke(arg);
-        } catch (final RuntimeException | Error e) {
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Error e) {
             throw e;
         } catch (final Throwable t) {
             throw new RuntimeException(t);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/arrays/IntArrayData.java
--- a/src/jdk/nashorn/internal/runtime/arrays/IntArrayData.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/arrays/IntArrayData.java	Thu Feb 07 13:40:05 2013 +0100
@@ -166,7 +166,7 @@
             array[index] = intValue;
             setLength(Math.max(index + 1, length()));
             return this;
-        } catch (final NullPointerException | ClassCastException e) {
+        } catch (final NullPointerException e) {
             if (value instanceof Short || value instanceof Byte) {
                 final int intValue = ((Number)value).intValue();
                 array[index] = intValue;
@@ -177,6 +177,16 @@
             if (value == ScriptRuntime.UNDEFINED) {
                 return new UndefinedArrayFilter(this).set(index, value, strict);
             }
+        } catch (final ClassCastException e) {
+            if (value instanceof Short || value instanceof Byte) {
+                final int intValue = ((Number)value).intValue();
+                array[index] = intValue;
+                setLength(Math.max(index + 1, length()));
+                return this;
+            }
+            if (value == ScriptRuntime.UNDEFINED) {
+                return new UndefinedArrayFilter(this).set(index, value, strict);
+            }
         }
 
         final ArrayData newData = convert(value == null ? Object.class : value.getClass());
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/arrays/IteratorAction.java
--- a/src/jdk/nashorn/internal/runtime/arrays/IteratorAction.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/arrays/IteratorAction.java	Thu Feb 07 13:40:05 2013 +0100
@@ -115,7 +115,9 @@
                 if (!forEach(val, index)) {
                     return result;
                 }
-            } catch (final RuntimeException | Error e) {
+            } catch (final RuntimeException e) {
+                throw e;
+            } catch (final Error e) {
                 throw e;
             } catch (final Throwable t) {
                 throw new RuntimeException(t);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/arrays/LongArrayData.java
--- a/src/jdk/nashorn/internal/runtime/arrays/LongArrayData.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/arrays/LongArrayData.java	Thu Feb 07 13:40:05 2013 +0100
@@ -143,7 +143,11 @@
             array[index] = longValue;
             setLength(Math.max(index + 1, length()));
             return this;
-        } catch (final NullPointerException | ClassCastException e) {
+        } catch (final NullPointerException e) {
+            if (value == ScriptRuntime.UNDEFINED) {
+                return new UndefinedArrayFilter(this).set(index, value, strict);
+            }
+        } catch (final ClassCastException e) {
             if (value == ScriptRuntime.UNDEFINED) {
                 return new UndefinedArrayFilter(this).set(index, value, strict);
             }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/arrays/NumberArrayData.java
--- a/src/jdk/nashorn/internal/runtime/arrays/NumberArrayData.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/arrays/NumberArrayData.java	Thu Feb 07 13:40:05 2013 +0100
@@ -132,7 +132,11 @@
             array[index] = doubleValue;
             setLength(Math.max(index + 1, length()));
             return this;
-        } catch (final NullPointerException | ClassCastException e) {
+        } catch (final NullPointerException e) {
+            if (value == UNDEFINED) {
+                return new UndefinedArrayFilter(this).set(index, value, strict);
+            }
+        } catch (final ClassCastException e) {
             if (value == UNDEFINED) {
                 return new UndefinedArrayFilter(this).set(index, value, strict);
             }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/arrays/SparseArrayData.java
--- a/src/jdk/nashorn/internal/runtime/arrays/SparseArrayData.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/arrays/SparseArrayData.java	Thu Feb 07 13:40:05 2013 +0100
@@ -45,7 +45,7 @@
     private final long maxDenseLength;
 
     /** Sparse elements. */
-    private TreeMap<Long, Object> sparseMap = new TreeMap<>();
+    private TreeMap<Long, Object> sparseMap = new TreeMap<Long, Object>();
 
     SparseArrayData(final ArrayData underlying) {
         super(underlying.length());
@@ -85,7 +85,7 @@
     public void shiftLeft(final int by) {
         underlying.shiftLeft(by);
 
-        final TreeMap<Long, Object> newSparseMap = new TreeMap<>();
+        final TreeMap<Long, Object> newSparseMap = new TreeMap<Long, Object>();
 
         for (final Map.Entry<Long, Object> entry : sparseMap.entrySet()) {
             final long newIndex = entry.getKey().longValue() - by;
@@ -102,7 +102,7 @@
 
     @Override
     public ArrayData shiftRight(final int by) {
-        final TreeMap<Long, Object> newSparseMap = new TreeMap<>();
+        final TreeMap<Long, Object> newSparseMap = new TreeMap<Long, Object>();
         if (underlying.length() + by > maxDenseLength) {
             for (long i = maxDenseLength - by; i < underlying.length(); i++) {
                 if (underlying.has((int) i)) {
@@ -273,7 +273,7 @@
     }
 
     private static Long indexToKey(final int index) {
-        return Long.valueOf(index & 0xffff_ffffL);
+        return Long.valueOf(index & 0xffffffffL);
     }
 
     @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/linker/JSObjectLinker.java
--- a/src/jdk/nashorn/internal/runtime/linker/JSObjectLinker.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/linker/JSObjectLinker.java	Thu Feb 07 13:40:05 2013 +0100
@@ -28,7 +28,7 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
-import java.util.Objects;
+import jdk.nashorn.internal.compat.Objects;
 import jdk.nashorn.internal.runtime.JSType;
 import netscape.javascript.JSObject;
 import org.dynalang.dynalink.CallSiteDescriptor;
@@ -60,15 +60,13 @@
 
         static GuardedInvocation lookup(final CallSiteDescriptor desc) {
             final String operator = CallSiteDescriptorFactory.tokenizeOperators(desc).get(0);
-            switch (operator) {
-                case "call": {
-                    // collect everything except the first two - JSObjectMethod instance and the actual 'self'
-                    final int paramCount = desc.getMethodType().parameterCount();
-                    final MethodHandle caller = MH.asCollector(JSOBJECTMETHOD_CALL, Object[].class, paramCount - 2);
-                    return new GuardedInvocation(caller, null, IS_JSOBJECTMETHOD_GUARD);
-                }
-                default:
-                    return null;
+            if ("call".equals(operator)) {
+                // collect everything except the first two - JSObjectMethod instance and the actual 'self'
+                final int paramCount = desc.getMethodType().parameterCount();
+                final MethodHandle caller = MH.asCollector(JSOBJECTMETHOD_CALL, Object[].class, paramCount - 2);
+                return new GuardedInvocation(caller, null, IS_JSOBJECTMETHOD_GUARD);
+            } else {
+                return null;
             }
         }
     }
@@ -109,20 +107,16 @@
     private static GuardedInvocation lookup(final CallSiteDescriptor desc) {
         final String operator = CallSiteDescriptorFactory.tokenizeOperators(desc).get(0);
         final int c = desc.getNameTokenCount();
-        switch (operator) {
-            case "getProp":
-            case "getElem":
-            case "getMethod":
-                return c > 2 ? findGetMethod(desc, operator) : findGetIndexMethod();
-            case "setProp":
-            case "setElem":
-                return c > 2 ? findSetMethod(desc) : findSetIndexMethod();
-            case "call":
-            case "callMethod":
-                return findCallMethod(desc, operator);
-            case "new":
-            default:
-                return null;
+        if ("getProp".equals(operator) || "getElem".equals(operator) || "getMethod".equals(operator)) {
+            return c > 2 ? findGetMethod(desc, operator) : findGetIndexMethod();
+        } else if ("setProp".equals(operator) || "setElem".equals(operator)) {
+            return c > 2 ? findSetMethod(desc) : findSetIndexMethod();
+        } else if ("call".equals(operator) || "callMethod".equals(operator)) {
+            return findCallMethod(desc, operator);
+        } else if ("new".equals(operator)) {
+            return null;
+        } else {
+            return null;
         }
     }
 
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/linker/JavaAdapterFactory.java
--- a/src/jdk/nashorn/internal/runtime/linker/JavaAdapterFactory.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/linker/JavaAdapterFactory.java	Thu Feb 07 13:40:05 2013 +0100
@@ -25,21 +25,21 @@
 
 package jdk.nashorn.internal.runtime.linker;
 
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_VARARGS;
-import static jdk.internal.org.objectweb.asm.Opcodes.ACONST_NULL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
-import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;
-import static jdk.internal.org.objectweb.asm.Opcodes.IFNONNULL;
-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;
-import static jdk.internal.org.objectweb.asm.Opcodes.ISTORE;
-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
+import static org.objectweb.asm.Opcodes.ACC_FINAL;
+import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ACC_STATIC;
+import static org.objectweb.asm.Opcodes.ACC_SUPER;
+import static org.objectweb.asm.Opcodes.ACC_VARARGS;
+import static org.objectweb.asm.Opcodes.ACONST_NULL;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.ARETURN;
+import static org.objectweb.asm.Opcodes.ASTORE;
+import static org.objectweb.asm.Opcodes.DUP;
+import static org.objectweb.asm.Opcodes.IFNONNULL;
+import static org.objectweb.asm.Opcodes.ILOAD;
+import static org.objectweb.asm.Opcodes.ISTORE;
+import static org.objectweb.asm.Opcodes.RETURN;
 import static jdk.nashorn.internal.runtime.ECMAErrors.typeError;
 import static jdk.nashorn.internal.runtime.linker.Lookup.MH;
 
@@ -70,11 +70,11 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
-import jdk.internal.org.objectweb.asm.ClassWriter;
-import jdk.internal.org.objectweb.asm.Label;
-import jdk.internal.org.objectweb.asm.Opcodes;
-import jdk.internal.org.objectweb.asm.Type;
-import jdk.internal.org.objectweb.asm.commons.InstructionAdapter;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.commons.InstructionAdapter;
 import jdk.nashorn.internal.objects.NativeJava;
 import jdk.nashorn.internal.runtime.Context;
 import jdk.nashorn.internal.runtime.ECMAErrors;
@@ -209,7 +209,7 @@
     private static final ClassValue<Map<List<Class<?>>, AdapterInfo>> ADAPTER_INFO_MAPS = new ClassValue<Map<List<Class<?>>, AdapterInfo>>() {
         @Override
         protected Map<List<Class<?>>, AdapterInfo> computeValue(final Class<?> type) {
-            return new HashMap<>();
+            return new HashMap<List<Class<?>>, AdapterInfo>();
         }
     };
 
@@ -229,11 +229,11 @@
     private final String generatedClassName;
     // Binary name of the PrivilegedAction inner class that is used to
     private final String globalSetterClassName;
-    private final Set<String> usedFieldNames = new HashSet<>();
-    private final Set<String> abstractMethodNames = new HashSet<>();
+    private final Set<String> usedFieldNames = new HashSet<String>();
+    private final Set<String> abstractMethodNames = new HashSet<String>();
     private final String samName;
-    private final Set<MethodInfo> finalMethods = new HashSet<>(EXCLUDED);
-    private final Set<MethodInfo> methodInfos = new HashSet<>();
+    private final Set<MethodInfo> finalMethods = new HashSet<MethodInfo>(EXCLUDED);
+    private final Set<MethodInfo> methodInfos = new HashSet<MethodInfo>();
     private boolean autoConvertibleFromFunction = false;
 
     private final ClassWriter cw;
@@ -1102,7 +1102,7 @@
      */
     private static AdapterInfo createAdapterInfo(final Class<?>[] types, final ClassAndLoader definingClassAndLoader) {
         Class<?> superClass = null;
-        final List<Class<?>> interfaces = new ArrayList<>(types.length);
+        final List<Class<?>> interfaces = new ArrayList<Class<?>>(types.length);
         for(final Class<?> t: types) {
             final int mod = t.getModifiers();
             if(!t.isInterface()) {
@@ -1245,7 +1245,7 @@
      * @return a collection of maximum visibility class loaders. It is guaranteed to have at least one element.
      */
     private static Collection<ClassAndLoader> getMaximumVisibilityLoaders(final Class<?>[] types) {
-        final List<ClassAndLoader> maximumVisibilityLoaders = new LinkedList<>();
+        final List<ClassAndLoader> maximumVisibilityLoaders = new LinkedList<ClassAndLoader>();
         outer:  for(final ClassAndLoader maxCandidate: getClassLoadersForTypes(types)) {
             final Iterator<ClassAndLoader> it = maximumVisibilityLoaders.iterator();
             while(it.hasNext()) {
@@ -1276,7 +1276,7 @@
     }
 
     private static Collection<ClassAndLoader> getClassLoadersForTypes(final Class<?>[] types) {
-        final Map<ClassAndLoader, ClassAndLoader> classesAndLoaders = new LinkedHashMap<>();
+        final Map<ClassAndLoader, ClassAndLoader> classesAndLoaders = new LinkedHashMap<ClassAndLoader, ClassAndLoader>();
         for(final Class<?> c: types) {
             final ClassAndLoader cl = new ClassAndLoader(c, true);
             if(!classesAndLoaders.containsKey(cl)) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java
--- a/src/jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java	Thu Feb 07 13:40:05 2013 +0100
@@ -241,7 +241,7 @@
         return MH.findStatic(MethodHandles.lookup(), JavaArgumentConverters.class, name, MH.type(rtype, types));
     }
 
-    private static final Map<Class<?>, MethodHandle> CONVERTERS = new HashMap<>();
+    private static final Map<Class<?>, MethodHandle> CONVERTERS = new HashMap<Class<?>, MethodHandle>();
 
     static {
         CONVERTERS.put(Number.class, TO_NUMBER);
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/linker/LinkerCallSite.java
--- a/src/jdk/nashorn/internal/runtime/linker/LinkerCallSite.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/linker/LinkerCallSite.java	Thu Feb 07 13:40:05 2013 +0100
@@ -199,7 +199,7 @@
 
         public static ProfilingLinkerCallSite newProfilingLinkerCallSite(final NashornCallSiteDescriptor desc) {
             if (profileCallSites == null) {
-                profileCallSites = new LinkedList<>();
+                profileCallSites = new LinkedList<ProfilingLinkerCallSite>();
 
                 final Thread profileDumperThread = new Thread(new ProfileDumper());
                 Runtime.getRuntime().addShutdownHook(profileDumperThread);
@@ -495,7 +495,7 @@
 
     // counters updated in debug mode
     private static int count;
-    private static final HashMap<String, AtomicInteger> missCounts = new HashMap<>();
+    private static final HashMap<String, AtomicInteger> missCounts = new HashMap<String, AtomicInteger>();
     private static int missCount;
     private static final Random r = new Random();
     private static final int missSamplingPercentage = Options.getIntProperty("nashorn.tcs.miss.samplePercent", 1);
@@ -529,7 +529,7 @@
      * @param out print stream
      */
     public static void getMissCounts(final PrintWriter out) {
-        final ArrayList<Entry<String, AtomicInteger>> entries = new ArrayList<>(missCounts.entrySet());
+        final ArrayList<Entry<String, AtomicInteger>> entries = new ArrayList<Entry<String, AtomicInteger>>(missCounts.entrySet());
 
         Collections.sort(entries, new Comparator<Map.Entry<String, AtomicInteger>>() {
             @Override
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/linker/MethodHandleFactory.java
--- a/src/jdk/nashorn/internal/runtime/linker/MethodHandleFactory.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/linker/MethodHandleFactory.java	Thu Feb 07 13:40:05 2013 +0100
@@ -193,7 +193,7 @@
         }
 
         if (arg.getClass().isArray()) {
-            final List<Object> list = new ArrayList<>();
+            final List<Object> list = new ArrayList<Object>();
             for (final Object elem : (Object[])arg) {
                 list.add('\'' + argString(elem) + '\'');
             }
@@ -356,7 +356,9 @@
         public MethodHandle getter(final MethodHandles.Lookup explicitLookup, final Class<?> clazz, final String name, final Class<?> type) {
             try {
                 return explicitLookup.findGetter(clazz, name, type);
-            } catch (final NoSuchFieldException | IllegalAccessException e) {
+            } catch (final NoSuchFieldException e) {
+                throw new LookupException(e);
+            } catch (final IllegalAccessException e) {
                 throw new LookupException(e);
             }
         }
@@ -365,7 +367,9 @@
         public MethodHandle staticGetter(final MethodHandles.Lookup explicitLookup, final Class<?> clazz, final String name, final Class<?> type) {
             try {
                 return explicitLookup.findStaticGetter(clazz, name, type);
-            } catch (final NoSuchFieldException | IllegalAccessException e) {
+            } catch (final NoSuchFieldException e) {
+                throw new LookupException(e);
+            } catch (final IllegalAccessException e) {
                 throw new LookupException(e);
             }
         }
@@ -375,7 +379,9 @@
         public MethodHandle setter(final MethodHandles.Lookup explicitLookup, final Class<?> clazz, final String name, final Class<?> type) {
             try {
                 return explicitLookup.findSetter(clazz, name, type);
-            } catch (final NoSuchFieldException | IllegalAccessException e) {
+            } catch (final NoSuchFieldException e) {
+                throw new LookupException(e);
+            } catch (final IllegalAccessException e) {
                 throw new LookupException(e);
             }
         }
@@ -384,7 +390,9 @@
         public MethodHandle staticSetter(final MethodHandles.Lookup explicitLookup, final Class<?> clazz, final String name, final Class<?> type) {
             try {
                 return explicitLookup.findStaticSetter(clazz, name, type);
-            } catch (final NoSuchFieldException | IllegalAccessException e) {
+            } catch (final NoSuchFieldException e) {
+                throw new LookupException(e);
+            } catch (final IllegalAccessException e) {
                 throw new LookupException(e);
             }
         }
@@ -402,7 +410,9 @@
         public MethodHandle findStatic(final MethodHandles.Lookup explicitLookup, final Class<?> clazz, final String name, final MethodType type) {
             try {
                 return explicitLookup.findStatic(clazz, name, type);
-            } catch (final NoSuchMethodException | IllegalAccessException e) {
+            } catch (final NoSuchMethodException e) {
+                throw new LookupException(e);
+            } catch (final IllegalAccessException e) {
                 throw new LookupException(e);
             }
         }
@@ -411,7 +421,9 @@
         public MethodHandle findVirtual(final MethodHandles.Lookup explicitLookup, final Class<?> clazz, final String name, final MethodType type) {
             try {
                 return explicitLookup.findVirtual(clazz, name, type);
-            } catch (final NoSuchMethodException | IllegalAccessException e) {
+            } catch (final NoSuchMethodException e) {
+                throw new LookupException(e);
+            } catch (final IllegalAccessException e) {
                 throw new LookupException(e);
             }
         }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/linker/NashornBottomLinker.java
--- a/src/jdk/nashorn/internal/runtime/linker/NashornBottomLinker.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/linker/NashornBottomLinker.java	Thu Feb 07 13:40:05 2013 +0100
@@ -76,39 +76,30 @@
         final NashornCallSiteDescriptor desc = (NashornCallSiteDescriptor)linkRequest.getCallSiteDescriptor();
         final Object self = linkRequest.getReceiver();
         final String operator = desc.getFirstOperator();
-        switch (operator) {
-        case "new":
+        if ("new".equals(operator)) {
             if(isJavaDynamicMethod(self)) {
                 typeError("method.not.constructor", ScriptRuntime.safeToString(self));
             } else {
                 typeError("not.a.function", ScriptRuntime.safeToString(self));
             }
-            break;
-        case "call":
+        } else if ("call".equals(operator)) {
             if(isJavaDynamicMethod(self)) {
                 typeError("no.method.matches.args", ScriptRuntime.safeToString(self));
             } else {
                 typeError("not.a.function", ScriptRuntime.safeToString(self));
             }
-            break;
-        case "callMethod":
-        case "getMethod":
+        } else if ("callMethod".equals(operator) || "getMethod".equals(operator)) {
             typeError("no.such.function", getArgument(linkRequest), ScriptRuntime.safeToString(self));
-            break;
-        case "getProp":
-        case "getElem":
+        } else if ("getProp".equals(operator) || "getElem".equals(operator)) {
             if (desc.getOperand() != null) {
                 return getInvocation(EMPTY_PROP_GETTER, self, linkerServices, desc);
             }
             return getInvocation(EMPTY_ELEM_GETTER, self, linkerServices, desc);
-        case "setProp":
-        case "setElem":
+        } else if ("setProp".equals(operator) || "setElem".equals(operator)) {
             if (desc.getOperand() != null) {
                 return getInvocation(EMPTY_PROP_SETTER, self, linkerServices, desc);
             }
             return getInvocation(EMPTY_ELEM_SETTER, self, linkerServices, desc);
-        default:
-            break;
         }
         throw new AssertionError("unknown call type " + desc);
     }
@@ -136,25 +127,14 @@
     private static GuardedInvocation linkNull(final LinkRequest linkRequest) {
         final NashornCallSiteDescriptor desc = (NashornCallSiteDescriptor)linkRequest.getCallSiteDescriptor();
         final String operator = desc.getFirstOperator();
-        switch (operator) {
-        case "new":
-        case "call":
+        if ("new".equals(operator) || "call".equals(operator)) {
             typeError("not.a.function", "null");
-            break;
-        case "callMethod":
-        case "getMethod":
+        } else if ("callMethod".equals(operator) || "getMethod".equals(operator)) {
             typeError("no.such.function", getArgument(linkRequest), "null");
-            break;
-        case "getProp":
-        case "getElem":
+        } else if ("getProp".equals(operator) || "getElem".equals(operator)) {
             typeError("cant.get.property", getArgument(linkRequest), "null");
-            break;
-        case "setProp":
-        case "setElem":
+        } else if ("setProp".equals(operator) || "setElem".equals(operator)) {
             typeError("cant.set.property", getArgument(linkRequest), "null");
-            break;
-        default:
-            break;
         }
         throw new AssertionError("unknown call type " + desc);
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/linker/NashornCallSiteDescriptor.java
--- a/src/jdk/nashorn/internal/runtime/linker/NashornCallSiteDescriptor.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/linker/NashornCallSiteDescriptor.java	Thu Feb 07 13:40:05 2013 +0100
@@ -74,7 +74,7 @@
     public static final int CALLSITE_TRACE_SCOPE      = 0x200;
 
     private static final WeakHashMap<NashornCallSiteDescriptor, WeakReference<NashornCallSiteDescriptor>> canonicals =
-            new WeakHashMap<>();
+            new WeakHashMap<NashornCallSiteDescriptor, WeakReference<NashornCallSiteDescriptor>>();
 
     private final String operator;
     private final String operand;
@@ -111,7 +111,7 @@
                     return canonical;
                 }
             }
-            canonicals.put(csd, new WeakReference<>(csd));
+            canonicals.put(csd, new WeakReference<NashornCallSiteDescriptor>(csd));
         }
         return csd;
     }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/options/KeyValueOption.java
--- a/src/jdk/nashorn/internal/runtime/options/KeyValueOption.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/options/KeyValueOption.java	Thu Feb 07 13:40:05 2013 +0100
@@ -74,7 +74,7 @@
             return;
         }
 
-        map = new LinkedHashMap<>();
+        map = new LinkedHashMap<String, String>();
 
         final StringTokenizer st = new StringTokenizer(getValue(), ",");
         while (st.hasMoreElements()) {
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/options/OptionTemplate.java
--- a/src/jdk/nashorn/internal/runtime/options/OptionTemplate.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/options/OptionTemplate.java	Thu Feb 07 13:40:05 2013 +0100
@@ -137,22 +137,17 @@
      * @return the default value as a string
      */
     public String getDefaultValue() {
-        switch (getType()) {
-        case "boolean":
+        String localType = getType();
+        if ("boolean".equals(localType)) {
             if (this.defaultValue == null) {
                 this.defaultValue = "false";
             }
-            break;
-        case "integer":
+        } else if ("integer".equals(localType)) {
             if (this.defaultValue == null) {
                 this.defaultValue = "0";
             }
-            break;
-        case "timezone":
+        } else if ("timezone".equals(localType)) {
             this.defaultValue = TimeZone.getDefault().getID();
-            break;
-        default:
-            break;
         }
         return this.defaultValue;
     }
@@ -240,44 +235,33 @@
                 final String                keyToken = st.nextToken();
                 final String                arg      = st.nextToken();
 
-                switch (keyToken) {
-                case "is_undocumented":
+                if ("is_undocumented".equals(keyToken)) {
                     this.isUndocumented = Boolean.parseBoolean(arg);
-                    break;
-                case "name":
+                } else if ("name".equals(keyToken)) {
                     if (!arg.startsWith("-")) {
                         throw new IllegalArgumentException(arg);
                     }
                     this.name = arg;
-                    break;
-                case "short_name":
+                } else if ("short_name".equals(keyToken)) {
                     if (!arg.startsWith("-")) {
                         throw new IllegalArgumentException(arg);
                     }
                     this.shortName = arg;
-                    break;
-                case "desc":
+                } else if ("desc".equals(keyToken)) {
                     this.description = arg;
-                    break;
-                case "params":
+                } else if ("params".equals(keyToken)) {
                     this.params = arg;
-                    break;
-                case "type":
+                } else if ("type".equals(keyToken)) {
                     this.type = arg.toLowerCase();
-                    break;
-                case "default":
+                } else if ("default".equals(keyToken)) {
                     this.defaultValue = arg;
-                    break;
-                case "dependency":
+                } else if ("dependency".equals(keyToken)) {
                     this.dependency = arg;
-                    break;
-                case "conflict":
+                } else if ("conflict".equals(keyToken)) {
                     this.conflict = arg;
-                    break;
-                case "value_next_arg":
+                } else if ("value_next_arg".equals(keyToken)) {
                     this.valueNextArg = Boolean.parseBoolean(arg);
-                    break;
-                default:
+                } else {
                     throw new IllegalArgumentException();
                 }
             }
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/options/Options.java
--- a/src/jdk/nashorn/internal/runtime/options/Options.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/options/Options.java	Thu Feb 07 13:40:05 2013 +0100
@@ -87,9 +87,9 @@
     public Options(final String resource, final PrintWriter err) {
         this.resource  = resource;
         this.err       = err;
-        this.files     = new ArrayList<>();
-        this.arguments = new ArrayList<>();
-        this.options   = new TreeMap<>();
+        this.files     = new ArrayList<String>();
+        this.arguments = new ArrayList<String>();
+        this.options   = new TreeMap<String, Option<?>>();
 
         // set all default values
         for (final OptionTemplate t : Options.validOptions) {
@@ -261,7 +261,7 @@
      * @param option option
      */
     public void set(final String key, final boolean option) {
-        set(key, new Option<>(option));
+        set(key, new Option<Boolean>(option));
     }
 
     /**
@@ -271,7 +271,7 @@
      * @param option option
      */
     public void set(final String key, final String option) {
-        set(key, new Option<>(option));
+        set(key, new Option<String>(option));
     }
 
     /**
@@ -384,7 +384,7 @@
      * @param args arguments from command line
      */
     public void process(final String[] args) {
-        final LinkedList<String> argList = new LinkedList<>();
+        final LinkedList<String> argList = new LinkedList<String>();
         Collections.addAll(argList, args);
 
         while (!argList.isEmpty()) {
@@ -476,37 +476,36 @@
     }
 
     private static Option<?> createOption(final OptionTemplate t, final String value) {
-        switch (t.getType()) {
-        case "string":
+        String type = t.getType();
+        if ("string".equals(type)) {
             // default value null
-            return new Option<>(value);
-        case "timezone":
+            return new Option<String>(value);
+        } else if ("timezone".equals(type)) {
             // default value "TimeZone.getDefault()"
-            return new Option<>(TimeZone.getTimeZone(value));
-        case "keyvalues":
+            return new Option<TimeZone>(TimeZone.getTimeZone(value));
+        } else if ("keyvalues".equals(type)) {
             return new KeyValueOption(value);
-        case "values":
+        } else if ("values".equals(type)) {
             return new ValueOption(value);
-        case "log":
+        } else if ("log".equals(type)) {
             final KeyValueOption kv = new KeyValueOption(value);
             Logging.initialize(kv.getValues());
             return kv;
-        case "boolean":
-            return new Option<>(value != null && Boolean.parseBoolean(value));
-        case "integer":
+        } else if ("boolean".equals(type)) {
+            return new Option<Boolean>(value != null && Boolean.parseBoolean(value));
+        } else if ("integer".equals(type)) {
             try {
-                return new Option<>((value == null) ? 0 : Integer.parseInt(value));
+                return new Option<Integer>((value == null) ? 0 : Integer.parseInt(value));
             } catch (final NumberFormatException nfe) {
                 throw new IllegalOptionException(t);
             }
-        case "properties":
+        } else if ("properties".equals(type)) {
             //swallow the properties and set them
             initProps(new KeyValueOption(value));
             return null;
-        default:
-            break;
+        } else {
+            throw new IllegalArgumentException(value);
         }
-        throw new IllegalArgumentException(value);
     }
 
     private static void initProps(final KeyValueOption kv) {
@@ -560,8 +559,8 @@
             }
         });
 
-        Options.validOptions = new TreeSet<>();
-        Options.usage        = new HashMap<>();
+        Options.validOptions = new TreeSet<OptionTemplate>();
+        Options.usage        = new HashMap<Object, Object>();
 
         for (final Enumeration<String> keys = Options.bundle.getKeys(); keys.hasMoreElements(); ) {
             final String key = keys.nextElement();
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/internal/runtime/options/ValueOption.java
--- a/src/jdk/nashorn/internal/runtime/options/ValueOption.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/internal/runtime/options/ValueOption.java	Thu Feb 07 13:40:05 2013 +0100
@@ -40,7 +40,7 @@
     ValueOption(final String value) {
         super(value);
         if (value != null) {
-            values = new LinkedHashSet<>();
+            values = new LinkedHashSet<String>();
             final StringTokenizer st = new StringTokenizer(getValue(), ",");
             while (st.hasMoreElements()) {
                 values.add(st.nextToken());
diff -r 02f810c26ff9 -r 716d47361960 src/jdk/nashorn/tools/Shell.java
--- a/src/jdk/nashorn/tools/Shell.java	Wed Feb 06 12:51:09 2013 -0400
+++ b/src/jdk/nashorn/tools/Shell.java	Thu Feb 07 13:40:05 2013 +0100
@@ -203,12 +203,17 @@
             for (final String fileName : options.getFiles()) {
                 final File firstFile = new File(fileName);
                 if (firstFile.isFile()) {
-                    try (final FileReader fr = new FileReader(firstFile)) {
-                        final int firstChar = fr.read();
-                        // starts with '#
-                        if (firstChar == '#') {
-                            options.set("scripting", true);
-                            break;
+                    try {
+                        final FileReader fr = new FileReader(firstFile);
+                        try {
+                            final int firstChar = fr.read();
+                            // starts with '#
+                            if (firstChar == '#') {
+                                options.set("scripting", true);
+                                break;
+                            }
+                        } finally {
+                            fr.close();
                         }
                     } catch (final IOException e) {
                         // ignore this. File IO errors will be reported later anyway
diff -r 02f810c26ff9 -r 716d47361960 stubs/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/build.xml	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,74 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- You may freely edit this file. See commented blocks below for -->
+<!-- some examples of how to customize the build. -->
+<!-- (If you delete it and reopen the project it will be recreated.) -->
+<!-- By default, only the Clean and Build commands use this build script. -->
+<!-- Commands such as Run, Debug, and Test only use this build script if -->
+<!-- the Compile on Save feature is turned off for the project. -->
+<!-- You can turn off the Compile on Save (or Deploy on Save) setting -->
+<!-- in the project's Project Properties dialog box.-->
+<project name="stubs" default="default" basedir=".">
+    <description>Builds, tests, and runs the project stubs.</description>
+    <import file="nbproject/build-impl.xml"/>
+    <!--
+
+    There exist several targets which are by default empty and which can be 
+    used for execution of your tasks. These targets are usually executed 
+    before and after some main targets. They are: 
+
+      -pre-init:                 called before initialization of project properties
+      -post-init:                called after initialization of project properties
+      -pre-compile:              called before javac compilation
+      -post-compile:             called after javac compilation
+      -pre-compile-single:       called before javac compilation of single file
+      -post-compile-single:      called after javac compilation of single file
+      -pre-compile-test:         called before javac compilation of JUnit tests
+      -post-compile-test:        called after javac compilation of JUnit tests
+      -pre-compile-test-single:  called before javac compilation of single JUnit test
+      -post-compile-test-single: called after javac compilation of single JUunit test
+      -pre-jar:                  called before JAR building
+      -post-jar:                 called after JAR building
+      -post-clean:               called after cleaning build products
+
+    (Targets beginning with '-' are not intended to be called on their own.)
+
+    Example of inserting an obfuscator after compilation could look like this:
+
+        <target name="-post-compile">
+            <obfuscate>
+                <fileset dir="${build.classes.dir}"/>
+            </obfuscate>
+        </target>
+
+    For list of available properties check the imported 
+    nbproject/build-impl.xml file. 
+
+
+    Another way to customize the build is by overriding existing main targets.
+    The targets of interest are: 
+
+      -init-macrodef-javac:     defines macro for javac compilation
+      -init-macrodef-junit:     defines macro for junit execution
+      -init-macrodef-debug:     defines macro for class debugging
+      -init-macrodef-java:      defines macro for class execution
+      -do-jar-with-manifest:    JAR building (if you are using a manifest)
+      -do-jar-without-manifest: JAR building (if you are not using a manifest)
+      run:                      execution of project 
+      -javadoc-build:           Javadoc generation
+      test-report:              JUnit report generation
+
+    An example of overriding the target for project execution could look like this:
+
+        <target name="run" depends="stubs-impl.jar">
+            <exec dir="bin" executable="launcher.exe">
+                <arg file="${dist.jar}"/>
+            </exec>
+        </target>
+
+    Notice that the overridden target depends on the jar target and not only on 
+    the compile target as the regular run target does. Again, for a list of available 
+    properties which you can use, check the target you are overriding in the
+    nbproject/build-impl.xml file. 
+
+    -->
+</project>
diff -r 02f810c26ff9 -r 716d47361960 stubs/nbproject/build-impl.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/nbproject/build-impl.xml	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,1086 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+*** GENERATED FROM project.xml - DO NOT EDIT  ***
+***         EDIT ../build.xml INSTEAD         ***
+
+For the purpose of easier reading the script
+is divided into following sections:
+
+  - initialization
+  - compilation
+  - jar
+  - execution
+  - debugging
+  - javadoc
+  - junit compilation
+  - junit execution
+  - junit debugging
+  - applet
+  - cleanup
+
+        -->
+<project xmlns:j2seproject1="http://www.netbeans.org/ns/j2se-project/1" xmlns:j2seproject3="http://www.netbeans.org/ns/j2se-project/3" xmlns:jaxrpc="http://www.netbeans.org/ns/j2se-project/jax-rpc" basedir=".." default="default" name="stubs-impl">
+    <fail message="Please build using Ant 1.8.0 or higher.">
+        <condition>
+            <not>
+                <antversion atleast="1.8.0"/>
+            </not>
+        </condition>
+    </fail>
+    <target depends="test,jar,javadoc" description="Build and test whole project." name="default"/>
+    <!-- 
+                ======================
+                INITIALIZATION SECTION 
+                ======================
+            -->
+    <target name="-pre-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init" name="-init-private">
+        <property file="nbproject/private/config.properties"/>
+        <property file="nbproject/private/configs/${config}.properties"/>
+        <property file="nbproject/private/private.properties"/>
+    </target>
+    <target depends="-pre-init,-init-private" name="-init-user">
+        <property file="${user.properties.file}"/>
+        <!-- The two properties below are usually overridden -->
+        <!-- by the active platform. Just a fallback. -->
+        <property name="default.javac.source" value="1.4"/>
+        <property name="default.javac.target" value="1.4"/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user" name="-init-project">
+        <property file="nbproject/configs/${config}.properties"/>
+        <property file="nbproject/project.properties"/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-init-macrodef-property" name="-do-init">
+        <j2seproject1:property name="platform.home" value="platforms.${platform.active}.home"/>
+        <j2seproject1:property name="platform.bootcp" value="platforms.${platform.active}.bootclasspath"/>
+        <j2seproject1:property name="platform.compiler" value="platforms.${platform.active}.compile"/>
+        <j2seproject1:property name="platform.javac.tmp" value="platforms.${platform.active}.javac"/>
+        <condition property="platform.javac" value="${platform.home}/bin/javac">
+            <equals arg1="${platform.javac.tmp}" arg2="$${platforms.${platform.active}.javac}"/>
+        </condition>
+        <property name="platform.javac" value="${platform.javac.tmp}"/>
+        <j2seproject1:property name="platform.java.tmp" value="platforms.${platform.active}.java"/>
+        <condition property="platform.java" value="${platform.home}/bin/java">
+            <equals arg1="${platform.java.tmp}" arg2="$${platforms.${platform.active}.java}"/>
+        </condition>
+        <property name="platform.java" value="${platform.java.tmp}"/>
+        <j2seproject1:property name="platform.javadoc.tmp" value="platforms.${platform.active}.javadoc"/>
+        <condition property="platform.javadoc" value="${platform.home}/bin/javadoc">
+            <equals arg1="${platform.javadoc.tmp}" arg2="$${platforms.${platform.active}.javadoc}"/>
+        </condition>
+        <property name="platform.javadoc" value="${platform.javadoc.tmp}"/>
+        <condition property="platform.invalid" value="true">
+            <or>
+                <contains string="${platform.javac}" substring="$${platforms."/>
+                <contains string="${platform.java}" substring="$${platforms."/>
+                <contains string="${platform.javadoc}" substring="$${platforms."/>
+            </or>
+        </condition>
+        <fail unless="platform.home">Must set platform.home</fail>
+        <fail unless="platform.bootcp">Must set platform.bootcp</fail>
+        <fail unless="platform.java">Must set platform.java</fail>
+        <fail unless="platform.javac">Must set platform.javac</fail>
+        <fail if="platform.invalid">
+ The J2SE Platform is not correctly set up.
+ Your active platform is: ${platform.active}, but the corresponding property "platforms.${platform.active}.home" is not found in the project's properties files. 
+ Either open the project in the IDE and setup the Platform with the same name or add it manually.
+ For example like this:
+     ant -Duser.properties.file=&lt;path_to_property_file&gt; jar (where you put the property "platforms.${platform.active}.home" in a .properties file)
+  or ant -Dplatforms.${platform.active}.home=&lt;path_to_JDK_home&gt; jar (where no properties file is used) 
+  </fail>
+        <available file="${manifest.file}" property="manifest.available"/>
+        <condition property="splashscreen.available">
+            <and>
+                <not>
+                    <equals arg1="${application.splash}" arg2="" trim="true"/>
+                </not>
+                <available file="${application.splash}"/>
+            </and>
+        </condition>
+        <condition property="main.class.available">
+            <and>
+                <isset property="main.class"/>
+                <not>
+                    <equals arg1="${main.class}" arg2="" trim="true"/>
+                </not>
+            </and>
+        </condition>
+        <condition property="manifest.available+main.class">
+            <and>
+                <isset property="manifest.available"/>
+                <isset property="main.class.available"/>
+            </and>
+        </condition>
+        <condition property="do.archive">
+            <not>
+                <istrue value="${jar.archive.disabled}"/>
+            </not>
+        </condition>
+        <condition property="do.mkdist">
+            <and>
+                <isset property="do.archive"/>
+                <isset property="libs.CopyLibs.classpath"/>
+                <not>
+                    <istrue value="${mkdist.disabled}"/>
+                </not>
+            </and>
+        </condition>
+        <condition property="manifest.available+main.class+mkdist.available">
+            <and>
+                <istrue value="${manifest.available+main.class}"/>
+                <isset property="do.mkdist"/>
+            </and>
+        </condition>
+        <condition property="do.archive+manifest.available">
+            <and>
+                <isset property="manifest.available"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="do.archive+main.class.available">
+            <and>
+                <isset property="main.class.available"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="do.archive+splashscreen.available">
+            <and>
+                <isset property="splashscreen.available"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="do.archive+manifest.available+main.class">
+            <and>
+                <istrue value="${manifest.available+main.class}"/>
+                <istrue value="${do.archive}"/>
+            </and>
+        </condition>
+        <condition property="manifest.available-mkdist.available">
+            <or>
+                <istrue value="${manifest.available}"/>
+                <isset property="do.mkdist"/>
+            </or>
+        </condition>
+        <condition property="manifest.available+main.class-mkdist.available">
+            <or>
+                <istrue value="${manifest.available+main.class}"/>
+                <isset property="do.mkdist"/>
+            </or>
+        </condition>
+        <condition property="have.tests">
+            <or>
+                <available file="${test.src.dir}"/>
+            </or>
+        </condition>
+        <condition property="have.sources">
+            <or>
+                <available file="${src.dir}"/>
+            </or>
+        </condition>
+        <condition property="netbeans.home+have.tests">
+            <and>
+                <isset property="netbeans.home"/>
+                <isset property="have.tests"/>
+            </and>
+        </condition>
+        <condition property="no.javadoc.preview">
+            <and>
+                <isset property="javadoc.preview"/>
+                <isfalse value="${javadoc.preview}"/>
+            </and>
+        </condition>
+        <property name="run.jvmargs" value=""/>
+        <property name="javac.compilerargs" value=""/>
+        <property name="work.dir" value="${basedir}"/>
+        <condition property="no.deps">
+            <and>
+                <istrue value="${no.dependencies}"/>
+            </and>
+        </condition>
+        <property name="javac.debug" value="true"/>
+        <property name="javadoc.preview" value="true"/>
+        <property name="application.args" value=""/>
+        <property name="source.encoding" value="${file.encoding}"/>
+        <property name="runtime.encoding" value="${source.encoding}"/>
+        <condition property="javadoc.encoding.used" value="${javadoc.encoding}">
+            <and>
+                <isset property="javadoc.encoding"/>
+                <not>
+                    <equals arg1="${javadoc.encoding}" arg2=""/>
+                </not>
+            </and>
+        </condition>
+        <property name="javadoc.encoding.used" value="${source.encoding}"/>
+        <property name="includes" value="**"/>
+        <property name="excludes" value=""/>
+        <property name="do.depend" value="false"/>
+        <condition property="do.depend.true">
+            <istrue value="${do.depend}"/>
+        </condition>
+        <path id="endorsed.classpath.path" path="${endorsed.classpath}"/>
+        <condition else="" property="endorsed.classpath.cmd.line.arg" value="-Xbootclasspath/p:'${toString:endorsed.classpath.path}'">
+            <length length="0" string="${endorsed.classpath}" when="greater"/>
+        </condition>
+        <property name="jar.index" value="false"/>
+        <property name="jar.index.metainf" value="${jar.index}"/>
+        <property name="copylibs.rebase" value="true"/>
+        <available file="${meta.inf.dir}/persistence.xml" property="has.persistence.xml"/>
+    </target>
+    <target name="-post-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init" name="-init-check">
+        <fail unless="src.dir">Must set src.dir</fail>
+        <fail unless="test.src.dir">Must set test.src.dir</fail>
+        <fail unless="build.dir">Must set build.dir</fail>
+        <fail unless="dist.dir">Must set dist.dir</fail>
+        <fail unless="build.classes.dir">Must set build.classes.dir</fail>
+        <fail unless="dist.javadoc.dir">Must set dist.javadoc.dir</fail>
+        <fail unless="build.test.classes.dir">Must set build.test.classes.dir</fail>
+        <fail unless="build.test.results.dir">Must set build.test.results.dir</fail>
+        <fail unless="build.classes.excludes">Must set build.classes.excludes</fail>
+        <fail unless="dist.jar">Must set dist.jar</fail>
+    </target>
+    <target name="-init-macrodef-property">
+        <macrodef name="property" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute name="name"/>
+            <attribute name="value"/>
+            <sequential>
+                <property name="@{name}" value="${@{value}}"/>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-ap-cmdline-properties" if="ap.supported.internal" name="-init-macrodef-javac-with-processors">
+        <macrodef name="javac" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <attribute default="${javac.processorpath}" name="processorpath"/>
+            <attribute default="${build.generated.sources.dir}/ap-source-output" name="apgeneratedsrcdir"/>
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="${javac.debug}" name="debug"/>
+            <attribute default="${empty.dir}" name="sourcepath"/>
+            <attribute default="${empty.dir}" name="gensrcdir"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property location="${build.dir}/empty" name="empty.dir"/>
+                <mkdir dir="${empty.dir}"/>
+                <mkdir dir="@{apgeneratedsrcdir}"/>
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" executable="${platform.javac}" fork="yes" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                    <src>
+                        <dirset dir="@{gensrcdir}" erroronmissingdir="false">
+                            <include name="*"/>
+                        </dirset>
+                    </src>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <compilerarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <compilerarg line="${javac.compilerargs}"/>
+                    <compilerarg value="-processorpath"/>
+                    <compilerarg path="@{processorpath}:${empty.dir}"/>
+                    <compilerarg line="${ap.processors.internal}"/>
+                    <compilerarg line="${annotation.processing.processor.options}"/>
+                    <compilerarg value="-s"/>
+                    <compilerarg path="@{apgeneratedsrcdir}"/>
+                    <compilerarg line="${ap.proc.none.internal}"/>
+                    <customize/>
+                </javac>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-ap-cmdline-properties" name="-init-macrodef-javac-without-processors" unless="ap.supported.internal">
+        <macrodef name="javac" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <attribute default="${javac.processorpath}" name="processorpath"/>
+            <attribute default="${build.generated.sources.dir}/ap-source-output" name="apgeneratedsrcdir"/>
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="${javac.debug}" name="debug"/>
+            <attribute default="${empty.dir}" name="sourcepath"/>
+            <attribute default="${empty.dir}" name="gensrcdir"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property location="${build.dir}/empty" name="empty.dir"/>
+                <mkdir dir="${empty.dir}"/>
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" executable="${platform.javac}" fork="yes" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                    <src>
+                        <dirset dir="@{gensrcdir}" erroronmissingdir="false">
+                            <include name="*"/>
+                        </dirset>
+                    </src>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <compilerarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <compilerarg line="${javac.compilerargs}"/>
+                    <customize/>
+                </javac>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-macrodef-javac-with-processors,-init-macrodef-javac-without-processors" name="-init-macrodef-javac">
+        <macrodef name="depend" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <sequential>
+                <depend cache="${build.dir}/depcache" destdir="@{destdir}" excludes="${excludes}" includes="${includes}" srcdir="@{srcdir}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                </depend>
+            </sequential>
+        </macrodef>
+        <macrodef name="force-recompile" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <sequential>
+                <fail unless="javac.includes">Must set javac.includes</fail>
+                <pathconvert pathsep="${line.separator}" property="javac.includes.binary">
+                    <path>
+                        <filelist dir="@{destdir}" files="${javac.includes}"/>
+                    </path>
+                    <globmapper from="*.java" to="*.class"/>
+                </pathconvert>
+                <tempfile deleteonexit="true" property="javac.includesfile.binary"/>
+                <echo file="${javac.includesfile.binary}" message="${javac.includes.binary}"/>
+                <delete>
+                    <files includesfile="${javac.includesfile.binary}"/>
+                </delete>
+                <delete>
+                    <fileset file="${javac.includesfile.binary}"/>
+                </delete>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-junit">
+        <macrodef name="junit" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <sequential>
+                <property name="junit.forkmode" value="perTest"/>
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" forkmode="${junit.forkmode}" jvm="${platform.java}" showoutput="true" tempdir="${build.dir}">
+                    <batchtest todir="${build.test.results.dir}">
+                        <fileset dir="${test.src.dir}" excludes="@{excludes},${excludes}" includes="@{includes}">
+                            <filename name="@{testincludes}"/>
+                        </fileset>
+                    </batchtest>
+                    <classpath>
+                        <path path="${run.test.classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="test-sys-prop."/>
+                        <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <formatter type="brief" usefile="false"/>
+                    <formatter type="xml"/>
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg value="-ea"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                </junit>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-profile-pre-init, init, -profile-post-init, -profile-init-macrodef-profile, -profile-init-check" name="profile-init"/>
+    <target name="-profile-pre-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target name="-profile-post-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target name="-profile-init-macrodef-profile">
+        <macrodef name="resolve">
+            <attribute name="name"/>
+            <attribute name="value"/>
+            <sequential>
+                <property name="@{name}" value="${env.@{value}}"/>
+            </sequential>
+        </macrodef>
+        <macrodef name="profile">
+            <attribute default="${main.class}" name="classname"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property environment="env"/>
+                <resolve name="profiler.current.path" value="${profiler.info.pathvar}"/>
+                <java classname="@{classname}" dir="${profiler.info.dir}" fork="true" jvm="${profiler.info.jvm}">
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg value="${profiler.info.jvmargs.agent}"/>
+                    <jvmarg line="${profiler.info.jvmargs}"/>
+                    <env key="${profiler.info.pathvar}" path="${profiler.info.agentpath}:${profiler.current.path}"/>
+                    <arg line="${application.args}"/>
+                    <classpath>
+                        <path path="${run.classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-profile-pre-init, init, -profile-post-init, -profile-init-macrodef-profile" name="-profile-init-check">
+        <fail unless="profiler.info.jvm">Must set JVM to use for profiling in profiler.info.jvm</fail>
+        <fail unless="profiler.info.jvmargs.agent">Must set profiler agent JVM arguments in profiler.info.jvmargs.agent</fail>
+    </target>
+    <target depends="-init-debug-args" name="-init-macrodef-nbjpda">
+        <macrodef name="nbjpdastart" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${main.class}" name="name"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <attribute default="" name="stopclassname"/>
+            <sequential>
+                <nbjpdastart addressproperty="jpda.address" name="@{name}" stopclassname="@{stopclassname}" transport="${debug-transport}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <bootclasspath>
+                        <path path="${platform.bootcp}"/>
+                    </bootclasspath>
+                </nbjpdastart>
+            </sequential>
+        </macrodef>
+        <macrodef name="nbjpdareload" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${build.classes.dir}" name="dir"/>
+            <sequential>
+                <nbjpdareload>
+                    <fileset dir="@{dir}" includes="${fix.classes}">
+                        <include name="${fix.includes}*.class"/>
+                    </fileset>
+                </nbjpdareload>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-debug-args">
+        <exec executable="${platform.java}" outputproperty="version-output">
+            <arg value="-version"/>
+        </exec>
+        <condition property="have-jdk-older-than-1.4">
+            <or>
+                <contains string="${version-output}" substring="java version &quot;1.0"/>
+                <contains string="${version-output}" substring="java version &quot;1.1"/>
+                <contains string="${version-output}" substring="java version &quot;1.2"/>
+                <contains string="${version-output}" substring="java version &quot;1.3"/>
+            </or>
+        </condition>
+        <condition else="-Xdebug" property="debug-args-line" value="-Xdebug -Xnoagent -Djava.compiler=none">
+            <istrue value="${have-jdk-older-than-1.4}"/>
+        </condition>
+        <condition else="dt_socket" property="debug-transport-by-os" value="dt_shmem">
+            <os family="windows"/>
+        </condition>
+        <condition else="${debug-transport-by-os}" property="debug-transport" value="${debug.transport}">
+            <isset property="debug.transport"/>
+        </condition>
+    </target>
+    <target depends="-init-debug-args" name="-init-macrodef-debug">
+        <macrodef name="debug" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" fork="true" jvm="${platform.java}">
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg line="${debug-args-line}"/>
+                    <jvmarg value="-Xrunjdwp:transport=${debug-transport},address=${jpda.address}"/>
+                    <jvmarg value="-Dfile.encoding=${runtime.encoding}"/>
+                    <redirector errorencoding="${runtime.encoding}" inputencoding="${runtime.encoding}" outputencoding="${runtime.encoding}"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-java">
+        <macrodef name="java" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="${run.classpath}" name="classpath"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" fork="true" jvm="${platform.java}">
+                    <jvmarg line="${endorsed.classpath.cmd.line.arg}"/>
+                    <jvmarg value="-Dfile.encoding=${runtime.encoding}"/>
+                    <redirector errorencoding="${runtime.encoding}" inputencoding="${runtime.encoding}" outputencoding="${runtime.encoding}"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-copylibs">
+        <macrodef name="copylibs" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${manifest.file}" name="manifest"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+                <pathconvert property="run.classpath.without.build.classes.dir">
+                    <path path="${run.classpath}"/>
+                    <map from="${build.classes.dir.resolved}" to=""/>
+                </pathconvert>
+                <pathconvert pathsep=" " property="jar.classpath">
+                    <path path="${run.classpath.without.build.classes.dir}"/>
+                    <chainedmapper>
+                        <flattenmapper/>
+                        <globmapper from="*" to="lib/*"/>
+                    </chainedmapper>
+                </pathconvert>
+                <taskdef classname="org.netbeans.modules.java.j2seproject.copylibstask.CopyLibs" classpath="${libs.CopyLibs.classpath}" name="copylibs"/>
+                <copylibs compress="${jar.compress}" index="${jar.index}" indexMetaInf="${jar.index.metainf}" jarfile="${dist.jar}" manifest="@{manifest}" rebase="${copylibs.rebase}" runtimeclasspath="${run.classpath.without.build.classes.dir}">
+                    <fileset dir="${build.classes.dir}"/>
+                    <manifest>
+                        <attribute name="Class-Path" value="${jar.classpath}"/>
+                        <customize/>
+                    </manifest>
+                </copylibs>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-presetdef-jar">
+        <presetdef name="jar" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <jar compress="${jar.compress}" index="${jar.index}" jarfile="${dist.jar}">
+                <j2seproject1:fileset dir="${build.classes.dir}"/>
+            </jar>
+        </presetdef>
+    </target>
+    <target name="-init-ap-cmdline-properties">
+        <property name="annotation.processing.enabled" value="true"/>
+        <property name="annotation.processing.processors.list" value=""/>
+        <property name="annotation.processing.processor.options" value=""/>
+        <property name="annotation.processing.run.all.processors" value="true"/>
+        <property name="javac.processorpath" value="${javac.classpath}"/>
+        <property name="javac.test.processorpath" value="${javac.test.classpath}"/>
+        <condition property="ap.supported.internal" value="true">
+            <not>
+                <matches pattern="1\.[0-5](\..*)?" string="${javac.source}"/>
+            </not>
+        </condition>
+    </target>
+    <target depends="-init-ap-cmdline-properties" if="ap.supported.internal" name="-init-ap-cmdline-supported">
+        <condition else="" property="ap.processors.internal" value="-processor ${annotation.processing.processors.list}">
+            <isfalse value="${annotation.processing.run.all.processors}"/>
+        </condition>
+        <condition else="" property="ap.proc.none.internal" value="-proc:none">
+            <isfalse value="${annotation.processing.enabled}"/>
+        </condition>
+    </target>
+    <target depends="-init-ap-cmdline-properties,-init-ap-cmdline-supported" name="-init-ap-cmdline">
+        <property name="ap.cmd.line.internal" value=""/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init,-post-init,-init-check,-init-macrodef-property,-init-macrodef-javac,-init-macrodef-junit,-init-macrodef-nbjpda,-init-macrodef-debug,-init-macrodef-java,-init-presetdef-jar,-init-ap-cmdline" name="init"/>
+    <!--
+                ===================
+                COMPILATION SECTION
+                ===================
+            -->
+    <target name="-deps-jar-init" unless="built-jar.properties">
+        <property location="${build.dir}/built-jar.properties" name="built-jar.properties"/>
+        <delete file="${built-jar.properties}" quiet="true"/>
+    </target>
+    <target if="already.built.jar.${basedir}" name="-warn-already-built-jar">
+        <echo level="warn" message="Cycle detected: stubs was already built"/>
+    </target>
+    <target depends="init,-deps-jar-init" name="deps-jar" unless="no.deps">
+        <mkdir dir="${build.dir}"/>
+        <touch file="${built-jar.properties}" verbose="false"/>
+        <property file="${built-jar.properties}" prefix="already.built.jar."/>
+        <antcall target="-warn-already-built-jar"/>
+        <propertyfile file="${built-jar.properties}">
+            <entry key="${basedir}" value=""/>
+        </propertyfile>
+    </target>
+    <target depends="init,-check-automatic-build,-clean-after-automatic-build" name="-verify-automatic-build"/>
+    <target depends="init" name="-check-automatic-build">
+        <available file="${build.classes.dir}/.netbeans_automatic_build" property="netbeans.automatic.build"/>
+    </target>
+    <target depends="init" if="netbeans.automatic.build" name="-clean-after-automatic-build">
+        <antcall target="clean"/>
+    </target>
+    <target depends="init,deps-jar" name="-pre-pre-compile">
+        <mkdir dir="${build.classes.dir}"/>
+    </target>
+    <target name="-pre-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="do.depend.true" name="-compile-depend">
+        <pathconvert property="build.generated.subdirs">
+            <dirset dir="${build.generated.sources.dir}" erroronmissingdir="false">
+                <include name="*"/>
+            </dirset>
+        </pathconvert>
+        <j2seproject3:depend srcdir="${src.dir}:${build.generated.subdirs}"/>
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile,-pre-compile, -copy-persistence-xml,-compile-depend" if="have.sources" name="-do-compile">
+        <j2seproject3:javac gensrcdir="${build.generated.sources.dir}"/>
+        <copy todir="${build.classes.dir}">
+            <fileset dir="${src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target if="has.persistence.xml" name="-copy-persistence-xml">
+        <mkdir dir="${build.classes.dir}/META-INF"/>
+        <copy todir="${build.classes.dir}/META-INF">
+            <fileset dir="${meta.inf.dir}" includes="persistence.xml"/>
+        </copy>
+    </target>
+    <target name="-post-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile,-do-compile,-post-compile" description="Compile project." name="compile"/>
+    <target name="-pre-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile" name="-do-compile-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile/>
+        <j2seproject3:javac excludes="" gensrcdir="${build.generated.sources.dir}" includes="${javac.includes}" sourcepath="${src.dir}"/>
+    </target>
+    <target name="-post-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile-single,-do-compile-single,-post-compile-single" name="compile-single"/>
+    <!--
+                ====================
+                JAR BUILDING SECTION
+                ====================
+            -->
+    <target depends="init" name="-pre-pre-jar">
+        <dirname file="${dist.jar}" property="dist.jar.dir"/>
+        <mkdir dir="${dist.jar.dir}"/>
+    </target>
+    <target name="-pre-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="do.archive" name="-do-jar-without-manifest" unless="manifest.available-mkdist.available">
+        <j2seproject1:jar/>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="do.archive+manifest.available" name="-do-jar-with-manifest" unless="manifest.available+main.class-mkdist.available">
+        <j2seproject1:jar manifest="${manifest.file}"/>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="do.archive+manifest.available+main.class" name="-do-jar-with-mainclass" unless="manifest.available+main.class+mkdist.available">
+        <j2seproject1:jar manifest="${manifest.file}">
+            <j2seproject1:manifest>
+                <j2seproject1:attribute name="Main-Class" value="${main.class}"/>
+            </j2seproject1:manifest>
+        </j2seproject1:jar>
+        <echo level="info">To run this application from the command line without Ant, try:</echo>
+        <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <pathconvert property="run.classpath.with.dist.jar">
+            <path path="${run.classpath}"/>
+            <map from="${build.classes.dir.resolved}" to="${dist.jar.resolved}"/>
+        </pathconvert>
+        <echo level="info">${platform.java} -cp "${run.classpath.with.dist.jar}" ${main.class}</echo>
+    </target>
+    <target depends="init" if="do.archive" name="-do-jar-with-libraries-create-manifest" unless="manifest.available">
+        <tempfile deleteonexit="true" destdir="${build.dir}" property="tmp.manifest.file"/>
+        <touch file="${tmp.manifest.file}" verbose="false"/>
+    </target>
+    <target depends="init" if="do.archive+manifest.available" name="-do-jar-with-libraries-copy-manifest">
+        <tempfile deleteonexit="true" destdir="${build.dir}" property="tmp.manifest.file"/>
+        <copy file="${manifest.file}" tofile="${tmp.manifest.file}"/>
+    </target>
+    <target depends="init,-do-jar-with-libraries-create-manifest,-do-jar-with-libraries-copy-manifest" if="do.archive+main.class.available" name="-do-jar-with-libraries-set-main">
+        <manifest file="${tmp.manifest.file}" mode="update">
+            <attribute name="Main-Class" value="${main.class}"/>
+        </manifest>
+    </target>
+    <target depends="init,-do-jar-with-libraries-create-manifest,-do-jar-with-libraries-copy-manifest" if="do.archive+splashscreen.available" name="-do-jar-with-libraries-set-splashscreen">
+        <basename file="${application.splash}" property="splashscreen.basename"/>
+        <mkdir dir="${build.classes.dir}/META-INF"/>
+        <copy failonerror="false" file="${application.splash}" todir="${build.classes.dir}/META-INF"/>
+        <manifest file="${tmp.manifest.file}" mode="update">
+            <attribute name="SplashScreen-Image" value="META-INF/${splashscreen.basename}"/>
+        </manifest>
+    </target>
+    <target depends="init,-init-macrodef-copylibs,compile,-pre-pre-jar,-pre-jar,-do-jar-with-libraries-create-manifest,-do-jar-with-libraries-copy-manifest,-do-jar-with-libraries-set-main,-do-jar-with-libraries-set-splashscreen" if="do.mkdist" name="-do-jar-with-libraries-pack">
+        <j2seproject3:copylibs manifest="${tmp.manifest.file}"/>
+        <echo level="info">To run this application from the command line without Ant, try:</echo>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <echo level="info">${platform.java} -jar "${dist.jar.resolved}"</echo>
+    </target>
+    <target depends="-do-jar-with-libraries-pack" if="do.archive" name="-do-jar-with-libraries-delete-manifest">
+        <delete>
+            <fileset file="${tmp.manifest.file}"/>
+        </delete>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar,-do-jar-with-libraries-create-manifest,-do-jar-with-libraries-copy-manifest,-do-jar-with-libraries-set-main,-do-jar-with-libraries-set-splashscreen,-do-jar-with-libraries-pack,-do-jar-with-libraries-delete-manifest" name="-do-jar-with-libraries"/>
+    <target name="-post-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-jar,-do-jar-with-manifest,-do-jar-without-manifest,-do-jar-with-mainclass,-do-jar-with-libraries,-post-jar" description="Build JAR." name="jar"/>
+    <!--
+                =================
+                EXECUTION SECTION
+                =================
+            -->
+    <target depends="init,compile" description="Run a main class." name="run">
+        <j2seproject1:java>
+            <customize>
+                <arg line="${application.args}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <target name="-do-not-recompile">
+        <property name="javac.includes.binary" value=""/>
+    </target>
+    <target depends="init,compile-single" name="run-single">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <j2seproject1:java classname="${run.class}"/>
+    </target>
+    <target depends="init,compile-test-single" name="run-test-with-main">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <j2seproject1:java classname="${run.class}" classpath="${run.test.classpath}"/>
+    </target>
+    <!--
+                =================
+                DEBUGGING SECTION
+                =================
+            -->
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger">
+        <j2seproject1:nbjpdastart name="${debug.class}"/>
+    </target>
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger-main-test">
+        <j2seproject1:nbjpdastart classpath="${debug.test.classpath}" name="${debug.class}"/>
+    </target>
+    <target depends="init,compile" name="-debug-start-debuggee">
+        <j2seproject3:debug>
+            <customize>
+                <arg line="${application.args}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile,-debug-start-debugger,-debug-start-debuggee" description="Debug project in IDE." if="netbeans.home" name="debug"/>
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger-stepinto">
+        <j2seproject1:nbjpdastart stopclassname="${main.class}"/>
+    </target>
+    <target depends="init,compile,-debug-start-debugger-stepinto,-debug-start-debuggee" if="netbeans.home" name="debug-stepinto"/>
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-single">
+        <fail unless="debug.class">Must select one file in the IDE or set debug.class</fail>
+        <j2seproject3:debug classname="${debug.class}"/>
+    </target>
+    <target depends="init,compile-single,-debug-start-debugger,-debug-start-debuggee-single" if="netbeans.home" name="debug-single"/>
+    <target depends="init,compile-test-single" if="netbeans.home" name="-debug-start-debuggee-main-test">
+        <fail unless="debug.class">Must select one file in the IDE or set debug.class</fail>
+        <j2seproject3:debug classname="${debug.class}" classpath="${debug.test.classpath}"/>
+    </target>
+    <target depends="init,compile-test-single,-debug-start-debugger-main-test,-debug-start-debuggee-main-test" if="netbeans.home" name="debug-test-with-main"/>
+    <target depends="init" name="-pre-debug-fix">
+        <fail unless="fix.includes">Must set fix.includes</fail>
+        <property name="javac.includes" value="${fix.includes}.java"/>
+    </target>
+    <target depends="init,-pre-debug-fix,compile-single" if="netbeans.home" name="-do-debug-fix">
+        <j2seproject1:nbjpdareload/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix" if="netbeans.home" name="debug-fix"/>
+    <!--
+                =================
+                PROFILING SECTION
+                =================
+            -->
+    <target depends="profile-init,compile" description="Profile a project in the IDE." if="netbeans.home" name="profile">
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <profile/>
+    </target>
+    <target depends="profile-init,compile-single" description="Profile a selected class in the IDE." if="netbeans.home" name="profile-single">
+        <fail unless="profile.class">Must select one file in the IDE or set profile.class</fail>
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <profile classname="${profile.class}"/>
+    </target>
+    <!--
+                =========================
+                APPLET PROFILING  SECTION
+                =========================
+            -->
+    <target depends="profile-init,compile-single" if="netbeans.home" name="profile-applet">
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <profile classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </profile>
+    </target>
+    <!--
+                =========================
+                TESTS PROFILING  SECTION
+                =========================
+            -->
+    <target depends="profile-init,compile-test-single" if="netbeans.home" name="profile-test-single">
+        <nbprofiledirect>
+            <classpath>
+                <path path="${run.test.classpath}"/>
+            </classpath>
+        </nbprofiledirect>
+        <junit dir="${profiler.info.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" jvm="${profiler.info.jvm}" showoutput="true">
+            <env key="${profiler.info.pathvar}" path="${profiler.info.agentpath}:${profiler.current.path}"/>
+            <jvmarg value="${profiler.info.jvmargs.agent}"/>
+            <jvmarg line="${profiler.info.jvmargs}"/>
+            <test name="${profile.class}"/>
+            <classpath>
+                <path path="${run.test.classpath}"/>
+            </classpath>
+            <syspropertyset>
+                <propertyref prefix="test-sys-prop."/>
+                <mapper from="test-sys-prop.*" to="*" type="glob"/>
+            </syspropertyset>
+            <formatter type="brief" usefile="false"/>
+            <formatter type="xml"/>
+        </junit>
+    </target>
+    <!--
+                ===============
+                JAVADOC SECTION
+                ===============
+            -->
+    <target depends="init" if="have.sources" name="-javadoc-build">
+        <mkdir dir="${dist.javadoc.dir}"/>
+        <condition else="" property="javadoc.endorsed.classpath.cmd.line.arg" value="-J${endorsed.classpath.cmd.line.arg}">
+            <and>
+                <isset property="endorsed.classpath.cmd.line.arg"/>
+                <not>
+                    <equals arg1="${endorsed.classpath.cmd.line.arg}" arg2=""/>
+                </not>
+            </and>
+        </condition>
+        <javadoc additionalparam="${javadoc.additionalparam}" author="${javadoc.author}" charset="UTF-8" destdir="${dist.javadoc.dir}" docencoding="UTF-8" encoding="${javadoc.encoding.used}" executable="${platform.javadoc}" failonerror="true" noindex="${javadoc.noindex}" nonavbar="${javadoc.nonavbar}" notree="${javadoc.notree}" private="${javadoc.private}" source="${javac.source}" splitindex="${javadoc.splitindex}" use="${javadoc.use}" useexternalfile="true" version="${javadoc.version}" windowtitle="${javadoc.windowtitle}">
+            <classpath>
+                <path path="${javac.classpath}"/>
+            </classpath>
+            <fileset dir="${src.dir}" excludes="*.java,${excludes}" includes="${includes}">
+                <filename name="**/*.java"/>
+            </fileset>
+            <fileset dir="${build.generated.sources.dir}" erroronmissingdir="false">
+                <include name="**/*.java"/>
+                <exclude name="*.java"/>
+            </fileset>
+            <arg line="${javadoc.endorsed.classpath.cmd.line.arg}"/>
+        </javadoc>
+        <copy todir="${dist.javadoc.dir}">
+            <fileset dir="${src.dir}" excludes="${excludes}" includes="${includes}">
+                <filename name="**/doc-files/**"/>
+            </fileset>
+            <fileset dir="${build.generated.sources.dir}" erroronmissingdir="false">
+                <include name="**/doc-files/**"/>
+            </fileset>
+        </copy>
+    </target>
+    <target depends="init,-javadoc-build" if="netbeans.home" name="-javadoc-browse" unless="no.javadoc.preview">
+        <nbbrowse file="${dist.javadoc.dir}/index.html"/>
+    </target>
+    <target depends="init,-javadoc-build,-javadoc-browse" description="Build Javadoc." name="javadoc"/>
+    <!--
+                =========================
+                JUNIT COMPILATION SECTION
+                =========================
+            -->
+    <target depends="init,compile" if="have.tests" name="-pre-pre-compile-test">
+        <mkdir dir="${build.test.classes.dir}"/>
+    </target>
+    <target name="-pre-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="do.depend.true" name="-compile-test-depend">
+        <j2seproject3:depend classpath="${javac.test.classpath}" destdir="${build.test.classes.dir}" srcdir="${test.src.dir}"/>
+    </target>
+    <target depends="init,deps-jar,compile,-pre-pre-compile-test,-pre-compile-test,-compile-test-depend" if="have.tests" name="-do-compile-test">
+        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" processorpath="${javac.test.processorpath}" srcdir="${test.src.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test,-do-compile-test,-post-compile-test" name="compile-test"/>
+    <target name="-pre-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,compile,-pre-pre-compile-test,-pre-compile-test-single" if="have.tests" name="-do-compile-test-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile destdir="${build.test.classes.dir}"/>
+        <j2seproject3:javac apgeneratedsrcdir="${build.test.classes.dir}" classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" excludes="" includes="${javac.includes}" processorpath="${javac.test.processorpath}" sourcepath="${test.src.dir}" srcdir="${test.src.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test-single,-do-compile-test-single,-post-compile-test-single" name="compile-test-single"/>
+    <!--
+                =======================
+                JUNIT EXECUTION SECTION
+                =======================
+            -->
+    <target depends="init" if="have.tests" name="-pre-test-run">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test,-pre-test-run" if="have.tests" name="-do-test-run">
+        <j2seproject3:junit testincludes="**/*Test.java"/>
+    </target>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run" if="have.tests" name="-post-test-run">
+        <fail if="tests.failed" unless="ignore.failing.tests">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init" if="have.tests" name="test-report"/>
+    <target depends="init" if="netbeans.home+have.tests" name="-test-browse"/>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run,test-report,-post-test-run,-test-browse" description="Run unit tests." name="test"/>
+    <target depends="init" if="have.tests" name="-pre-test-run-single">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single" if="have.tests" name="-do-test-run-single">
+        <fail unless="test.includes">Must select some files in the IDE or set test.includes</fail>
+        <j2seproject3:junit excludes="" includes="${test.includes}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single,-do-test-run-single" if="have.tests" name="-post-test-run-single">
+        <fail if="tests.failed" unless="ignore.failing.tests">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single,-do-test-run-single,-post-test-run-single" description="Run single unit test." name="test-single"/>
+    <!--
+                =======================
+                JUNIT DEBUGGING SECTION
+                =======================
+            -->
+    <target depends="init,compile-test" if="have.tests" name="-debug-start-debuggee-test">
+        <fail unless="test.class">Must select one file in the IDE or set test.class</fail>
+        <property location="${build.test.results.dir}/TEST-${test.class}.xml" name="test.report.file"/>
+        <delete file="${test.report.file}"/>
+        <mkdir dir="${build.test.results.dir}"/>
+        <j2seproject3:debug classname="org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner" classpath="${ant.home}/lib/ant.jar:${ant.home}/lib/ant-junit.jar:${debug.test.classpath}">
+            <customize>
+                <syspropertyset>
+                    <propertyref prefix="test-sys-prop."/>
+                    <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                </syspropertyset>
+                <arg value="${test.class}"/>
+                <arg value="showoutput=true"/>
+                <arg value="formatter=org.apache.tools.ant.taskdefs.optional.junit.BriefJUnitResultFormatter"/>
+                <arg value="formatter=org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter,${test.report.file}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile-test" if="netbeans.home+have.tests" name="-debug-start-debugger-test">
+        <j2seproject1:nbjpdastart classpath="${debug.test.classpath}" name="${test.class}"/>
+    </target>
+    <target depends="init,compile-test-single,-debug-start-debugger-test,-debug-start-debuggee-test" name="debug-test"/>
+    <target depends="init,-pre-debug-fix,compile-test-single" if="netbeans.home" name="-do-debug-fix-test">
+        <j2seproject1:nbjpdareload dir="${build.test.classes.dir}"/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix-test" if="netbeans.home" name="debug-fix-test"/>
+    <!--
+                =========================
+                APPLET EXECUTION SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" name="run-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject1:java classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <!--
+                =========================
+                APPLET DEBUGGING  SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject3:debug classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile-single,-debug-start-debugger,-debug-start-debuggee-applet" if="netbeans.home" name="debug-applet"/>
+    <!--
+                ===============
+                CLEANUP SECTION
+                ===============
+            -->
+    <target name="-deps-clean-init" unless="built-clean.properties">
+        <property location="${build.dir}/built-clean.properties" name="built-clean.properties"/>
+        <delete file="${built-clean.properties}" quiet="true"/>
+    </target>
+    <target if="already.built.clean.${basedir}" name="-warn-already-built-clean">
+        <echo level="warn" message="Cycle detected: stubs was already built"/>
+    </target>
+    <target depends="init,-deps-clean-init" name="deps-clean" unless="no.deps">
+        <mkdir dir="${build.dir}"/>
+        <touch file="${built-clean.properties}" verbose="false"/>
+        <property file="${built-clean.properties}" prefix="already.built.clean."/>
+        <antcall target="-warn-already-built-clean"/>
+        <propertyfile file="${built-clean.properties}">
+            <entry key="${basedir}" value=""/>
+        </propertyfile>
+    </target>
+    <target depends="init" name="-do-clean">
+        <delete dir="${build.dir}"/>
+        <delete dir="${dist.dir}" followsymlinks="false" includeemptydirs="true"/>
+    </target>
+    <target name="-post-clean">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-clean,-do-clean,-post-clean" description="Clean build products." name="clean"/>
+    <target name="-check-call-dep">
+        <property file="${call.built.properties}" prefix="already.built."/>
+        <condition property="should.call.dep">
+            <not>
+                <isset property="already.built.${call.subproject}"/>
+            </not>
+        </condition>
+    </target>
+    <target depends="-check-call-dep" if="should.call.dep" name="-maybe-call-dep">
+        <ant antfile="${call.script}" inheritall="false" target="${call.target}">
+            <propertyset>
+                <propertyref prefix="transfer."/>
+                <mapper from="transfer.*" to="*" type="glob"/>
+            </propertyset>
+        </ant>
+    </target>
+</project>
diff -r 02f810c26ff9 -r 716d47361960 stubs/nbproject/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/nbproject/project.properties	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,70 @@
+annotation.processing.enabled=true
+annotation.processing.enabled.in.editor=false
+annotation.processing.run.all.processors=true
+annotation.processing.source.output=${build.generated.sources.dir}/ap-source-output
+application.title=stubs
+application.vendor=Petr Hejl
+build.classes.dir=${build.dir}/classes
+build.classes.excludes=**/*.java,**/*.form
+# This directory is removed when the project is cleaned:
+build.dir=build
+build.generated.dir=${build.dir}/generated
+build.generated.sources.dir=${build.dir}/generated-sources
+# Only compile against the classpath explicitly listed here:
+build.sysclasspath=ignore
+build.test.classes.dir=${build.dir}/test/classes
+build.test.results.dir=${build.dir}/test/results
+# Uncomment to specify the preferred debugger connection transport:
+#debug.transport=dt_socket
+debug.classpath=\
+    ${run.classpath}
+debug.test.classpath=\
+    ${run.test.classpath}
+# This directory is removed when the project is cleaned:
+dist.dir=dist
+dist.jar=${dist.dir}/stubs.jar
+dist.javadoc.dir=${dist.dir}/javadoc
+endorsed.classpath=
+excludes=
+includes=**
+jar.compress=false
+javac.classpath=
+# Space-separated list of extra javac options
+javac.compilerargs=
+javac.deprecation=false
+javac.processorpath=\
+    ${javac.classpath}
+javac.source=1.6
+javac.target=1.6
+javac.test.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}
+javac.test.processorpath=\
+    ${javac.test.classpath}
+javadoc.additionalparam=
+javadoc.author=false
+javadoc.encoding=${source.encoding}
+javadoc.noindex=false
+javadoc.nonavbar=false
+javadoc.notree=false
+javadoc.private=false
+javadoc.splitindex=true
+javadoc.use=true
+javadoc.version=false
+javadoc.windowtitle=
+meta.inf.dir=${src.dir}/META-INF
+mkdist.disabled=true
+platform.active=JDK_1.7
+run.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}
+# Space-separated list of JVM arguments used when running the project
+# (you may also define separate properties like run-sys-prop.name=value instead of -Dname=value
+# or test-sys-prop.name=value to set system properties for unit tests):
+run.jvmargs=
+run.test.classpath=\
+    ${javac.test.classpath}:\
+    ${build.test.classes.dir}
+source.encoding=UTF-8
+src.dir=src
+test.src.dir=test
diff -r 02f810c26ff9 -r 716d47361960 stubs/nbproject/project.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/nbproject/project.xml	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://www.netbeans.org/ns/project/1">
+    <type>org.netbeans.modules.java.j2seproject</type>
+    <configuration>
+        <data xmlns="http://www.netbeans.org/ns/j2se-project/3">
+            <name>stubs</name>
+            <explicit-platform explicit-source-supported="true"/>
+            <source-roots>
+                <root id="src.dir"/>
+            </source-roots>
+            <test-roots>
+                <root id="test.src.dir"/>
+            </test-roots>
+        </data>
+    </configuration>
+</project>
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/ClassValue.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/ClassValue.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public abstract class ClassValue<T> {
+
+    protected ClassValue() {
+        super();
+    }
+
+    protected abstract T computeValue(Class<?> type);
+
+    public T get(Class<?> type) {
+        throw new RuntimeException("stub only");
+    }
+
+    public void remove(Class<?> type) {
+        throw new RuntimeException("stub only");
+    }
+
+}
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/invoke/CallSite.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/invoke/CallSite.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public abstract class CallSite {
+
+    public MethodType type() {
+        throw new RuntimeException("stub only");
+    }
+
+    public abstract MethodHandle getTarget();
+
+    public abstract void setTarget(MethodHandle mh);
+
+    public abstract MethodHandle dynamicInvoker();
+
+}
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/invoke/ConstantCallSite.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/invoke/ConstantCallSite.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class ConstantCallSite extends CallSite {
+
+    public ConstantCallSite(MethodHandle target) {
+        throw new RuntimeException("stub only");
+    }
+
+    protected ConstantCallSite(MethodType targetType, MethodHandle createTargetHook) throws Throwable {
+        throw new RuntimeException("stub only");
+    }
+
+    public final MethodHandle getTarget() {
+        throw new RuntimeException("stub only");
+    }
+
+    public final void setTarget(MethodHandle ignore) {
+        throw new RuntimeException("stub only");
+    }
+
+    public final MethodHandle dynamicInvoker() {
+        throw new RuntimeException("stub only");
+    }
+}
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/invoke/MethodHandle.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/invoke/MethodHandle.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+import java.util.List;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public abstract class MethodHandle {
+
+    public MethodType type() {
+        throw new RuntimeException("stub only");
+    }
+
+    public final Object invokeExact(Object... args) throws Throwable {
+        throw new RuntimeException("stub only");
+    }
+
+    public final Object invoke(Object... args) throws Throwable {
+        throw new RuntimeException("stub only");
+    }
+
+    public Object invokeWithArguments(Object... arguments) throws Throwable {
+        throw new RuntimeException("stub only");
+    }
+
+    public Object invokeWithArguments(List<?> arguments) throws Throwable {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodHandle asType(MethodType newType) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodHandle asSpreader(Class<?> arrayType, int arrayLength) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodHandle asCollector(Class<?> arrayType, int arrayLength) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodHandle asVarargsCollector(Class<?> arrayType) {
+        throw new RuntimeException("stub only");
+    }
+
+    public boolean isVarargsCollector() {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodHandle asFixedArity() {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodHandle bindTo(Object x) {
+        throw new RuntimeException("stub only");
+    }
+}
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/invoke/MethodHandles.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/invoke/MethodHandles.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.List;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class MethodHandles {
+
+    public static Lookup lookup() {
+        throw new RuntimeException("stub only");
+    }
+
+    public static Lookup publicLookup() {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle arrayElementGetter(Class<?> arrayClass) throws IllegalArgumentException {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle arrayElementSetter(Class<?> arrayClass) throws IllegalArgumentException {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle exactInvoker(MethodType type) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle invoker(MethodType type) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle constant(Class<?> type, Object value) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle identity(Class<?> type) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle dropArguments(MethodHandle target, int pos, List<Class<?>> valueTypes) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle dropArguments(MethodHandle target, int pos, Class<?>... valueTypes) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle guardWithTest(MethodHandle test, MethodHandle target, MethodHandle fallback) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle catchException(MethodHandle target, Class<? extends Throwable> exType, MethodHandle handler) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodHandle throwException(Class<?> returnType, Class<? extends Throwable> exType) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static final class Lookup {
+
+        public static final int PUBLIC = 1;
+
+        public static final int PRIVATE = 2;
+
+        public static final int PROTECTED = 4;
+
+        public static final int PACKAGE = 8;
+
+        public Class<?> lookupClass() {
+            throw new RuntimeException("stub only");
+        }
+
+        public int lookupModes() {
+            throw new RuntimeException("stub only");
+        }
+
+        public Lookup in(Class<?> requestedLookupClass) {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findStatic(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findVirtual(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findSpecial(Class<?> refc, String name, MethodType type, Class<?> specialCaller) throws NoSuchMethodException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findSetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findStaticGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle findStaticSetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle unreflect(Method m) throws IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle unreflectSpecial(Method m, Class<?> specialCaller) throws IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle unreflectConstructor(Constructor c) throws IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+
+        public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
+            throw new RuntimeException("stub only");
+        }
+    }
+}
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/invoke/MethodType.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/invoke/MethodType.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+import java.util.List;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public final class MethodType {
+
+    public static MethodType methodType(Class<?> rtype, Class<?>[] ptypes) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType methodType(Class<?> rtype, List<Class<?>> ptypes) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType methodType(Class<?> rtype, Class<?> ptype0, Class<?>... ptypes) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType methodType(Class<?> rtype) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType methodType(Class<?> rtype, Class<?> ptype0) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType methodType(Class<?> rtype, MethodType ptypes) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType genericMethodType(int objectArgCount, boolean finalArray) {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType genericMethodType(int objectArgCount) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType changeParameterType(int num, Class<?> nptype) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType insertParameterTypes(int num, Class<?>... ptypesToInsert) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType appendParameterTypes(Class<?>... ptypesToInsert) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType insertParameterTypes(int num, List<Class<?>> ptypesToInsert) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType appendParameterTypes(List<Class<?>> ptypesToInsert) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType dropParameterTypes(int start, int end) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType changeReturnType(Class<?> nrtype) {
+        throw new RuntimeException("stub only");
+    }
+
+    public boolean hasPrimitives() {
+        throw new RuntimeException("stub only");
+    }
+
+    public boolean hasWrappers() {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType erase() {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType generic() {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType wrap() {
+        throw new RuntimeException("stub only");
+    }
+
+    public MethodType unwrap() {
+        throw new RuntimeException("stub only");
+    }
+
+    public Class<?> parameterType(int num) {
+        throw new RuntimeException("stub only");
+    }
+
+    public int parameterCount() {
+        throw new RuntimeException("stub only");
+    }
+
+    public Class<?> returnType() {
+        throw new RuntimeException("stub only");
+    }
+
+    public List<Class<?>> parameterList() {
+        throw new RuntimeException("stub only");
+    }
+
+    public Class<?>[] parameterArray() {
+        throw new RuntimeException("stub only");
+    }
+
+    public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader)
+            throws IllegalArgumentException, TypeNotPresentException {
+        throw new RuntimeException("stub only");
+    }
+
+    public String toMethodDescriptorString() {
+        throw new RuntimeException("stub only");
+    }
+}
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/invoke/MutableCallSite.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/invoke/MutableCallSite.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class MutableCallSite extends CallSite {
+
+    public MutableCallSite(MethodType type) {
+        throw new RuntimeException("stub only");
+    }
+
+    public MutableCallSite(MethodHandle target) {
+        throw new RuntimeException("stub only");
+    }
+
+    public final MethodHandle getTarget() {
+        throw new RuntimeException("stub only");
+    }
+
+    public void setTarget(MethodHandle newTarget) {
+        throw new RuntimeException("stub only");
+    }
+
+    public final MethodHandle dynamicInvoker() {
+        throw new RuntimeException("stub only");
+    }
+
+    public static void syncAll(MutableCallSite[] sites) {
+        throw new RuntimeException("stub only");
+    }
+}
+
diff -r 02f810c26ff9 -r 716d47361960 stubs/src/java/lang/invoke/SwitchPoint.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/stubs/src/java/lang/invoke/SwitchPoint.java	Thu Feb 07 13:40:05 2013 +0100
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2010-2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class SwitchPoint {
+
+    public MethodHandle guardWithTest(MethodHandle target, MethodHandle fallback) {
+        throw new RuntimeException("stub only");
+    }
+
+    public boolean hasBeenInvalidated() {
+        throw new RuntimeException("stub only");
+    }
+
+    public static void invalidateAll(SwitchPoint[] switchPoints) {
+        throw new RuntimeException("stub only");
+    }
+
+}
