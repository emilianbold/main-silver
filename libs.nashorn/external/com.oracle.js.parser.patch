diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/AbstractParser.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/AbstractParser.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/AbstractParser.java	Wed Jul 20 10:53:21 2016 +0200
@@ -88,6 +88,9 @@
     /** Is this parser running under strong mode? */
     protected boolean isStrongMode;
 
+    /** Is this parser parsing module? */
+    protected boolean isModule;
+
     /** What should line numbers be counted from? */
     protected final int lineOffset;
 
@@ -463,15 +466,16 @@
      *
      * @return true if current token is an identifier name
      */
-    protected final boolean isIdentifierName() {
-        final TokenKind kind = type.getKind();
+    protected final boolean isIdentifierName(long token) {
+        final TokenType currentType = Token.descType(token);
+        final TokenKind kind = currentType.getKind();
         if (kind == TokenKind.KEYWORD || kind == TokenKind.FUTURE || kind == TokenKind.FUTURESTRICT) {
             return true;
         }
 
         // only literals allowed are null, false and true
         if (kind == TokenKind.LITERAL) {
-            switch (type) {
+            switch (currentType) {
                 case FALSE:
                 case NULL:
                 case TRUE:
@@ -496,7 +500,7 @@
     protected final IdentNode getIdentifierName() {
         if (type == IDENT) {
             return getIdent();
-        } else if (isIdentifierName()) {
+        } else if (isIdentifierName(token)) {
             // Fake out identifier.
             final long identToken = Token.recast(token, IDENT);
             // Get IDENT.
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/Lexer.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/Lexer.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/Lexer.java	Wed Jul 20 10:53:21 2016 +0200
@@ -53,6 +53,8 @@
 import static com.oracle.js.parser.TokenType.XML;
 
 import java.math.BigInteger;
+import java.util.ArrayDeque;
+import java.util.Deque;
 
 // @formatter:off
 /**
@@ -81,6 +83,9 @@
     /** True if parsing in ECMAScript 6 mode. */
     private final boolean es6;
 
+    /** True if parsing JSX. */
+    private final boolean jsx;
+
     /** True if a nested scan. (scan to completion, no EOF.) */
     private final boolean nested;
 
@@ -96,7 +101,21 @@
     private final boolean pauseOnFunctionBody;
     private boolean pauseOnNextLeftBrace;
 
-    private int templateExpressionOpenBraces;
+    private int jsxTagCount;
+
+    private boolean jsxTag;
+
+    private boolean jsxClosing;
+
+    private boolean template;
+
+    private boolean templateExpression;
+
+    private int nextStateChange;
+
+    private int openExpressionBraces;
+
+    private final Deque<InnerState> innerStates = new ArrayDeque<>();
 
     private static final String SPACETAB = " \t";  // ASCII space and tab
     private static final String LFCR     = "\n\r"; // line feed and carriage return (ctrl-m)
@@ -184,7 +203,7 @@
      * @param stream    the token stream to lex
      */
     public Lexer(final Source source, final TokenStream stream) {
-        this(source, stream, false, false, false);
+        this(source, stream, false, false, false, false);
     }
 
     /**
@@ -196,8 +215,8 @@
      * @param es6       are we in ECMAScript 6 mode
      * @param shebang   do we support shebang
      */
-    public Lexer(final Source source, final TokenStream stream, final boolean scripting, final boolean es6, final boolean shebang) {
-        this(source, 0, source.getLength(), stream, scripting, es6, shebang, false);
+    public Lexer(final Source source, final TokenStream stream, final boolean scripting, final boolean es6, final boolean shebang, final boolean jsx) {
+        this(source, 0, source.getLength(), stream, scripting, es6, shebang, false, jsx);
     }
 
     /**
@@ -214,12 +233,13 @@
      * function body. This is used with the feature where the parser is skipping nested function bodies to
      * avoid reading ahead unnecessarily when we skip the function bodies.
      */
-    public Lexer(final Source source, final int start, final int len, final TokenStream stream, final boolean scripting, final boolean es6, final boolean shebang, final boolean pauseOnFunctionBody) {
+    public Lexer(final Source source, final int start, final int len, final TokenStream stream, final boolean scripting, final boolean es6, final boolean shebang, final boolean pauseOnFunctionBody, final boolean jsx) {
         super(source.getContent(), 1, start, len);
         this.source      = source;
         this.stream      = stream;
         this.scripting   = scripting;
         this.es6         = es6;
+        this.jsx         = jsx;
         this.shebang     = shebang;
         this.nested      = false;
         this.pendingLine = 1;
@@ -235,6 +255,7 @@
         stream = lexer.stream;
         scripting = lexer.scripting;
         es6 = lexer.es6;
+        jsx = lexer.jsx;
         shebang = lexer.shebang;
         nested = true;
 
@@ -258,7 +279,8 @@
          * Constructor.
          */
 
-        State(final int position, final int limit, final int line, final int pendingLine, final int linePosition, final TokenType last) {
+        State(final int position, final int limit, final int line,
+                final int pendingLine, final int linePosition, final TokenType last) {
             super(position, limit, line);
 
             this.pendingLine = pendingLine;
@@ -598,7 +620,9 @@
      * @return true if token can start a literal.
      */
     public boolean canStartLiteral(final TokenType token) {
-        return token.startsWith('/') || ((scripting || XML_LITERALS) && token.startsWith('<'));
+        return token.startsWith('/')
+                || ((scripting || XML_LITERALS) && token.startsWith('<'))
+                || (jsx && token.startsWith('<'));
     }
 
     /**
@@ -647,6 +671,27 @@
         return false;
     }
 
+    protected boolean scanJsx(final long token, final TokenType startTokenType) {
+        // Check if it can be a literal.
+        if (!startTokenType.startsWith('<')) {
+            return false;
+        }
+        // We break on ambiguous tokens so if we already moved on it can't be a literal.
+        if (stream.get(stream.last()) != token) {
+            return false;
+        }
+        // Rewind to token start position
+        reset(Token.descPosition(token));
+
+        if (ch0 == '<' && ch1 != '<') {
+            jsxTagCount = 1;
+            jsxTag = true;
+            skip(1);
+            return true;
+        }
+        return false;
+    }
+
     /**
      * Scan over regex literal.
      *
@@ -1129,70 +1174,6 @@
     }
 
     /**
-     * Scan over a template string literal.
-     */
-    private void scanTemplate() {
-        assert ch0 == '`';
-        TokenType type = TEMPLATE;
-
-        // Skip over quote and record beginning of string content.
-        skip(1);
-        State stringState = saveState();
-
-        // Scan until close quote
-        while (!atEOF()) {
-            // Skip over escaped character.
-            if (ch0 == '`') {
-                skip(1);
-                // Record end of string.
-                stringState.setLimit(position - 1);
-                add(type == TEMPLATE ? type : TEMPLATE_TAIL, stringState.position, stringState.limit);
-                return;
-            } else if (ch0 == '$' && ch1 == '{') {
-                skip(2);
-                stringState.setLimit(position - 2);
-                add(type == TEMPLATE ? TEMPLATE_HEAD : type, stringState.position, stringState.limit);
-
-                // scan to RBRACE
-                Lexer expressionLexer = new Lexer(this, saveState());
-                expressionLexer.templateExpressionOpenBraces = 1;
-                expressionLexer.lexify();
-                restoreState(expressionLexer.saveState());
-
-                // scan next middle or tail of the template literal
-                assert ch0 == '}';
-                type = TEMPLATE_MIDDLE;
-
-                // Skip over rbrace and record beginning of string content.
-                skip(1);
-                stringState = saveState();
-
-                continue;
-            } else if (ch0 == '\\') {
-                skip(1);
-                // EscapeSequence
-                if (!isEscapeCharacter(ch0)) {
-                    error(Lexer.message("invalid.escape.char"), TEMPLATE, position, limit);
-                }
-                if (isEOL(ch0)) {
-                    // LineContinuation
-                    skipEOL(false);
-                    continue;
-                }
-            }  else if (isEOL(ch0)) {
-                // LineTerminatorSequence
-                skipEOL(false);
-                continue;
-            }
-
-            // Skip literal character.
-            skip(1);
-        }
-
-        error(Lexer.message("missing.close.quote"), TEMPLATE, position, limit);
-    }
-
-    /**
      * Is the given character a valid escape char after "\" ?
      *
      * @param ch character to be checked
@@ -1409,6 +1390,56 @@
         return false;
     }
 
+    private void scanJsxIdentifier() {
+        final int start = position;
+        int length = scanIdentifier();
+        if (length > 0) {
+            if (ch0 == '-') {
+                length++;
+                skip(1);
+            }
+        }
+        add(TokenType.JSX_IDENTIFIER, start);
+    }
+
+    private void scanJsxText() {
+        final int start = position;
+
+        // Make sure remaining characters are valid source characters.
+        while (!atEOF()) {
+            if (ch0 == '{' || ch0 == '}' || ch0 == '<' || ch0 == '>') {
+                break;
+            } else {
+                skip(1);
+            }
+        }
+
+        add(TokenType.JSX_TEXT, start);
+    }
+
+    private void scanJsxString() {
+        assert ch0 == '"' || ch0 == '\'';
+
+        // Record starting quote.
+        final char quote = ch0;
+        // Skip over quote.
+        skip(1);
+
+        final int start = position;
+
+        // Make sure remaining characters are valid source characters.
+        while (!atEOF()) {
+            if (ch0 == quote) {
+                skip(1);
+                break;
+            } else {
+                skip(1);
+            }
+        }
+
+        add(TokenType.JSX_STRING, start, position - 1);
+    }
+
     /**
      * Scan over identifier characters.
      *
@@ -1746,6 +1777,136 @@
         return false;
     }
 
+    private void handleTemplate() {
+        int start = position;
+        while (!atEOF()) {
+            // Skip over escaped character.
+            if (ch0 == '`') {
+                skip(1);
+
+                // TEMPLATE or TEMPLATE_TAIL
+                add(templateExpression ? TEMPLATE_TAIL : TEMPLATE, start, position - 1);
+                template = false;
+                templateExpression = false;
+                break;
+            } else if (ch0 == '$' && ch1 == '{') {
+                skip(2);
+
+                // TEMPLATE_HEAD or TEMPLATE_MIDDLE
+                add(templateExpression ? TEMPLATE_MIDDLE : TEMPLATE_HEAD, start, position - 2);
+                templateExpression = true;
+
+                innerStates.push(new TemplateState(template, templateExpression, nextStateChange));
+                template = false;
+                templateExpression = false;
+                nextStateChange = openExpressionBraces;
+                openExpressionBraces++;
+                break;
+            } else if (ch0 == '\\') {
+                skip(1);
+                // EscapeSequence
+                if (!isEscapeCharacter(ch0)) {
+                    error(Lexer.message("invalid.escape.char"), TEMPLATE, position, limit);
+                }
+                if (isEOL(ch0)) {
+                    // LineContinuation
+                    skipEOL(false);
+                    continue;
+                }
+            } else if (isEOL(ch0)) {
+                // LineTerminatorSequence
+                skipEOL(false);
+                continue;
+            }
+
+            // Skip literal character.
+            skip(1);
+        }
+    }
+
+    private void handleJsx() {
+        if (jsxTag) {
+            if (Character.isJavaIdentifierStart(ch0) || ch0 == '\\' && ch1 == 'u') {
+                // Scan and add identifier or keyword.
+                scanJsxIdentifier();
+            } else if (isStringDelimiter(ch0)) {
+                scanJsxString();
+            } else {
+                switch (ch0) {
+                case '=':
+                case '.':
+                case ':':
+                    add(TokenLookup.lookupOperator(ch0, ch1, ch2, ch3), position, position + 1);
+                    skip(1);
+                    break;
+                case '{':
+                    skip(1);
+                    add(LBRACE, position - 1);
+                    innerStates.push(new JsxState(jsxTagCount, jsxTag, jsxClosing, nextStateChange));
+                    jsxTagCount = 0;
+                    jsxTag = false;
+                    jsxClosing = false;
+                    nextStateChange = openExpressionBraces;
+                    openExpressionBraces++;
+                    break;
+                case '<':
+                    skip(1);
+                    add(TokenType.JSX_ELEM_START, position - 1);
+                    jsxTagCount++;
+                    break;
+                case '/':
+                    skip(1);
+                    add(TokenType.JSX_ELEM_CLOSE, position - 1);
+                    jsxClosing = true;
+                    break;
+                case '>':
+                    skip(1);
+                    add(TokenType.JSX_ELEM_END, position - 1);
+                    jsxTag = false;
+                    if (jsxClosing) {
+                        jsxClosing = false;
+                        jsxTagCount--;
+                    }   break;
+                default:
+                    skip(1);
+                    add(ERROR, position - 1);
+                    break;
+                }
+            }
+        } else {
+            switch (ch0) {
+            case '<':
+                skip(1);
+                add(TokenType.JSX_ELEM_START, position - 1);
+                if (ch0 != '/') {
+                    jsxTagCount++;
+                }   jsxTag = true;
+                break;
+            case '{':
+                skip(1);
+                add(LBRACE, position - 1);
+                innerStates.push(new JsxState(jsxTagCount, jsxTag, jsxClosing, nextStateChange));
+                jsxTagCount = 0;
+                jsxTag = false;
+                jsxClosing = false;
+                nextStateChange = openExpressionBraces;
+                openExpressionBraces++;
+                break;
+            case '}':
+            case '>':
+                // we are not in tag and not in expression
+                // so this is either lex error or we may emit
+                // proper tokens and parser will fail
+                skip(1);
+                add(ERROR, position - 1);
+                break;
+            default:
+                scanJsxText();
+                break;
+            }
+        }
+    }
+
     /**
      * Breaks source content down into lex units, adding tokens to the token
      * stream. The routine scans until the stream buffer is full. Can be called
@@ -1753,6 +1914,24 @@
      */
     public void lexify() {
         while (!stream.isFull() || nested) {
+            // Detect end of file.
+            if (atEOF()) {
+                if (!nested) {
+                    if (template) {
+                        error(Lexer.message("missing.close.quote"), TEMPLATE, position, limit);
+                    }
+                    // Add an EOF token at the end.
+                    add(EOF, position);
+                }
+
+                break;
+            }
+
+            if (template) {
+                handleTemplate();
+                continue;
+            }
+
             // Skip over whitespace.
             skipWhitespace(true);
 
@@ -1777,6 +1956,11 @@
                 continue;
             }
 
+            if (jsxTagCount > 0) {
+                handleJsx();
+                continue;
+            }
+
             // TokenType for lookup of delimiter or operator.
             TokenType type;
 
@@ -1785,11 +1969,18 @@
                 // Scan and add a number.
                 scanNumber();
             } else if ((type = TokenLookup.lookupOperator(ch0, ch1, ch2, ch3)) != null) {
-                if (templateExpressionOpenBraces > 0) {
+                if (!innerStates.isEmpty()) {
                     if (type == LBRACE) {
-                        templateExpressionOpenBraces++;
+                        openExpressionBraces++;
                     } else if (type == RBRACE) {
-                        if (--templateExpressionOpenBraces == 0) {
+                        if (--openExpressionBraces == nextStateChange) {
+                            InnerState state = innerStates.pop();
+                            state.restore(this);
+                            nextStateChange = state.nextStateChange();
+                            skip(1);
+                            if (state.emitRightCurly()) {
+                                add(RBRACE, position - 1);
+                            }
                             break;
                         }
                     }
@@ -1820,7 +2011,9 @@
                 scanNumber();
             } else if (isTemplateDelimiter(ch0) && es6) {
                 // Scan and add template in ES6 mode.
-                scanTemplate();
+                //scanTemplate();
+                template = true;
+                skip(1);
             } else if (isTemplateDelimiter(ch0) && scripting) {
                 // Scan and add an exec string ('`') in scripting mode.
                 scanString(true);
@@ -1871,6 +2064,8 @@
                 return (long)value;
             }
             return value;
+        case JSX_TEXT:
+        case JSX_STRING:
         case STRING:
             return source.getString(start, len); // String
         case ESCSTRING:
@@ -1888,6 +2083,8 @@
             return valueOfXML(start, len); // XMLToken::LexerToken
         case DIRECTIVE_COMMENT:
             return source.getString(start, len);
+        case JSX_IDENTIFIER:
+            return valueOfIdent(start, len); // String
         default:
             break;
         }
@@ -2032,4 +2229,79 @@
             super(expression);
         }
     }
+
+    public static interface InnerState {
+
+        void restore(Lexer lexer);
+
+        boolean emitRightCurly();
+
+        int nextStateChange();
+    }
+
+    public static class JsxState implements InnerState {
+
+        private final int jsxTagCount;
+
+        private final boolean jsxTag;
+
+        private final boolean jsxClosing;
+
+        private final int expressionBraces;
+
+        public JsxState(int jsxTagCount, boolean jsxTag, boolean jsxClosing, int expressionBraces) {
+            this.jsxTagCount = jsxTagCount;
+            this.jsxTag = jsxTag;
+            this.jsxClosing = jsxClosing;
+            this.expressionBraces = expressionBraces;
+        }
+
+        @Override
+        public void restore(Lexer lexer) {
+            lexer.jsxTagCount = jsxTagCount;
+            lexer.jsxTag = jsxTag;
+            lexer.jsxClosing = jsxClosing;
+        }
+
+        @Override
+        public boolean emitRightCurly() {
+            return true;
+        }
+
+        @Override
+        public int nextStateChange() {
+            return expressionBraces;
+        }
+    }
+
+    public static class TemplateState implements InnerState {
+
+        private final boolean template;
+
+        private final boolean templateExpression;
+
+        private final int expressionBraces;
+
+        public TemplateState(boolean template, boolean templateExpression, int expressionBraces) {
+            this.template = template;
+            this.templateExpression = templateExpression;
+            this.expressionBraces = expressionBraces;
+        }
+
+        @Override
+        public void restore(Lexer lexer) {
+            lexer.template = template;
+            lexer.templateExpression = templateExpression;
+        }
+
+        @Override
+        public boolean emitRightCurly() {
+            return false;
+        }
+
+        @Override
+        public int nextStateChange() {
+            return expressionBraces;
+        }
+    }
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/Parser.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/Parser.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/Parser.java	Wed Jul 20 10:53:21 2016 +0200
@@ -27,6 +27,8 @@
 
 import static com.oracle.js.parser.TokenType.ARROW;
 import static com.oracle.js.parser.TokenType.ASSIGN;
+import static com.oracle.js.parser.TokenType.AT;
+import static com.oracle.js.parser.TokenType.AWAIT;
 import static com.oracle.js.parser.TokenType.CASE;
 import static com.oracle.js.parser.TokenType.CATCH;
 import static com.oracle.js.parser.TokenType.CLASS;
@@ -36,6 +38,7 @@
 import static com.oracle.js.parser.TokenType.CONST;
 import static com.oracle.js.parser.TokenType.DECPOSTFIX;
 import static com.oracle.js.parser.TokenType.DECPREFIX;
+import static com.oracle.js.parser.TokenType.DEFAULT;
 import static com.oracle.js.parser.TokenType.ELLIPSIS;
 import static com.oracle.js.parser.TokenType.ELSE;
 import static com.oracle.js.parser.TokenType.EOF;
@@ -61,6 +64,7 @@
 import static com.oracle.js.parser.TokenType.RPAREN;
 import static com.oracle.js.parser.TokenType.SEMICOLON;
 import static com.oracle.js.parser.TokenType.SPREAD_ARRAY;
+import static com.oracle.js.parser.TokenType.SPREAD_OBJECT;
 import static com.oracle.js.parser.TokenType.STATIC;
 import static com.oracle.js.parser.TokenType.STRING;
 import static com.oracle.js.parser.TokenType.SUPER;
@@ -101,15 +105,24 @@
 import com.oracle.js.parser.ir.DebuggerNode;
 import com.oracle.js.parser.ir.EmptyNode;
 import com.oracle.js.parser.ir.ErrorNode;
+import com.oracle.js.parser.ir.ExportClauseNode;
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ExportSpecifierNode;
 import com.oracle.js.parser.ir.Expression;
 import com.oracle.js.parser.ir.ExpressionList;
 import com.oracle.js.parser.ir.ExpressionStatement;
 import com.oracle.js.parser.ir.ForNode;
+import com.oracle.js.parser.ir.FromNode;
 import com.oracle.js.parser.ir.FunctionNode;
 import com.oracle.js.parser.ir.IdentNode;
 import com.oracle.js.parser.ir.IfNode;
+import com.oracle.js.parser.ir.ImportClauseNode;
+import com.oracle.js.parser.ir.ImportNode;
+import com.oracle.js.parser.ir.ImportSpecifierNode;
 import com.oracle.js.parser.ir.IndexNode;
 import com.oracle.js.parser.ir.JoinPredecessorExpression;
+import com.oracle.js.parser.ir.JsxAttributeNode;
+import com.oracle.js.parser.ir.JsxElementNode;
 import com.oracle.js.parser.ir.LabelNode;
 import com.oracle.js.parser.ir.LexicalContext;
 import com.oracle.js.parser.ir.LiteralNode;
@@ -117,6 +130,8 @@
 import com.oracle.js.parser.ir.Module;
 import com.oracle.js.parser.ir.Module.ExportEntry;
 import com.oracle.js.parser.ir.Module.ImportEntry;
+import com.oracle.js.parser.ir.NameSpaceImportNode;
+import com.oracle.js.parser.ir.NamedImportsNode;
 import com.oracle.js.parser.ir.Node;
 import com.oracle.js.parser.ir.ObjectNode;
 import com.oracle.js.parser.ir.PropertyKey;
@@ -154,6 +169,8 @@
     private static final String ARROW_FUNCTION_PREFIX = "=>:";
     private static final char NESTED_FUNCTION_SEPARATOR = '#';
 
+    private static final String ASYNC_IDENT = "async";
+
     private static final boolean ES6_FOR_OF = Options.getBooleanProperty("parser.for.of", true);
     private static final boolean ES6_CLASS = Options.getBooleanProperty("parser.class", true);
     private static final boolean ES6_ARROW_FUNCTION = Options.getBooleanProperty("parser.arrow.function", true);
@@ -166,6 +183,12 @@
     private static final boolean ES6_DEFAULT_PARAMETER = Options.getBooleanProperty("parser.default.parameter", true);
     private static final boolean ES6_NEW_TARGET = Options.getBooleanProperty("parser.new.target", true);
 
+    private static final boolean ES7_CLASS_FIELD = Options.getBooleanProperty("parser.class.field", true);
+    private static final boolean ES7_DECORATOR = Options.getBooleanProperty("parser.decorator", true);
+    private static final boolean ES7_ASYNC_FUNCTION = Options.getBooleanProperty("parser.async.function", true);
+    private static final boolean ES7_REST_SPREAD_PROPERTY = Options.getBooleanProperty("parser.rest.spread.property", true);
+    private static final boolean ES7_TRAILING_COMMA = Options.getBooleanProperty("parser.trailing.comma", true);
+
     /** Current env. */
     private final ScriptEnvironment env;
 
@@ -302,7 +325,7 @@
     public FunctionNode parse(final String scriptName, final int startPos, final int len, final boolean allowPropertyFunction) {
         try {
             stream = new TokenStream();
-            lexer  = new Lexer(source, startPos, len, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions, reparsedFunction != null);
+            lexer  = new Lexer(source, startPos, len, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions, reparsedFunction != null, env.jsx);
             lexer.line = lexer.pendingLine = lineOffset + 1;
             line = lineOffset;
 
@@ -330,7 +353,7 @@
     public FunctionNode parseModule(final String moduleName, final int startPos, final int len) {
         try {
             stream = new TokenStream();
-            lexer  = new Lexer(source, startPos, len, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions, reparsedFunction != null);
+            lexer  = new Lexer(source, startPos, len, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions, reparsedFunction != null, env.jsx);
             lexer.line = lexer.pendingLine = lineOffset + 1;
             line = lineOffset;
 
@@ -360,11 +383,11 @@
     public List<IdentNode> parseFormalParameterList() {
         try {
             stream = new TokenStream();
-            lexer  = new Lexer(source, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions);
+            lexer  = new Lexer(source, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions, env.jsx);
 
             scanFirstToken();
 
-            return formalParameterList(TokenType.EOF, false);
+            return formalParameterList(TokenType.EOF, false, false);
         } catch (final Exception e) {
             handleParseException(e);
             return null;
@@ -382,7 +405,7 @@
     public FunctionNode parseFunctionBody() {
         try {
             stream = new TokenStream();
-            lexer  = new Lexer(source, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions);
+            lexer  = new Lexer(source, stream, scripting && env.syntaxExtensions, env.es6, shebang && env.syntaxExtensions, env.jsx);
             final int functionLine = line;
 
             scanFirstToken();
@@ -582,12 +605,19 @@
         }
 
         // Block closing brace.
+        int realFinish;
         if (needsBraces) {
+            expectDontAdvance(RBRACE);
+            // otherwise in case block containing single braced block the inner
+            // block could end somewhere later after comments and spaces
+            realFinish = Token.descPosition(token) + Token.descLength(token);
             expect(RBRACE);
+        } else {
+            realFinish = finish;
         }
 
         final int flags = newBlock.getFlags() | (needsBraces ? 0 : Block.IS_SYNTHETIC);
-        return new Block(blockToken, Math.max(finish, Token.descPosition(blockToken)), flags, newBlock.getStatements());
+        return new Block(blockToken, Math.max(realFinish, Token.descPosition(blockToken)), flags, newBlock.getStatements());
     }
 
     /**
@@ -618,7 +648,7 @@
         // Set up new block. Captures first token.
         final ParserContextBlockNode newBlock = newBlock();
         try {
-            statement(false, false, true, labelledStatement);
+            statement(false, false, true, labelledStatement, Collections.emptyList());
         } finally {
             restoreBlock(newBlock);
         }
@@ -659,6 +689,10 @@
         return env.es6;
     }
 
+    private boolean isES7() {
+        return env.es7;
+    }
+
     private static boolean isArguments(final String name) {
         return ARGUMENTS_NAME.equals(name);
     }
@@ -895,7 +929,7 @@
 
                 try {
                     // Get the next element.
-                    statement(true, allowPropertyFunction, false, false);
+                    statement(true, allowPropertyFunction, false, false, Collections.emptyList());
                     allowPropertyFunction = false;
 
                     // check for directive prologues
@@ -1008,7 +1042,7 @@
      *     GeneratorDeclaration
      */
     private void statement() {
-        statement(false, false, false, false);
+        statement(false, false, false, false, Collections.emptyList());
     }
 
     /**
@@ -1016,7 +1050,11 @@
      * @param allowPropertyFunction allow property "get" and "set" functions?
      * @param singleStatement are we in a single statement context?
      */
-    private void statement(final boolean topLevel, final boolean allowPropertyFunction, final boolean singleStatement, final boolean labelledStatement) {
+    private void statement(final boolean topLevel, final boolean allowPropertyFunction,
+            final boolean singleStatement, final boolean labelledStatement, List<Expression> decorators) {
+        if (!decorators.isEmpty() && type != CLASS) {
+            throw error(expectMessage(CLASS));
+        }
         switch (type) {
         case LBRACE:
             block();
@@ -1079,7 +1117,7 @@
                     throw error(AbstractParser.message("expected.stmt", "function declaration"), token);
                 }
             }
-            functionExpression(true, topLevel || labelledStatement);
+            functionExpression(true, topLevel || labelledStatement, false);
             return;
         default:
             if (useBlockScope() && (type == LET && lookaheadIsLetDeclaration(false) || type == CONST)) {
@@ -1088,11 +1126,18 @@
                 }
                 variableStatement(type);
                 break;
-            } else if (ES6_CLASS && type == CLASS && isES6()) {
+            // either it is ES6 class or it starts with @something as is ES7 decorated class
+            } else if (ES6_CLASS && isES6() && (type == CLASS || (ES7_DECORATOR && isES7() && type == AT))) {
                 if (singleStatement) {
                     throw error(AbstractParser.message("expected.stmt", "class declaration"), token);
                 }
-                classDeclaration(false);
+                classDeclaration(false, decorators);
+                break;
+            // start of async function
+            } else if (ES7_ASYNC_FUNCTION && isES7() && type == IDENT && ASYNC_IDENT.equals((String) getValue(token))
+                    && lookaheadIsAsyncFunction(false)) {
+                nextOrEOL();
+                functionExpression(true, topLevel || labelledStatement, true);
                 break;
             }
             if (env.constAsVar && type == CONST) {
@@ -1101,7 +1146,7 @@
             }
 
             if (isBindingIdentifier()) {
-                if (T(k + 1) == COLON && (type != YIELD || !inGeneratorFunction())) {
+                if (T(k + 1) == COLON && (type != YIELD || !inGeneratorFunction()) && (!isAwait(token) || !inAsyncFunction())) {
                     labelStatement();
                     return;
                 }
@@ -1136,10 +1181,10 @@
      *   class BindingIdentifier[?Yield] ClassTail[?Yield]
      *   [+Default] class ClassTail[?Yield]
      */
-    private ClassNode classDeclaration(boolean isDefault) {
+    private ClassNode classDeclaration(boolean isDefault, List<Expression> exportDecorators) {
         int classLineNumber = line;
 
-        ClassNode classExpression = classExpression(!isDefault);
+        ClassNode classExpression = classExpression(!isDefault, exportDecorators);
 
         if (!isDefault) {
             VarNode classVar = new VarNode(classLineNumber, classExpression.getToken(), classExpression.getIdent().getFinish(), classExpression.getIdent(), classExpression, VarNode.IS_CONST);
@@ -1152,18 +1197,20 @@
      * ClassExpression[Yield] :
      *   class BindingIdentifier[?Yield]opt ClassTail[?Yield]
      */
-    private ClassNode classExpression(boolean isStatement) {
-        assert type == CLASS;
+    private ClassNode classExpression(boolean isStatement, List<Expression> exportDecorators) {
+        assert type == CLASS || type == AT;
         int classLineNumber = line;
         long classToken = token;
-        next();
+        List<Expression> decorators = new ArrayList<>(exportDecorators);
+        decorators.addAll(decoratorList());
+        expect(CLASS);
 
         IdentNode className = null;
         if (isStatement || type == IDENT) {
             className = getIdent();
         }
 
-        return classTail(classLineNumber, classToken, className);
+        return classTail(classLineNumber, classToken, className, decorators);
     }
 
     private static final class ClassElementKey {
@@ -1212,7 +1259,7 @@
      *   static MethodDefinition[?Yield]
      *   ;
      */
-    private ClassNode classTail(int classLineNumber, long classToken, IdentNode className) {
+    private ClassNode classTail(int classLineNumber, long classToken, IdentNode className, List<Expression> decorators) {
         boolean oldStrictMode = isStrictMode;
         isStrictMode = true;
         try {
@@ -1235,18 +1282,31 @@
                 if (type == RBRACE) {
                     break;
                 }
+
+                List<Expression> methodDecorators;
+                if (type == AT) {
+                    methodDecorators = decoratorList();
+                } else {
+                    methodDecorators = Collections.emptyList();
+                }
                 long classElementToken = token;
                 boolean isStatic = false;
                 if (type == STATIC) {
                     isStatic = true;
                     next();
                 }
+                boolean async = false;
+                if (ES7_ASYNC_FUNCTION && isES7() && type == IDENT && ASYNC_IDENT.equals((String) getValue(token))
+                        && lookaheadIsAsyncFunction(true)) {
+                    async = true;
+                    next();
+                }
                 boolean generator = false;
-                if (ES6_GENERATOR_FUNCTION && type == MUL) {
+                if (!async && ES6_GENERATOR_FUNCTION && type == MUL) {
                     generator = true;
                     next();
                 }
-                PropertyNode classElement = methodDefinition(isStatic, classHeritage != null, generator);
+                PropertyNode classElement = classElement(isStatic, classHeritage != null, generator, async, methodDecorators);
                 if (classElement.isComputed()) {
                     classElements.add(classElement);
                 } else if (!classElement.isStatic() && classElement.getKeyName().equals("constructor")) {
@@ -1294,7 +1354,7 @@
             }
 
             classElements.trimToSize();
-            return new ClassNode(classLineNumber, classToken, finish, className, classHeritage, constructor, classElements);
+            return new ClassNode(classLineNumber, classToken, finish, className, classHeritage, constructor, classElements, decorators);
         } finally {
             isStrictMode = oldStrictMode;
         }
@@ -1340,11 +1400,11 @@
                         FunctionNode.Kind.NORMAL,
                         classLineNumber,
                         body
-                        ), null, null, false, false);
+                        ), null, null, false, false, Collections.emptyList());
         return constructor;
     }
 
-    private PropertyNode methodDefinition(boolean isStatic, boolean subclass, boolean generator) {
+    private PropertyNode classElement(boolean isStatic, boolean subclass, boolean generator, boolean async, List<Expression> decorators) {
         final long methodToken = token;
         final int methodLine = line;
         final boolean computed = type == LBRACKET;
@@ -1353,14 +1413,16 @@
         int flags = FunctionNode.IS_METHOD;
         if (!computed) {
             final String name = ((PropertyKey)propertyName).getPropertyName();
-            if (!generator && isIdent && type != LPAREN && name.equals("get")) {
+            if (!generator && isIdent && type != LPAREN && name.equals("get")
+                    && (!ES7_CLASS_FIELD || !isES7() || isPropertyName(token))) {
                 PropertyFunction methodDefinition = propertyGetterFunction(methodToken, methodLine, flags);
-                verifyAllowedMethodName(methodDefinition.key, isStatic, methodDefinition.computed, generator, true);
-                return new PropertyNode(methodToken, finish, methodDefinition.key, null, methodDefinition.functionNode, null, isStatic, methodDefinition.computed);
-            } else if (!generator && isIdent && type != LPAREN && name.equals("set")) {
+                verifyAllowedMethodName(methodDefinition.key, isStatic, methodDefinition.computed, generator, async, true);
+                return new PropertyNode(methodToken, finish, methodDefinition.key, null, methodDefinition.functionNode, null, isStatic, methodDefinition.computed, decorators);
+            } else if (!generator && isIdent && type != LPAREN && name.equals("set")
+                    && (!ES7_CLASS_FIELD || !isES7() || isPropertyName(token))) {
                 PropertyFunction methodDefinition = propertySetterFunction(methodToken, methodLine, flags);
-                verifyAllowedMethodName(methodDefinition.key, isStatic, methodDefinition.computed, generator, true);
-                return new PropertyNode(methodToken, finish, methodDefinition.key, null, null, methodDefinition.functionNode, isStatic, methodDefinition.computed);
+                verifyAllowedMethodName(methodDefinition.key, isStatic, methodDefinition.computed, generator, async, true);
+                return new PropertyNode(methodToken, finish, methodDefinition.key, null, null, methodDefinition.functionNode, isStatic, methodDefinition.computed, decorators);
             } else {
                 if (!isStatic && !generator && name.equals("constructor")) {
                     flags |= FunctionNode.IS_CLASS_CONSTRUCTOR;
@@ -1368,17 +1430,54 @@
                         flags |= FunctionNode.IS_SUBCLASS_CONSTRUCTOR;
                     }
                 }
-                verifyAllowedMethodName(propertyName, isStatic, computed, generator, false);
-            }
-        }
-        PropertyFunction methodDefinition = propertyMethodFunction(propertyName, methodToken, methodLine, generator, flags, computed);
-        return new PropertyNode(methodToken, finish, methodDefinition.key, methodDefinition.functionNode, null, null, isStatic, computed);
+                if (async) {
+                    flags = FunctionNode.IS_ASYNC;
+                }
+                verifyAllowedMethodName(propertyName, isStatic, computed, generator, async, false);
+            }
+        }
+        // ClassFieldInitializer
+        if (ES7_CLASS_FIELD && isES7() && type != LPAREN && !async) {
+            // XXX decorators on properties
+            Expression assignment = null;
+            if (type == ASSIGN) {
+                next();
+                assignment = assignmentExpression(false);
+            }
+            endOfLine();
+            return new PropertyNode(methodToken, finish, propertyName, assignment, null, null, isStatic, computed, decorators);
+        }
+        PropertyFunction methodDefinition = propertyMethodFunction(propertyName, methodToken, methodLine, generator, false, flags, computed);
+        return new PropertyNode(methodToken, finish, methodDefinition.key, methodDefinition.functionNode, null, null, isStatic, computed, decorators);
+    }
+
+    /**
+     * https://github.com/wycats/javascript-decorators
+     */
+    private List<Expression> decoratorList() {
+        if (!isES7() || !ES7_DECORATOR || type != AT) {
+            return Collections.emptyList();
+        }
+        List<Expression> decorators = new ArrayList<>();
+        for (;;) {
+            next();
+            Expression decorator = leftHandSideExpression();
+            if (decorator == null) {
+                throw error(AbstractParser.message("expected.lvalue", type.getNameOrType()));
+            }
+            // FIXME https://github.com/wycats/javascript-decorators/issues/10 #2
+            decorators.add(decorator);
+            if (type != AT) {
+                break;
+            }
+        }
+        return decorators;
     }
 
     /**
      * ES6 14.5.1 Static Semantics: Early Errors.
      */
-    private void verifyAllowedMethodName(Expression key, boolean isStatic, boolean computed, boolean generator, boolean accessor) {
+    private void verifyAllowedMethodName(Expression key, boolean isStatic, boolean computed, boolean generator, boolean async, boolean accessor) {
         if (!computed) {
             if (!isStatic && generator && ((PropertyKey) key).getPropertyName().equals("constructor")) {
                 throw error(AbstractParser.message("generator.constructor"), key.getToken());
@@ -1392,6 +1491,33 @@
         }
     }
 
+    private boolean isPropertyName(long token) {
+        TokenType currentType = Token.descType(token);
+        if (ES6_COMPUTED_PROPERTY_NAME && currentType == LBRACKET && isES6()) {
+            // computed property
+            return true;
+        }
+
+        switch (currentType) {
+        case IDENT:
+            return true;
+        case OCTAL_LEGACY:
+            if (isStrictMode) {
+                return false;
+            }
+        case STRING:
+        case ESCSTRING:
+        case DECIMAL:
+        case HEXADECIMAL:
+        case OCTAL:
+        case BINARY_NUMBER:
+        case FLOATING:
+            return true;
+        default:
+            return isIdentifierName(token);
+        }
+    }
+
     /**
      * block :
      *      { StatementList? }
@@ -1445,6 +1571,9 @@
             if (tokenType != IDENT && tokenType.getKind() != TokenKind.FUTURESTRICT) {
                 throw error(expectMessage(IDENT));
             }
+            if (isModule && "await".equals(ident.getName())) {
+                throw error(AbstractParser.message("strict.name", ident.getName(), contextString), ident.getToken());
+            }
         }
     }
 
@@ -1561,7 +1690,7 @@
             final Expression binding = bindingIdentifierOrPattern(contextString);
             final boolean isDestructuring = !(binding instanceof IdentNode);
             if (isDestructuring) {
-                final int finalVarFlags = varFlags;
+                final int finalVarFlags = varFlags | VarNode.IS_DESTRUCTURING;
                 verifyDestructuringBindingPattern(binding, new Consumer<IdentNode>() {
                     public void accept(IdentNode identNode) {
                         verifyIdent(identNode, contextString);
@@ -1707,7 +1836,22 @@
 
         @Override
         public boolean enterObjectNode(ObjectNode objectNode) {
-            return true;
+            boolean restElement = false;
+            for (PropertyNode property : objectNode.getElements()) {
+                if (property != null) {
+                    if (restElement) {
+                        throw error("Unexpected element after rest element", property.getToken());
+                    }
+                    Expression value = property.getValue();
+                    if (value.isTokenType(SPREAD_OBJECT)) {
+                        restElement = true;
+                        Expression lvalue = ((UnaryNode) value).getExpression();
+                        verifySpreadElement(lvalue);
+                    }
+                    property.accept(this);
+                }
+            }
+            return false;
         }
 
         @Override
@@ -1733,7 +1877,7 @@
 
         @Override
         public boolean enterUnaryNode(UnaryNode unaryNode) {
-            if (unaryNode.isTokenType(SPREAD_ARRAY)) {
+            if (unaryNode.isTokenType(SPREAD_ARRAY) || unaryNode.isTokenType(SPREAD_OBJECT)) {
                 // rest element
                 return true;
             } else {
@@ -1807,13 +1951,13 @@
 
         ExpressionStatement expressionStatement = null;
         if (expression != null) {
+            endOfLine();
             expressionStatement = new ExpressionStatement(expressionLine, expressionToken, finish, expression);
             appendStatement(expressionStatement);
         } else {
             expect(null);
-        }
-
-        endOfLine();
+            endOfLine();
+        }
     }
 
     /**
@@ -1916,7 +2060,7 @@
                     break;
                 }
 
-                init = expression(true);
+                init = expression(true, false);
                 break;
             }
 
@@ -2342,6 +2486,18 @@
         return new UnaryNode(yieldToken, expression);
     }
 
+    private Expression awaitExpression() {
+        assert inAsyncFunction();
+        // Capture await token.
+        long awaitToken = token;
+        nextOrEOL();
+
+        Expression expression = unaryExpression();
+
+        // Construct and add AWAIT node.
+        return new UnaryNode(Token.recast(awaitToken, AWAIT), expression);
+    }
+
     private static UnaryNode newUndefinedLiteral(long token, int finish) {
         return new UnaryNode(Token.recast(token, VOID), LiteralNode.newInstance(token, finish, 0));
     }
@@ -2606,7 +2762,7 @@
                     appendStatement(catchNode);
                 } finally {
                     restoreBlock(catchBlock);
-                    catchBlocks.add(new Block(catchBlock.getToken(), finish, catchBlock.getFlags() | Block.IS_SYNTHETIC, catchBlock.getStatements()));
+                    catchBlocks.add(new Block(catchBlock.getToken(), Math.max(finish, Token.descPosition(catchBlock.getToken())), catchBlock.getFlags() | Block.IS_SYNTHETIC, catchBlock.getStatements()));
                 }
 
                 // If unconditional catch then should to be the end.
@@ -2736,7 +2892,7 @@
                     return new ExpressionList(primaryToken, finish, Collections.emptyList());
                 } else if (ES6_REST_PARAMETER && type == ELLIPSIS) {
                     // (...rest)
-                    IdentNode restParam = formalParameterList(false).get(0);
+                    IdentNode restParam = formalParameterList(false, false).get(0);
                     expectDontAdvance(RPAREN);
                     nextOrEOL();
                     expectDontAdvance(ARROW);
@@ -2744,7 +2900,7 @@
                 }
             }
 
-            final Expression expression = expression();
+            final Expression expression = expression(false, true);
 
             expect(RPAREN);
 
@@ -2754,6 +2910,9 @@
             return templateLiteral();
 
         default:
+            if (env.jsx && lexer.scanJsx(primaryToken, type)) {
+                return jsxElement(primaryToken);
+            }
             // In this context some operator tokens mark the start of a literal.
             if (lexer.scanLiteral(primaryToken, type, lineInfoReceiver)) {
                 next();
@@ -2925,7 +3084,7 @@
                     // Get and add the next property.
                     final PropertyNode property = propertyAssignment();
 
-                    if (property.isComputed()) {
+                    if (property.isComputed() || property.getKey().isTokenType(SPREAD_OBJECT)) {
                         elements.add(property);
                         break;
                     }
@@ -3082,19 +3241,29 @@
      * @return Property or reference node.
      */
     private PropertyNode propertyAssignment() {
+        final Expression propertyName;
+        final boolean isIdentifier;
+
+        List<Expression> decorators = decoratorList();
+        boolean method = ES7_DECORATOR && isES7() && !decorators.isEmpty();
+
+        boolean async = false;
+        if (ES7_ASYNC_FUNCTION && isES7() && type == IDENT && ASYNC_IDENT.equals((String) getValue(token))
+                && lookaheadIsAsyncFunction(true)) {
+            async = true;
+            next();
+        }
+        boolean generator = false;
+        if (!async && ES6_GENERATOR_FUNCTION && type == MUL && isES6()) {
+            generator = true;
+            next();
+        }
+
+        // We capture first tokens here to be consistent with classElement.
         // Capture firstToken.
         final long propertyToken = token;
         final int  functionLine  = line;
 
-        final Expression propertyName;
-        final boolean isIdentifier;
-
-        boolean generator = false;
-        if (ES6_GENERATOR_FUNCTION && type == MUL && isES6()) {
-            generator = true;
-            next();
-        }
-
         final boolean computed = type == LBRACKET;
         if (type == IDENT) {
             // Get IDENT.
@@ -3106,11 +3275,11 @@
                 switch (ident) {
                 case "get":
                     final PropertyFunction getter = propertyGetterFunction(getSetToken, functionLine);
-                    return new PropertyNode(propertyToken, finish, getter.key, null, getter.functionNode, null, false, getter.computed);
+                    return new PropertyNode(propertyToken, finish, getter.key, null, getter.functionNode, null, false, getter.computed, decorators);
 
                 case "set":
                     final PropertyFunction setter = propertySetterFunction(getSetToken, functionLine);
-                    return new PropertyNode(propertyToken, finish, setter.key, null, null, setter.functionNode, false, setter.computed);
+                    return new PropertyNode(propertyToken, finish, setter.key, null, null, setter.functionNode, false, setter.computed, decorators);
                 default:
                     break;
                 }
@@ -3122,6 +3291,16 @@
                 identNode = identNode.setIsProtoPropertyName();
             }
             propertyName = identNode;
+        } else if (type == ELLIPSIS && ES7_REST_SPREAD_PROPERTY && isES7()) {
+            if (method) {
+                // we do not allow decorators on spread property
+                throw error(AbstractParser.message("decorator.method.only"));
+            }
+            long spreadToken = Token.recast(propertyToken, TokenType.SPREAD_OBJECT);
+            next();
+            Expression assignment = new UnaryNode(spreadToken, assignmentExpression(false));
+            // FIXME start at ... or after it ?
+            return new PropertyNode(propertyToken, finish, assignment, assignment, null, null, false, false, decorators);
         } else {
             isIdentifier = isNonStrictModeIdent();
             propertyName = propertyName();
@@ -3129,12 +3308,12 @@
 
         Expression propertyValue;
 
-        if (generator) {
+        if (generator || method || async) {
             expectDontAdvance(LPAREN);
         }
 
         if (type == LPAREN && isES6()) {
-            propertyValue = propertyMethodFunction(propertyName, propertyToken, functionLine, generator, FunctionNode.IS_METHOD, computed).functionNode;
+            propertyValue = propertyMethodFunction(propertyName, propertyToken, functionLine, generator, async, FunctionNode.IS_METHOD, computed).functionNode;
         } else if (isIdentifier && (type == COMMARIGHT || type == RBRACE || type == ASSIGN) && isES6()) {
             propertyValue = createIdentNode(propertyToken, finish, ((IdentNode) propertyName).getPropertyName());
             if (type == ASSIGN && ES6_DESTRUCTURING) {
@@ -3155,7 +3334,7 @@
             }
         }
 
-        return new PropertyNode(propertyToken, finish, propertyName, propertyValue, null, null, false, computed);
+        return new PropertyNode(propertyToken, finish, propertyName, propertyValue, null, null, false, computed, decorators);
     }
 
     private PropertyFunction propertyGetterFunction(final long getSetToken, final int functionLine) {
@@ -3251,7 +3430,7 @@
         return new PropertyFunction(propertyName, function, computed);
     }
 
-    private PropertyFunction propertyMethodFunction(Expression key, final long methodToken, final int methodLine, final boolean generator, final int flags, boolean computed) {
+    private PropertyFunction propertyMethodFunction(Expression key, final long methodToken, final int methodLine, final boolean generator, final boolean async, final int flags, boolean computed) {
         final String methodName = key instanceof PropertyKey ? ((PropertyKey) key).getPropertyName() : getDefaultValidFunctionName(methodLine, false);
         final IdentNode methodNameNode = createIdentNode(((Node)key).getToken(), finish, methodName);
 
@@ -3261,6 +3440,9 @@
         if (computed) {
             functionNode.setFlag(FunctionNode.IS_ANONYMOUS);
         }
+        if (async) {
+            functionNode.setFlag(FunctionNode.IS_ASYNC);
+        }
         lc.push(functionNode);
 
         try {
@@ -3268,7 +3450,7 @@
             final List<IdentNode> parameters;
             try {
                 expect(LPAREN);
-                parameters = formalParameterList(generator);
+                parameters = formalParameterList(generator, async);
                 functionNode.setParameters(parameters);
                 expect(RPAREN);
             } finally {
@@ -3498,12 +3680,13 @@
 
         case FUNCTION:
             // Get function expression.
-            lhs = functionExpression(false, false);
+            lhs = functionExpression(false, false, false);
             break;
 
         case CLASS:
-            if (ES6_CLASS && isES6()) {
-                lhs = classExpression(false);
+        case AT:
+            if (ES6_CLASS && isES6() && (type == CLASS || (ES7_DECORATOR && isES7() && type == AT))) {
+                lhs = classExpression(false, Collections.emptyList());
                 break;
             } else {
                 // fall through
@@ -3542,6 +3725,12 @@
             }
 
         default:
+            if (ES7_ASYNC_FUNCTION && isES7() && type == IDENT && ASYNC_IDENT.equals((String) getValue(token))
+                    && lookaheadIsAsyncFunction(false)) {
+                nextOrEOL();
+                lhs = functionExpression(false, false, true);
+                break;
+            }
             // Get primary expression.
             lhs = primaryExpression();
             break;
@@ -3637,6 +3826,10 @@
             // Comma prior to every argument except the first.
             if (!first) {
                 expect(COMMARIGHT);
+                // if it was a trailing comma
+                if (ES7_TRAILING_COMMA && isES7() && type == RPAREN) {
+                    break;
+                }
             } else {
                 first = false;
             }
@@ -3688,7 +3881,7 @@
      *
      * @return Expression node.
      */
-    private Expression functionExpression(final boolean isStatement, final boolean topLevel) {
+    private Expression functionExpression(final boolean isStatement, final boolean topLevel, final boolean async) {
         final long functionToken = token;
         final int  functionLine  = line;
         // FUNCTION is tested in caller.
@@ -3710,6 +3903,9 @@
                 // HoistableDeclaration with BindingIdentifier yield in generator function body
                 expect(IDENT);
             }
+            if (isAwait(token) && ((!isStatement && async) || (isStatement && inAsyncFunction()))) {
+                expect(IDENT);
+            }
             name = getIdent();
             verifyIdent(name, "function name");
         } else if (isStatement) {
@@ -3734,6 +3930,9 @@
         FunctionNode.Kind functionKind = generator ? FunctionNode.Kind.GENERATOR : FunctionNode.Kind.NORMAL;
         List<IdentNode> parameters = Collections.emptyList();
         final ParserContextFunctionNode functionNode = createParserContextFunctionNode(name, functionToken, functionKind, functionLine, parameters);
+        if (async) {
+            functionNode.setFlag(FunctionNode.IS_ASYNC);
+        }
         lc.push(functionNode);
 
         Block functionBody = null;
@@ -3744,7 +3943,7 @@
             ParserContextBlockNode parameterBlock = newBlock();
             try {
                 expect(LPAREN);
-                parameters = formalParameterList(generator);
+                parameters = formalParameterList(generator, async);
                 functionNode.setParameters(parameters);
                 expect(RPAREN);
             } finally {
@@ -3760,6 +3959,7 @@
         }
 
         if (isStatement) {
+            functionNode.setFlag(FunctionNode.IS_STATEMENT);
             if (topLevel || useBlockScope() || (!isStrictMode && env.functionDeclarationHoisting && env.functionStatement == ScriptEnvironment.FunctionStatementBehavior.ACCEPT)) {
                 functionNode.setFlag(FunctionNode.IS_DECLARED);
             } else if (isStrictMode) {
@@ -3907,8 +4107,8 @@
      * Parse function parameter list.
      * @return List of parameter nodes.
      */
-    private List<IdentNode> formalParameterList(final boolean yield) {
-        return formalParameterList(RPAREN, yield);
+    private List<IdentNode> formalParameterList(final boolean yield, final boolean await) {
+        return formalParameterList(RPAREN, yield, await);
     }
 
     /**
@@ -3924,7 +4124,8 @@
      * Parse function parameter list.
      * @return List of parameter nodes.
      */
-    private List<IdentNode> formalParameterList(final TokenType endType, final boolean yield) {
+    private List<IdentNode> formalParameterList(final TokenType endType, final boolean yield, final boolean await) {
+        assert endType != COMMARIGHT;
         // Prepare to gather parameters.
         final ArrayList<IdentNode> parameters = new ArrayList<>();
         // Track commas.
@@ -3934,6 +4135,10 @@
             // Comma prior to every argument except the first.
             if (!first) {
                 expect(COMMARIGHT);
+                // if it was a trailing comma
+                if (ES7_TRAILING_COMMA && isES7() && type == endType) {
+                    break;
+                }
             } else {
                 first = false;
             }
@@ -3944,7 +4149,7 @@
                 restParameter = true;
             }
 
-            if (type == YIELD && yield) {
+            if (type == YIELD && yield || isAwait(token) && await) {
                 expect(IDENT);
             }
 
@@ -3965,7 +4170,7 @@
                     next();
                     ident = ident.setIsDefaultParameter();
 
-                    if (type == YIELD && yield) {
+                    if (type == YIELD && yield || isAwait(token) && await) {
                         // error: yield in default expression
                         expect(IDENT);
                     }
@@ -4031,7 +4236,8 @@
                 ParserContextFunctionNode currentFunction = lc.getCurrentFunction();
                 if (currentFunction != null) {
                     // declare function-scope variables for destructuring bindings
-                    lc.getFunctionBody(currentFunction).appendStatement(new VarNode(paramLine, Token.recast(paramToken, VAR), pattern.getFinish(), identNode, null));
+                    lc.getFunctionBody(currentFunction).appendStatement(
+                            new VarNode(paramLine, Token.recast(paramToken, VAR), pattern.getFinish(), identNode, null).setFlag(VarNode.IS_DESTRUCTURING));
                     // detect duplicate bounds names in parameter list
                     currentFunction.addParameterBinding(identNode);
                     currentFunction.setSimpleParameterList(false);
@@ -4197,7 +4403,7 @@
         }
 
         stream.reset();
-        lexer = parserState.createLexer(source, lexer, stream, scripting && env.syntaxExtensions, env.es6, shebang);
+        lexer = parserState.createLexer(source, lexer, stream, scripting && env.syntaxExtensions, env.es6, shebang, env.jsx);
         line = parserState.line;
         linePosition = parserState.linePosition;
         // Doesn't really matter, but it's safe to treat it as if there were a semicolon before
@@ -4223,8 +4429,8 @@
             this.linePosition = linePosition;
         }
 
-        Lexer createLexer(final Source source, final Lexer lexer, final TokenStream stream, final boolean scripting, final boolean es6, final boolean shebang) {
-            final Lexer newLexer = new Lexer(source, position, lexer.limit - position, stream, scripting, es6, shebang, true);
+        Lexer createLexer(final Source source, final Lexer lexer, final TokenStream stream, final boolean scripting, final boolean es6, final boolean shebang, final boolean jsx) {
+            final Lexer newLexer = new Lexer(source, position, lexer.limit - position, stream, scripting, es6, shebang, true, jsx);
             newLexer.restoreState(new Lexer.State(position, Integer.MAX_VALUE, line, -1, linePosition, SEMICOLON));
             return newLexer;
         }
@@ -4330,6 +4536,9 @@
             return verifyIncDecExpression(unaryToken, opType, lhs, false);
 
         default:
+            if (isAwait(token) && ES7_ASYNC_FUNCTION && inAsyncFunction() && isES7()) {
+                return awaitExpression();
+            }
             break;
         }
 
@@ -4480,14 +4689,18 @@
         // at expression start point!
 
         // Include commas in expression parsing.
-        return expression(false);
+        return expression(false, false);
     }
 
-    private Expression expression(final boolean noIn) {
+    private Expression expression(final boolean noIn, boolean parenthesized) {
         Expression assignmentExpression = assignmentExpression(noIn);
         while (type == COMMARIGHT) {
             long commaToken = token;
             next();
+            if (ES7_TRAILING_COMMA && isES7() && parenthesized && type == RPAREN) {
+                // allow trailing comma
+                break;
+            }
 
             boolean rhsRestParameter = false;
             if (ES6_ARROW_FUNCTION && ES6_REST_PARAMETER && type == ELLIPSIS && isES6()) {
@@ -4598,7 +4811,37 @@
 
         final long startToken = token;
         final int startLine = line;
-        final Expression exprLhs = conditionalExpression(noIn);
+        final int pos = k;
+        Expression exprLhs = conditionalExpression(noIn);
+
+        boolean asyncArrow = false;
+        if (ES7_ASYNC_FUNCTION && isES7()) {
+            // FIXME do we have a better way
+            if ((exprLhs instanceof IdentNode) && ASYNC_IDENT.equals(((IdentNode) exprLhs).getName())) {
+                if (isNonStrictModeIdent() || type == IDENT) {
+                    boolean containsEol = false;
+                    for (int i = pos + 1; i < k; i++) {
+                        TokenType t = T(i);
+                        if (t != COMMENT) {
+                            containsEol = true;
+                            break;
+                        }
+                    }
+                    if (!containsEol) {
+                        // async arrow function with one parameter such as "async x => {x}"
+                        asyncArrow = true;
+                        exprLhs = conditionalExpression(noIn);
+                    }
+                }
+            }
+
+            if (!asyncArrow && (exprLhs instanceof CallNode) && type == ARROW) {
+                 Expression function = ((CallNode) exprLhs).getFunction();
+                 if ((function instanceof IdentNode) && ASYNC_IDENT.equals(((IdentNode) function).getName())) {
+                     asyncArrow = true;
+                 }
+            }
+        }
 
         if (ES6_ARROW_FUNCTION && type == ARROW && isES6()) {
             if (checkNoLineTerminator()) {
@@ -4608,7 +4851,7 @@
                 } else {
                     paramListExpr = exprLhs;
                 }
-                return arrowFunction(startToken, startLine, paramListExpr);
+                return arrowFunction(startToken, startLine, paramListExpr, asyncArrow);
             }
         }
         assert !(exprLhs instanceof ExpressionList);
@@ -4647,7 +4890,7 @@
      * @param functionLine start line of the arrow function
      * @param paramListExpr ArrowParameters expression or {@code null} for {@code ()} (empty list)
      */
-    private Expression arrowFunction(final long startToken, final int functionLine, final Expression paramListExpr) {
+    private Expression arrowFunction(final long startToken, final int functionLine, final Expression paramListExpr, boolean async) {
         // caller needs to check that there's no LineTerminator between parameter list and arrow
         assert type != ARROW || checkNoLineTerminator();
         expect(ARROW);
@@ -4656,13 +4899,16 @@
         final IdentNode name = new IdentNode(functionToken, Token.descPosition(functionToken), ARROW_FUNCTION_PREFIX + functionLine);
         final ParserContextFunctionNode functionNode = createParserContextFunctionNode(name, functionToken, FunctionNode.Kind.ARROW, functionLine, null);
         functionNode.setFlag(FunctionNode.IS_ANONYMOUS);
+        if (async) {
+            functionNode.setFlag(FunctionNode.IS_ASYNC);
+        }
 
         lc.push(functionNode);
         try {
             ParserContextBlockNode parameterBlock = newBlock();
             final List<IdentNode> parameters;
             try {
-                parameters = convertArrowFunctionParameterList(paramListExpr, functionLine);
+                parameters = convertArrowFunctionParameterList(paramListExpr, functionLine, async);
                 functionNode.setParameters(parameters);
 
                 if (!functionNode.isSimpleParameterList()) {
@@ -4713,7 +4959,7 @@
         }
     }
 
-    private List<IdentNode> convertArrowFunctionParameterList(Expression paramListExpr, int functionLine) {
+    private List<IdentNode> convertArrowFunctionParameterList(Expression paramListExpr, int functionLine, boolean async) {
         List<IdentNode> parameters;
         if (paramListExpr == null) {
             // empty parameter list, i.e. () =>
@@ -4729,6 +4975,11 @@
                 car = ((BinaryNode) car).lhs();
             } while (car instanceof BinaryNode && Token.descType(car.getToken()) == COMMARIGHT);
             parameters.add(0, verifyArrowParameter(car, parameters.size(), functionLine));
+        } else if (paramListExpr instanceof CallNode && async) {
+            parameters = new ArrayList<>();
+            for (Expression param : ((CallNode) paramListExpr).getArgs()) {
+                parameters.add(verifyArrowParameter(param, parameters.size(), functionLine));
+            }
         } else {
             throw error(AbstractParser.message("expected.arrow.parameter"), paramListExpr.getToken());
         }
@@ -4975,8 +5226,10 @@
      */
     private FunctionNode module(final String moduleName) {
         boolean oldStrictMode = isStrictMode;
+        boolean oldModule = isModule;
         try {
             isStrictMode = true; // Module code is always strict mode code. (ES6 10.2.1)
+            isModule = true;
 
             // Make a pseudo-token for the script holding its start and length.
             int functionStart = Math.min(Token.descPosition(Token.withDelimiter(token)), finish);
@@ -5014,6 +5267,7 @@
             script.setModule(module.createModule());
             return createFunctionNode(script, functionToken, ident, Collections.<IdentNode>emptyList(), FunctionNode.Kind.MODULE, functionLine, programBody);
         } finally {
+            isModule = oldModule;
             isStrictMode = oldStrictMode;
         }
     }
@@ -5034,19 +5288,30 @@
      *      StatementListItem
      */
     private void moduleBody() {
+        // FIXME this decorator handling is not described in spec
+        // yet certain frameworks uses it this way
+        List<Expression> decorators = new ArrayList<>();
         loop: while (type != EOF) {
             switch (type) {
             case EOF:
                 break loop;
             case IMPORT:
                 importDeclaration();
+                decorators.clear();
                 break;
             case EXPORT:
-                exportDeclaration();
+                exportDeclaration(decorators);
+                decorators.clear();
                 break;
+            case AT:
+                if (ES7_DECORATOR && isES7()) {
+                    decorators.addAll(decoratorList());
+                    break;
+                }
             default:
                 // StatementListItem
-                statement(true, false, false, false);
+                statement(true, false, false, false, decorators);
+                decorators.clear();
                 break;
             }
         }
@@ -5073,20 +5338,30 @@
      *     BindingIdentifier
      */
     private void importDeclaration() {
+        final long importToken = token;
         expect(IMPORT);
         ParserContextModuleNode module = lc.getCurrentModule();
         if (type == STRING || type == ESCSTRING) {
             // import ModuleSpecifier ;
             String moduleSpecifier = (String) getValue();
+            LiteralNode<String> specifier = LiteralNode.newInstance(token, finish, moduleSpecifier);
             next();
             module.addModuleRequest(moduleSpecifier);
+            module.addImport(new ImportNode(importToken, Token.descPosition(importToken), finish, specifier));
         } else {
             // import ImportClause FromClause ;
             List<ImportEntry> importEntries;
+            ImportClauseNode importClause;
+            final long startToken = token;
             if (type == MUL) {
-                importEntries = Collections.singletonList(nameSpaceImport());
+                NameSpaceImportNode namespaceNode = nameSpaceImport();
+                importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, namespaceNode);
+                importEntries = Collections.singletonList(
+                        ImportEntry.importStarAsNameSpaceFrom(namespaceNode.getBindingIdentifier().getName()));
             } else if (type == LBRACE) {
-                importEntries = namedImports();
+                NamedImportsNode namedImportsNode = namedImports();
+                importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, namedImportsNode);
+                importEntries = convert(namedImportsNode);
             } else if (isBindingIdentifier()) {
                 // ImportedDefaultBinding
                 IdentNode importedDefaultBinding = bindingIdentifier("ImportedBinding");
@@ -5094,16 +5369,23 @@
 
                 if (type == COMMARIGHT) {
                     next();
-                    importEntries = new ArrayList<>();
                     if (type == MUL) {
-                        importEntries.add(nameSpaceImport());
+                        NameSpaceImportNode namespaceNode = nameSpaceImport();
+                        importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, importedDefaultBinding, namespaceNode);
+                        importEntries = new ArrayList<>(2);
+                        importEntries.add(defaultImport);
+                        importEntries.add(ImportEntry.importStarAsNameSpaceFrom(namespaceNode.getBindingIdentifier().getName()));
                     } else if (type == LBRACE) {
-                        importEntries.addAll(namedImports());
+                        NamedImportsNode namedImportsNode = namedImports();
+                        importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, importedDefaultBinding, namedImportsNode);
+                        importEntries = convert(namedImportsNode);
+                        importEntries.add(0, defaultImport);
                     } else {
                         // expected NameSpaceImport or NamedImports
                         throw error(AbstractParser.message("expected.named.import"));
                     }
                 } else {
+                    importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, importedDefaultBinding);
                     importEntries = Collections.singletonList(defaultImport);
                 }
             } else {
@@ -5111,13 +5393,15 @@
                 throw error(AbstractParser.message("expected.import"));
             }
 
-            String moduleSpecifier = fromClause();
+            FromNode fromNode = fromClause();
+            module.addImport(new ImportNode(importToken, Token.descPosition(importToken), finish, importClause, fromNode));
+            String moduleSpecifier = fromNode.getModuleSpecifier().getValue();
             module.addModuleRequest(moduleSpecifier);
             for (int i = 0; i < importEntries.size(); i++) {
                 module.addImportEntry(importEntries.get(i).withFrom(moduleSpecifier));
             }
         }
-        expect(SEMICOLON);
+        endOfLine();
     }
 
     /**
@@ -5126,7 +5410,8 @@
      *
      * @return imported binding identifier
      */
-    private ImportEntry nameSpaceImport() {
+    private NameSpaceImportNode nameSpaceImport() {
+        final long startToken = token;
         assert type == MUL;
         next();
         long asToken = token;
@@ -5135,7 +5420,7 @@
             throw error(AbstractParser.message("expected.as"), asToken);
         }
         IdentNode localNameSpace = bindingIdentifier("ImportedBinding");
-        return ImportEntry.importStarAsNameSpaceFrom(localNameSpace.getName());
+        return new NameSpaceImportNode(startToken, Token.descPosition(startToken), finish, localNameSpace);
     }
 
     /**
@@ -5152,10 +5437,11 @@
      * ImportedBinding :
      *     BindingIdentifier
      */
-    private List<ImportEntry> namedImports() {
+    private NamedImportsNode namedImports() {
+        final long startToken = token;
         assert type == LBRACE;
         next();
-        List<ImportEntry> importEntries = new ArrayList<>();
+        List<ImportSpecifierNode> importSpecifiers = new ArrayList<>();
         while (type != RBRACE) {
             boolean bindingIdentifier = isBindingIdentifier();
             long nameToken = token;
@@ -5163,12 +5449,14 @@
             if (type == IDENT && "as".equals(getValue())) {
                 next();
                 IdentNode localName = bindingIdentifier("ImportedBinding");
-                importEntries.add(ImportEntry.importSpecifier(importName.getName(), localName.getName()));
+                importSpecifiers.add(new ImportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, localName, importName));
+                //importEntries.add(ImportEntry.importSpecifier(importName.getName(), localName.getName()));
             } else if (!bindingIdentifier) {
                 // expected BindingIdentifier
                 throw error(AbstractParser.message("expected.binding.identifier"), nameToken);
             } else {
-                importEntries.add(ImportEntry.importSpecifier(importName.getName()));
+                importSpecifiers.add(new ImportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, importName, null));
+                //importEntries.add(ImportEntry.importSpecifier(importName.getName()));
             }
             if (type == COMMARIGHT) {
                 next();
@@ -5177,14 +5465,15 @@
             }
         }
         expect(RBRACE);
-        return importEntries;
+        return new NamedImportsNode(startToken, Token.descPosition(startToken), finish, importSpecifiers);
     }
 
     /**
      * FromClause :
      *     from ModuleSpecifier
      */
-    private String fromClause() {
+    private FromNode fromClause() {
+        int fromStart = start;
         long fromToken = token;
         String name = (String) expectValue(IDENT);
         if (!"from".equals(name)) {
@@ -5192,8 +5481,9 @@
         }
         if (type == STRING || type == ESCSTRING) {
             String moduleSpecifier = (String) getValue();
+            LiteralNode<String> specifier = LiteralNode.newInstance(token, finish, moduleSpecifier);
             next();
-            return moduleSpecifier;
+            return new FromNode(fromToken, fromStart, finish, specifier);
         } else {
             throw error(expectMessage(STRING));
         }
@@ -5212,36 +5502,54 @@
      *     export default ClassDeclaration[Default]
      *     export default [lookahead !in {function, class}] AssignmentExpression[In] ;
      */
-    private void exportDeclaration() {
+    private void exportDeclaration(List<Expression> decorators) {
+        final long exportToken = token;
         expect(EXPORT);
         ParserContextModuleNode module = lc.getCurrentModule();
+        if (!decorators.isEmpty() && type != DEFAULT && type != CLASS && type != AT) {
+            throw error(expectMessage(CLASS));
+        }
+
         switch (type) {
             case MUL: {
                 next();
-                String moduleRequest = fromClause();
-                expect(SEMICOLON);
+                FromNode from = fromClause();
+                String moduleRequest = from.getModuleSpecifier().getValue();
                 module.addModuleRequest(moduleRequest);
                 module.addStarExportEntry(ExportEntry.exportStarFrom(moduleRequest));
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, from));
+                endOfLine();
                 break;
             }
             case LBRACE: {
-                List<ExportEntry> exportEntries = exportClause();
+                ExportClauseNode exportClause = exportClause();
                 if (type == IDENT && "from".equals(getValue())) {
-                    String moduleRequest = fromClause();
+                    FromNode from = fromClause();
+                    module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, exportClause, from));
+                    String moduleRequest = from.getModuleSpecifier().getValue();
                     module.addModuleRequest(moduleRequest);
+                    List<ExportEntry> exportEntries = convert(exportClause);
                     for (int i = 0; i < exportEntries.size(); i++) {
                         module.addIndirectExportEntry(exportEntries.get(i).withFrom(moduleRequest));
                     }
                 } else {
+                    for (ExportSpecifierNode specifier : exportClause.getExportSpecifiers()) {
+                        verifyIdent(specifier.getIdentifier(), "ExportedBinding");
+                    }
+                    module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, exportClause));
+                    List<ExportEntry> exportEntries = convert(exportClause);
                     for (int i = 0; i < exportEntries.size(); i++) {
                         module.addLocalExportEntry(exportEntries.get(i));
                     }
                 }
-                expect(SEMICOLON);
+                endOfLine();
                 break;
             }
             case DEFAULT:
                 next();
+                if (!decorators.isEmpty() && type != AT && type != CLASS) {
+                    throw error(expectMessage(CLASS));
+                }
                 Expression assignmentExpression;
                 IdentNode ident;
                 int lineNumber = line;
@@ -5249,28 +5557,40 @@
                 boolean declaration;
                 switch (type) {
                     case FUNCTION:
-                        assignmentExpression = functionExpression(false, true);
+                        assignmentExpression = functionExpression(false, true, false);
                         ident = ((FunctionNode) assignmentExpression).getIdent();
                         declaration = true;
                         break;
+                    // this is according to current decorator spec
                     case CLASS:
-                        assignmentExpression = classDeclaration(true);
+                    case AT:
+                        assignmentExpression = classDeclaration(true, decorators);
                         ident = ((ClassNode) assignmentExpression).getIdent();
                         declaration = true;
                         break;
                     default:
+                        if (ES7_ASYNC_FUNCTION && isES7() && type == IDENT && ASYNC_IDENT.equals((String) getValue(token))
+                                && lookaheadIsAsyncFunction(false)) {
+                            nextOrEOL();
+                            assignmentExpression = functionExpression(false, true, true);
+                            ident = ((FunctionNode) assignmentExpression).getIdent();
+                            declaration = true;
+                            break;
+                        }
                         assignmentExpression = assignmentExpression(false);
                         ident = null;
                         declaration = false;
                         break;
                 }
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, assignmentExpression, true));
                 if (ident != null) {
                     module.addLocalExportEntry(ExportEntry.exportDefault(ident.getName()));
                 } else {
                     ident = createIdentNode(Token.recast(rhsToken, IDENT), finish, Module.DEFAULT_EXPORT_BINDING_NAME);
-                    lc.appendStatementToCurrentNode(new VarNode(lineNumber, Token.recast(rhsToken, LET), finish, ident, assignmentExpression));
+                    lc.appendStatementToCurrentNode(new VarNode(lineNumber, Token.recast(rhsToken, LET), finish, ident, assignmentExpression)
+                            .setFlag(VarNode.IS_EXPORT));
                     if (!declaration) {
-                        expect(SEMICOLON);
+                        endOfLine();
                     }
                     module.addLocalExportEntry(ExportEntry.exportDefault());
                 }
@@ -5283,21 +5603,34 @@
                 variableStatement(type);
                 for (Statement statement : statements.subList(previousEnd, statements.size())) {
                     if (statement instanceof VarNode) {
+                        module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, (VarNode) statement));
                         module.addLocalExportEntry(ExportEntry.exportSpecifier(((VarNode) statement).getName().getName()));
                     }
                 }
                 break;
-            case CLASS: {
-                ClassNode classDeclaration = classDeclaration(false);
+            // this is according to current decorator spec
+            case CLASS:
+            case AT: {
+                ClassNode classDeclaration = classDeclaration(false, decorators);
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, classDeclaration, false));
                 module.addLocalExportEntry(ExportEntry.exportSpecifier(classDeclaration.getIdent().getName()));
                 break;
             }
             case FUNCTION: {
-                FunctionNode functionDeclaration = (FunctionNode) functionExpression(true, true);
+                FunctionNode functionDeclaration = (FunctionNode) functionExpression(true, true, false);
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, functionDeclaration, false));
                 module.addLocalExportEntry(ExportEntry.exportSpecifier(functionDeclaration.getIdent().getName()));
                 break;
             }
             default:
+                if (ES7_ASYNC_FUNCTION && isES7() && type == IDENT && ASYNC_IDENT.equals((String) getValue(token))
+                        && lookaheadIsAsyncFunction(false)) {
+                    nextOrEOL();
+                    FunctionNode functionDeclaration = (FunctionNode) functionExpression(true, true, true);
+                    module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, functionDeclaration, false));
+                    module.addLocalExportEntry(ExportEntry.exportSpecifier(functionDeclaration.getIdent().getName()));
+                    break;
+                }
                 throw error(AbstractParser.message("invalid.export"), token);
         }
     }
@@ -5316,18 +5649,22 @@
      *
      * @return a list of ExportSpecifiers
      */
-    private List<ExportEntry> exportClause() {
+    private ExportClauseNode exportClause() {
+        final long startToken = token;
         assert type == LBRACE;
         next();
-        List<ExportEntry> exports = new ArrayList<>();
+        List<ExportSpecifierNode> exports = new ArrayList<>();
         while (type != RBRACE) {
+            long nameToken = token;
             IdentNode localName = getIdentifierName();
             if (type == IDENT && "as".equals(getValue())) {
                 next();
                 IdentNode exportName = getIdentifierName();
-                exports.add(ExportEntry.exportSpecifier(exportName.getName(), localName.getName()));
+                exports.add(new ExportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, localName, exportName));
+                //exports.add(ExportEntry.exportSpecifier(exportName.getName(), localName.getName()));
             } else {
-                exports.add(ExportEntry.exportSpecifier(localName.getName()));
+                exports.add(new ExportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, localName, null));
+                //exports.add(ExportEntry.exportSpecifier(localName.getName()));
             }
             if (type == COMMARIGHT) {
                 next();
@@ -5336,7 +5673,153 @@
             }
         }
         expect(RBRACE);
-        return exports;
+        return new ExportClauseNode(startToken, Token.descPosition(startToken), finish, exports);
+    }
+
+    private Expression jsxElement(long startToken) {
+        long realStart = startToken;
+        if (Token.descType(realStart) == TokenType.LT) {
+            realStart = Token.recast(realStart, TokenType.JSX_ELEM_START);
+        }
+        assert Token.descType(realStart) == TokenType.JSX_ELEM_START;
+        next();
+
+        String name = jsxElementName();
+
+        if (type == TokenType.JSX_ELEM_CLOSE) {
+            next();
+            expect(TokenType.JSX_ELEM_END);
+            return new JsxElementNode(name, Collections.emptyList(), Collections.emptyList(), realStart, finish);
+        }
+
+        // parse attributes
+        List<Expression> attributes = new ArrayList<>();
+        for (;;) {
+            Expression attribute = jsxAttribute();
+            if (attribute == null) {
+                break;
+            } else {
+                attributes.add(attribute);
+            }
+        }
+
+        boolean closed = false;
+        if (type == TokenType.JSX_ELEM_CLOSE) {
+            next();
+            closed = true;
+        }
+        expect(TokenType.JSX_ELEM_END);
+        if (closed) {
+            return new JsxElementNode(name, attributes, Collections.emptyList(), realStart, finish);
+        }
+
+        // parse children
+        List<Expression> children = new ArrayList<>();
+        children:
+        for (;;)
+            switch (type) {
+                case JSX_TEXT:
+                    long textStart = token;
+                    String text = (String) getValue(token);
+                    children.add(LiteralNode.newInstance(textStart, finish, text));
+                    next();
+                    break;
+                case JSX_ELEM_START:
+                    if (T(k + 1) == TokenType.JSX_ELEM_CLOSE) {
+                        next();
+                        next();
+                        String endName = jsxElementName();
+                        if (!endName.equals(name)) {
+                            throw error(AbstractParser.message("expected.jsx.name.mismatch", name, endName));
+                        }
+                        expect(TokenType.JSX_ELEM_END);
+                        break children;
+                    } else {
+                        children.add(jsxElement(token));
+                    }
+                    break;
+                case LBRACE:
+                    if (T(k + 1) == TokenType.RBRACE) {
+                        next();
+                        next();
+                    } else {
+                        next();
+                        children.add(assignmentExpression(false));
+                        expect(RBRACE);
+                    }
+                    break;
+                default:
+                    throw error(AbstractParser.message("expected.jsx.child", type.getNameOrType()));
+        }
+        return new JsxElementNode(name, attributes, children, realStart, finish);
+    }
+
+    private Expression jsxAttribute() {
+        Expression attribute = null;
+        if (type == LBRACE) {
+            next();
+            expect(ELLIPSIS);
+            // FIXME noin?
+            attribute = new UnaryNode(Token.recast(token, SPREAD_OBJECT), assignmentExpression(false));
+            expect(RBRACE);
+        } else if (type == TokenType.JSX_IDENTIFIER) {
+            long attrToken = token;
+            // attribute
+            StringBuilder attrName = new StringBuilder((String) getValue(token));
+            next();
+            if (type == TokenType.COLON) {
+                expectDontAdvance(TokenType.JSX_IDENTIFIER);
+                attrName.append(":").append((String) getValue(token));
+                next();
+            }
+            Expression value = null;
+            if (type == TokenType.ASSIGN) {
+                next();
+                switch (type) {
+                    case JSX_STRING:
+                        long textStart = token;
+                        String text = (String) getValue(token);
+                        value = LiteralNode.newInstance(textStart, finish, text);
+                        next();
+                        break;
+                    case LBRACE:
+                        next();
+                        value = assignmentExpression(false);
+                        expect(RBRACE);
+                        break;
+                    case JSX_ELEM_START:
+                        value = jsxElement(token);
+                        break;
+                    default:
+                        throw error(AbstractParser.message("expected.jsx.attribute", type.getNameOrType()));
+                }
+            }
+            attribute = new JsxAttributeNode(attrName.toString(), value, attrToken, finish);
+        }
+        return attribute;
+    }
+
+    private String jsxElementName() {
+        expectDontAdvance(TokenType.JSX_IDENTIFIER);
+        StringBuilder name = new StringBuilder((String) getValue(token));
+        next();
+        if (type == TokenType.COLON) {
+            next();
+            expectDontAdvance(TokenType.JSX_IDENTIFIER);
+            name.append(":").append((String) getValue(token));
+            next();
+        } else if (type == TokenType.PERIOD) {
+            for (;;) {
+                next();
+                expectDontAdvance(TokenType.JSX_IDENTIFIER);
+                name.append(".").append((String) getValue(token));
+                next();
+                if (type != TokenType.PERIOD) {
+                    break;
+                }
+            }
+        }
+        return name.toString();
     }
 
     @Override
@@ -5428,4 +5911,54 @@
     private boolean inGeneratorFunction() {
         return lc.getCurrentFunction().getKind() == FunctionNode.Kind.GENERATOR;
     }
+
+    private boolean inAsyncFunction() {
+        return lc.getCurrentFunction().isAsync();
+    }
+
+    private boolean isAwait(long token) {
+        return Token.descType(token) == IDENT && "await".equals((String) getValue(token)); 
+    }
+
+    private boolean lookaheadIsAsyncFunction(boolean method) {
+        assert type == IDENT && ASYNC_IDENT.equals((String) getValue(token));
+        for (int i = 1;; i++) {
+            long token = getToken(k + i);
+            TokenType t = Token.descType(token);
+            switch (t) {
+            case COMMENT:
+                continue;
+            case FUNCTION:
+                return !method;
+            case EOL:
+                return false;
+            default:
+                return method && isPropertyName(token);
+            }
+        }
+    }
+
+    private static List<ImportEntry> convert(NamedImportsNode namedImportsNode) {
+        List<ImportEntry> importEntries = new ArrayList<>(namedImportsNode.getImportSpecifiers().size());
+        for (ImportSpecifierNode s : namedImportsNode.getImportSpecifiers()) {
+            if (s.getIdentifier() != null) {
+                importEntries.add(ImportEntry.importSpecifier(s.getIdentifier().getName(), s.getBindingIdentifier().getName()));
+            } else {
+                importEntries.add(ImportEntry.importSpecifier(s.getBindingIdentifier().getName()));
+            }
+        }
+        return importEntries;
+    }
+
+    private static List<ExportEntry> convert(ExportClauseNode exportClauseNode) {
+        List<ExportEntry> exports = new ArrayList<>(exportClauseNode.getExportSpecifiers().size());
+        for (ExportSpecifierNode s : exportClauseNode.getExportSpecifiers()) {
+            if (s.getExportIdentifier() != null) {
+                exports.add(ExportEntry.exportSpecifier(s.getExportIdentifier().getName(), s.getIdentifier().getName()));
+            } else {
+                exports.add(ExportEntry.exportSpecifier(s.getIdentifier().getName()));
+            }
+        }
+        return exports;
+    }
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextFunctionNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextFunctionNode.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextFunctionNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -264,4 +264,8 @@
     public void setModule(Module module) {
         this.module = module;
     }
+
+    public boolean isAsync() {
+        return getFlag(FunctionNode.IS_ASYNC) != 0;
+    }
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextModuleNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextModuleNode.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextModuleNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -24,6 +24,8 @@
  */
 package com.oracle.js.parser;
 
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ImportNode;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -45,6 +47,9 @@
     private List<ExportEntry> indirectExportEntries = new ArrayList<>();
     private List<ExportEntry> starExportEntries = new ArrayList<>();
 
+    private List<ImportNode> imports = new ArrayList<>();
+    private List<ExportNode> exports = new ArrayList<>();
+
     /**
      * Constructor.
      *
@@ -63,6 +68,14 @@
         return name;
     }
 
+    public void addImport(ImportNode importNode) {
+        imports.add(importNode);
+    }
+
+    public void addExport(ExportNode exportNode) {
+        exports.add(exportNode);
+    }
+
     public void addModuleRequest(String moduleRequest) {
         requestedModules.add(moduleRequest);
     }
@@ -84,6 +97,6 @@
     }
 
     public Module createModule() {
-        return new Module(requestedModules, importEntries, localExportEntries, indirectExportEntries, starExportEntries);
+        return new Module(requestedModules, importEntries, localExportEntries, indirectExportEntries, starExportEntries, imports, exports);
     }
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ScriptEnvironment.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ScriptEnvironment.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ScriptEnvironment.java	Wed Jul 20 10:53:21 2016 +0200
@@ -52,6 +52,12 @@
     /** Enable ECMAScript 6 features. */
     final boolean es6;
 
+    /** Enable ECMAScript 7 features. */
+    final boolean es7;
+
+    /** Enable JSX extension. */
+    final boolean jsx;
+
     /**
      * Behavior when encountering a function declaration in a lexical context where only statements
      * are acceptable (function declarations are source elements, but not statements).
@@ -93,7 +99,7 @@
 
     final boolean functionDeclarationHoisting;
 
-    private ScriptEnvironment(boolean strict, boolean es6, boolean earlyLvalueError, boolean emptyStatements, boolean syntaxExtensions, boolean scripting, boolean shebang, boolean constAsVar,
+    private ScriptEnvironment(boolean strict, boolean es6, boolean es7, boolean jsx, boolean earlyLvalueError, boolean emptyStatements, boolean syntaxExtensions, boolean scripting, boolean shebang, boolean constAsVar,
                     boolean functionDeclarationHoisting, FunctionStatementBehavior functionStatementBehavior, PrintWriter dumpOnError) {
         this.namespace = new Namespace();
         this.err = dumpOnError;
@@ -108,6 +114,8 @@
         this.scripting = scripting;
         this.shebang = shebang;
         this.es6 = es6;
+        this.es7 = es7;
+        this.jsx = jsx;
         this.functionDeclarationHoisting = functionDeclarationHoisting;
     }
 
@@ -143,6 +151,8 @@
         private boolean earlyLvalueError = true;
         private boolean emptyStatements;
         private boolean es6 = true;
+        private boolean es7 = false;
+        private boolean jsx = false;
         private boolean syntaxExtensions = true;
         private boolean scripting;
         private boolean shebang;
@@ -174,6 +184,16 @@
             return this;
         }
 
+        public Builder es7(boolean es7) {
+            this.es7 = es7;
+            return this;
+        }
+
+        public Builder jsx(boolean jsx) {
+            this.jsx = jsx;
+            return this;
+        }
+
         public Builder syntaxExtensions(boolean syntaxExtensions) {
             this.syntaxExtensions = syntaxExtensions;
             return this;
@@ -210,7 +230,7 @@
         }
 
         public ScriptEnvironment build() {
-            return new ScriptEnvironment(strict, es6, earlyLvalueError, emptyStatements, syntaxExtensions, scripting, shebang, constAsVar,
+            return new ScriptEnvironment(strict, es6, es7, jsx, earlyLvalueError, emptyStatements, syntaxExtensions, scripting, shebang, constAsVar,
                             functionDeclarationHoisting, functionStatementBehavior, dumpOnError);
         }
     }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenKind.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenKind.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenKind.java	Wed Jul 20 10:53:21 2016 +0200
@@ -46,5 +46,7 @@
     /** Token reserved for future usage. */
     FUTURE,
     /** Token reserved for future in strict mode. */
-    FUTURESTRICT
+    FUTURESTRICT,
+    /** JSX tokens. */
+    JSX
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenLookup.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenLookup.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenLookup.java	Wed Jul 20 10:53:21 2016 +0200
@@ -64,7 +64,7 @@
             final String name = tokenType.getName();
 
             // Filter tokens.
-            if (name == null) {
+            if (name == null || tokenType.getKind() == TokenKind.JSX) {
                 continue;
             }
 
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenType.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenType.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenType.java	Wed Jul 20 10:53:21 2016 +0200
@@ -30,6 +30,7 @@
 import static com.oracle.js.parser.TokenKind.FUTURE;
 import static com.oracle.js.parser.TokenKind.FUTURESTRICT;
 import static com.oracle.js.parser.TokenKind.IR;
+import static com.oracle.js.parser.TokenKind.JSX;
 import static com.oracle.js.parser.TokenKind.KEYWORD;
 import static com.oracle.js.parser.TokenKind.LITERAL;
 import static com.oracle.js.parser.TokenKind.SPECIAL;
@@ -104,6 +105,7 @@
     RBRACE         (BRACKET, "}"),
     BIT_NOT        (UNARY,   "~",     15, false),
     ELLIPSIS       (UNARY,   "..."),
+    AT             (UNARY,   "@"),
 
     // ECMA 7.6.1.1 Keywords, 7.6.1.2 Future Reserved Words.
     // All other Java keywords are commented out.
@@ -197,7 +199,17 @@
     INCPOSTFIX     (IR,       null),
     SPREAD_ARGUMENT(IR,       null),
     SPREAD_ARRAY   (IR,       null),
-    YIELD_STAR     (IR,       null);
+    SPREAD_OBJECT  (IR,       null),
+    YIELD_STAR     (IR,       null),
+    AWAIT          (IR,       null),
+
+    JSX_IDENTIFIER   (JSX,  null),
+    JSX_TEXT         (JSX,  null),
+    JSX_STRING       (JSX,  null),
+    JSX_ELEM_START   (JSX,  "<"),
+    JSX_ELEM_END     (JSX,  ">"),
+    JSX_ELEM_CLOSE   (JSX,  "/")
+    ;
 
     /** Next token kind in token lookup table. */
     private TokenType next;
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ClassNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ClassNode.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ClassNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -39,6 +39,7 @@
     private final Expression classHeritage;
     private final PropertyNode constructor;
     private final List<PropertyNode> classElements;
+    private final List<Expression> decorators;
     private final int line;
 
     /**
@@ -49,13 +50,25 @@
      * @param finish finish
      */
     public ClassNode(final int line, final long token, final int finish, final IdentNode ident, final Expression classHeritage, final PropertyNode constructor,
-                    final List<PropertyNode> classElements) {
+                    final List<PropertyNode> classElements, final List<Expression> decorators) {
         super(token, finish);
         this.line = line;
         this.ident = ident;
         this.classHeritage = classHeritage;
         this.constructor = constructor;
         this.classElements = classElements;
+        this.decorators = decorators;
+    }
+
+    private ClassNode(final ClassNode classNode, final IdentNode ident, final Expression classHeritage, final PropertyNode constructor,
+                    final List<PropertyNode> classElements, final List<Expression> decorators) {
+        super(classNode);
+        this.line = classNode.getLineNumber();
+        this.ident = ident;
+        this.classHeritage = classHeritage;
+        this.constructor = constructor;
+        this.classElements = classElements;
+        this.decorators = decorators;
     }
 
     /**
@@ -65,6 +78,13 @@
         return ident;
     }
 
+    private ClassNode setIdent(final IdentNode ident) {
+        if (this.ident == ident) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * The expression of the {@code extends} clause. Optional.
      */
@@ -72,6 +92,13 @@
         return classHeritage;
     }
 
+    private ClassNode setClassHeritage(final Expression classHeritage) {
+        if (this.classHeritage == classHeritage) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * Get the constructor method definition.
      */
@@ -79,6 +106,13 @@
         return constructor;
     }
 
+    private ClassNode setConstructor(final PropertyNode constructor) {
+        if (this.constructor == constructor) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * Get method definitions except the constructor.
      */
@@ -86,6 +120,27 @@
         return Collections.unmodifiableList(classElements);
     }
 
+    private ClassNode setClassElements(final List<PropertyNode> classElements) {
+        if (this.classElements == classElements) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
+    /**
+     * Get decorators.
+     */
+    public List<Expression> getDecorators() {
+        return Collections.unmodifiableList(decorators);
+    }
+
+    private ClassNode setDecorators(final List<Expression> decorators) {
+        if (this.decorators == decorators) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * Returns the line number.
      */
@@ -96,7 +151,10 @@
     @Override
     public Node accept(final NodeVisitor<? extends LexicalContext> visitor) {
         if (visitor.enterClassNode(this)) {
-            return visitor.leaveClassNode(this);
+            IdentNode newIdent = ident == null ? null : (IdentNode) ident.accept(visitor);
+            Expression newClassHeritage = classHeritage == null ? null : (Expression) classHeritage.accept(visitor);
+            PropertyNode newConstructor = constructor == null ? null : (PropertyNode) constructor.accept(visitor);
+            return visitor.leaveClassNode(setIdent(newIdent).setClassHeritage(newClassHeritage).setConstructor(newConstructor).setClassElements(Node.accept(visitor, classElements)).setDecorators(Node.accept(visitor, decorators)));
         }
 
         return this;
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportClauseNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportClauseNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+import java.util.Collections;
+import java.util.List;
+
+public class ExportClauseNode extends Node {
+
+    private final List<ExportSpecifierNode> exportSpecifiers;
+
+    public ExportClauseNode(final long token, final int start, final int finish, final List<ExportSpecifierNode> exportSpecifiers) {
+        super(token, start, finish);
+        this.exportSpecifiers = exportSpecifiers;
+    }
+
+    private ExportClauseNode(final ExportClauseNode node, final List<ExportSpecifierNode> exportSpecifiers) {
+        super(node);
+        this.exportSpecifiers = exportSpecifiers;
+    }
+
+    public List<ExportSpecifierNode> getExportSpecifiers() {
+        return Collections.unmodifiableList(exportSpecifiers);
+    }
+
+    public ExportClauseNode setExportSpecifiers(List<ExportSpecifierNode> exportSpecifiers) {
+        if (this.exportSpecifiers == exportSpecifiers) {
+            return this;
+        }
+        return new ExportClauseNode(this, exportSpecifiers);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterExportClauseNode(this)) {
+            return visitor.leaveExportClauseNode(setExportSpecifiers(Node.accept(visitor, exportSpecifiers)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterExportClauseNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append('{');
+        for (int i = 0; i < exportSpecifiers.size(); i++) {
+            exportSpecifiers.get(i).toString(sb, printType);
+            if (i < exportSpecifiers.size() - 1) {
+                sb.append(", ");
+            }
+        }
+        sb.append('}');
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,179 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class ExportNode extends Node {
+
+    private final ExportClauseNode exportClause;
+
+    private final FromNode from;
+
+    private final VarNode var;
+
+    private final Expression expression;
+
+    private final boolean isDefault;
+
+    public ExportNode(final long token, final int start, final int finish, final ExportClauseNode exportClause) {
+        this(token, start, finish, exportClause, null, null, null, false);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final FromNode from) {
+        this(token, start, finish, null, from, null, null, false);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final ExportClauseNode exportClause, final FromNode from) {
+        this(token, start, finish, exportClause, from, null, null, false);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final Expression expression, final boolean isDefault) {
+        this(token, start, finish, null, null, null, expression, isDefault);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final VarNode var) {
+        this(token, start, finish, null, null, var, null, false);
+    }
+
+    private ExportNode(final long token, final int start, final int finish, final ExportClauseNode exportClause,
+                    final FromNode from, final VarNode var, final Expression expression, final boolean isDefault) {
+        super(token, start, finish);
+        this.exportClause = exportClause;
+        this.from = from;
+        this.var = var;
+        this.expression = expression;
+        this.isDefault = isDefault;
+    }
+
+    private ExportNode(final ExportNode node, final ExportClauseNode exportClause,
+                    final FromNode from, final VarNode var, final Expression expression) {
+        super(node);
+        this.isDefault = node.isDefault;
+
+        this.exportClause = exportClause;
+        this.from = from;
+        this.var = var;
+        this.expression = expression;
+    }
+
+    public ExportClauseNode getExportClause() {
+        return exportClause;
+    }
+
+    public FromNode getFrom() {
+        return from;
+    }
+
+    public VarNode getVar() {
+        return var;
+    }
+
+    public Expression getExpression() {
+        return expression;
+    }
+
+    public boolean isDefault() {
+        return isDefault;
+    }
+
+    public ExportNode setExportClause(ExportClauseNode exportClause) {
+        if (this.exportClause == exportClause) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    public ExportNode setFrom(FromNode from) {
+        if (this.from == from) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    public ExportNode setVar(VarNode var) {
+        if (this.var == var) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    public ExportNode setExpression(Expression expression) {
+        if (this.expression == expression) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterExportNode(this)) {
+            ExportClauseNode newExportClause = exportClause == null ? null
+                            : (ExportClauseNode) exportClause.accept(visitor);
+            FromNode newFrom = from == null ? null
+                            : (FromNode) from.accept(visitor);
+            VarNode newVar = var == null ? null
+                            : (VarNode) var.accept(visitor);
+            Expression newExpression = expression == null ? null
+                            : (Expression) expression.accept(visitor);
+            return visitor.leaveExportNode(
+                            setExportClause(newExportClause).setFrom(newFrom).setVar(newVar).setExpression(newExpression));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterExportNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("export ");
+        if (isDefault) {
+            sb.append("default ");
+        }
+        if (expression != null) {
+            expression.toString(sb, printType);
+            if (expression.isAssignment()) {
+                sb.append(';');
+            }
+        } else {
+            if (exportClause == null) {
+                sb.append("* ");
+            } else {
+                exportClause.toString(sb, printType);
+            }
+            if (from != null) {
+                from.toString(sb, printType);
+            }
+            sb.append(';');
+        }
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportSpecifierNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportSpecifierNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class ExportSpecifierNode extends Node {
+
+    private final IdentNode identifier;
+
+    private final IdentNode exportIdentifier;
+
+    public ExportSpecifierNode(final long token, final int start, final int finish, final IdentNode identifier, final IdentNode exportIdentifier) {
+        super(token, start, finish);
+        this.identifier = identifier;
+        this.exportIdentifier = exportIdentifier;
+    }
+
+    private ExportSpecifierNode(final ExportSpecifierNode node, final IdentNode identifier, final IdentNode exportIdentifier) {
+        super(node);
+        this.identifier = identifier;
+        this.exportIdentifier = exportIdentifier;
+    }
+
+    public IdentNode getIdentifier() {
+        return identifier;
+    }
+
+    public IdentNode getExportIdentifier() {
+        return exportIdentifier;
+    }
+
+    public ExportSpecifierNode setIdentifier(IdentNode identifier) {
+        if (this.identifier == identifier) {
+            return this;
+        }
+        return new ExportSpecifierNode(this, identifier, exportIdentifier);
+    }
+
+    public ExportSpecifierNode setExportIdentifier(IdentNode exportIdentifier) {
+        if (this.exportIdentifier == exportIdentifier) {
+            return this;
+        }
+        return new ExportSpecifierNode(this, identifier, exportIdentifier);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterExportSpecifierNode(this)) {
+            IdentNode newExportIdentifier = exportIdentifier == null ? null
+                            : (IdentNode) exportIdentifier.accept(visitor);
+            return visitor.leaveExportSpecifierNode(
+                            setIdentifier((IdentNode) identifier.accept(visitor)).setExportIdentifier(newExportIdentifier));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterExportSpecifierNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        if (identifier != null) {
+            identifier.toString(sb, printType);
+            sb.append(" as ");
+        }
+        exportIdentifier.toString(sb, printType);
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FromNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FromNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class FromNode extends Node {
+
+    private final LiteralNode<String> moduleSpecifier;
+
+    public FromNode(final long token, final int start, final int finish, final LiteralNode<String> moduleSpecifier) {
+        super(token, start, finish);
+        this.moduleSpecifier = moduleSpecifier;
+    }
+
+    private FromNode(final FromNode node, final LiteralNode<String> moduleSpecifier) {
+        super(node);
+        this.moduleSpecifier = moduleSpecifier;
+    }
+
+    public LiteralNode<String> getModuleSpecifier() {
+        return moduleSpecifier;
+    }
+
+    public FromNode setModuleSpecifier(LiteralNode<String> moduleSpecifier) {
+        if (this.moduleSpecifier == moduleSpecifier) {
+            return this;
+        }
+        return new FromNode(this, moduleSpecifier);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterFromNode(this)) {
+            return visitor.leaveFromNode(
+                            setModuleSpecifier((LiteralNode<String>) moduleSpecifier.accept(visitor)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterFromNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("from");
+        sb.append(' ');
+        moduleSpecifier.toString(sb, printType);
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FunctionNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FunctionNode.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FunctionNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -207,6 +207,12 @@
     /** Does this function use new.target? */
     public static final int USES_NEW_TARGET = 1 << 23;
 
+    /** Is it a statement? */
+    public static final int IS_STATEMENT = 1 << 24;
+
+    /** Is it async? */
+    public static final int IS_ASYNC = 1 << 25;
+
     /**
      * Constructor
      *
@@ -314,6 +320,14 @@
         return Node.accept(visitor, parameters);
     }
 
+    public List<ImportNode> visitImports(final NodeVisitor<? extends LexicalContext> visitor) {
+        return Node.accept(visitor, module.getImports());
+    }
+
+    public List<ExportNode> visitExports(final NodeVisitor<? extends LexicalContext> visitor) {
+        return Node.accept(visitor, module.getExports());
+    }
+
     /**
      * Get the source for this function
      *
@@ -363,6 +377,9 @@
 
     @Override
     public void toString(final StringBuilder sb, final boolean printTypes) {
+        if (isAsync()) {
+            sb.append("async ");
+        }
         sb.append("function");
 
         if (ident != null) {
@@ -737,4 +754,12 @@
     public Module getModule() {
         return module;
     }
+
+    public boolean isStatement() {
+        return getFlag(IS_STATEMENT);
+    }
+
+    public boolean isAsync() {
+        return getFlag(IS_ASYNC);
+    }
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportClauseNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportClauseNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class ImportClauseNode extends Node {
+
+    private final IdentNode defaultBinding;
+
+    private final NameSpaceImportNode nameSpaceImport;
+
+    private final NamedImportsNode namedImports;
+
+    public ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding) {
+        this(token, start, finish, defaultBinding, null, null);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final NameSpaceImportNode nameSpaceImport) {
+        this(token, start, finish, null, nameSpaceImport, null);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final NamedImportsNode namedImportsNode) {
+        this(token, start, finish, null, null, namedImportsNode);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding, final NameSpaceImportNode nameSpaceImport) {
+        this(token, start, finish, defaultBinding, nameSpaceImport, null);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding, final NamedImportsNode namedImports) {
+        this(token, start, finish, defaultBinding, null, namedImports);
+    }
+
+    private ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding, final NameSpaceImportNode nameSpaceImport, final NamedImportsNode namedImports) {
+        super(token, start, finish);
+        this.defaultBinding = defaultBinding;
+        this.nameSpaceImport = nameSpaceImport;
+        this.namedImports = namedImports;
+    }
+
+    private ImportClauseNode(final ImportClauseNode node, final IdentNode defaultBinding, final NameSpaceImportNode nameSpaceImport, final NamedImportsNode namedImports) {
+        super(node);
+        this.defaultBinding = defaultBinding;
+        this.nameSpaceImport = nameSpaceImport;
+        this.namedImports = namedImports;
+    }
+
+    public IdentNode getDefaultBinding() {
+        return defaultBinding;
+    }
+
+    public NameSpaceImportNode getNameSpaceImport() {
+        return nameSpaceImport;
+    }
+
+    public NamedImportsNode getNamedImports() {
+        return namedImports;
+    }
+
+    public ImportClauseNode setDefaultBinding(IdentNode defaultBinding) {
+        if (this.defaultBinding == defaultBinding) {
+            return this;
+        }
+        return new ImportClauseNode(this, defaultBinding, nameSpaceImport, namedImports);
+    }
+
+    public ImportClauseNode setNameSpaceImport(NameSpaceImportNode nameSpaceImport) {
+        if (this.nameSpaceImport == nameSpaceImport) {
+            return this;
+        }
+        return new ImportClauseNode(this, defaultBinding, nameSpaceImport, namedImports);
+    }
+
+    public ImportClauseNode setNamedImports(NamedImportsNode namedImports) {
+        if (this.namedImports == namedImports) {
+            return this;
+        }
+        return new ImportClauseNode(this, defaultBinding, nameSpaceImport, namedImports);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterImportClauseNode(this)) {
+            IdentNode newDefaultBinding = defaultBinding == null ? null
+                            : (IdentNode) defaultBinding.accept(visitor);
+            NameSpaceImportNode newNameSpaceImport = nameSpaceImport == null ? null
+                            : (NameSpaceImportNode) nameSpaceImport.accept(visitor);
+            NamedImportsNode newNamedImports = namedImports == null ? null
+                            : (NamedImportsNode) namedImports.accept(visitor);
+            return visitor.leaveImportClauseNode(
+                            setDefaultBinding(newDefaultBinding).setNameSpaceImport(newNameSpaceImport).setNamedImports(newNamedImports));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterImportClauseNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        if (defaultBinding != null) {
+            defaultBinding.toString(sb, printType);
+            if (nameSpaceImport != null || namedImports != null) {
+                sb.append(',');
+            }
+        }
+
+        if (nameSpaceImport != null) {
+            nameSpaceImport.toString(sb, printType);
+        } else if (namedImports != null) {
+            namedImports.toString(sb, printType);
+        }
+
+    }
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class ImportNode extends Node {
+
+    private final LiteralNode<String> moduleSpecifier;
+
+    private final ImportClauseNode importClause;
+
+    private final FromNode from;
+
+    public ImportNode(final long token, final int start, final int finish, final LiteralNode<String> moduleSpecifier) {
+        this(token, start, finish, moduleSpecifier, null, null);
+    }
+
+    public ImportNode(final long token, final int start, final int finish, final ImportClauseNode importClause, final FromNode from) {
+        this(token, start, finish, null, importClause, from);
+    }
+
+    private ImportNode(final long token, final int start, final int finish, final LiteralNode<String> moduleSpecifier, ImportClauseNode importClause, FromNode from) {
+        super(token, start, finish);
+        this.moduleSpecifier = moduleSpecifier;
+        this.importClause = importClause;
+        this.from = from;
+    }
+
+    private ImportNode(final ImportNode node, final LiteralNode<String> moduleSpecifier, ImportClauseNode importClause, FromNode from) {
+        super(node);
+        this.moduleSpecifier = moduleSpecifier;
+        this.importClause = importClause;
+        this.from = from;
+    }
+
+    public LiteralNode<String> getModuleSpecifier() {
+        return moduleSpecifier;
+    }
+
+    public ImportClauseNode getImportClause() {
+        return importClause;
+    }
+
+    public FromNode getFrom() {
+        return from;
+    }
+
+    public ImportNode setModuleSpecifier(LiteralNode<String> moduleSpecifier) {
+        if (this.moduleSpecifier == moduleSpecifier) {
+            return this;
+        }
+        return new ImportNode(this, moduleSpecifier, importClause, from);
+    }
+
+    public ImportNode setImportClause(ImportClauseNode importClause) {
+        if (this.importClause == importClause) {
+            return this;
+        }
+        return new ImportNode(this, moduleSpecifier, importClause, from);
+    }
+
+    public ImportNode setFrom(FromNode from) {
+        if (this.from == from) {
+            return this;
+        }
+        return new ImportNode(this, moduleSpecifier, importClause, from);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterImportNode(this)) {
+            LiteralNode<String> newModuleSpecifier = moduleSpecifier == null ? null
+                            : (LiteralNode<String>) moduleSpecifier.accept(visitor);
+            ImportClauseNode newImportClause = importClause == null ? null
+                            : (ImportClauseNode) importClause.accept(visitor);
+            FromNode newFrom = from == null ? null
+                            : (FromNode) from.accept(visitor);
+            return visitor.leaveImportNode(
+                            setModuleSpecifier(newModuleSpecifier).setImportClause(newImportClause).setFrom(newFrom));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterImportNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("import");
+        sb.append(' ');
+        if (moduleSpecifier != null) {
+            moduleSpecifier.toString(sb, printType);
+        } else {
+            importClause.toString(sb, printType);
+            sb.append(' ');
+            from.toString(sb, printType);
+        }
+        sb.append(';');
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportSpecifierNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportSpecifierNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class ImportSpecifierNode extends Node {
+
+    private final IdentNode identifier;
+
+    private final IdentNode bindingIdentifier;
+
+    public ImportSpecifierNode(final long token, final int start, final int finish, final IdentNode bindingIdentifier, final IdentNode identifier) {
+        super(token, start, finish);
+        this.identifier = identifier;
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    private ImportSpecifierNode(final ImportSpecifierNode node, final IdentNode bindingIdentifier, final IdentNode identifier) {
+        super(node);
+        this.identifier = identifier;
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    public IdentNode getIdentifier() {
+        return identifier;
+    }
+
+    public IdentNode getBindingIdentifier() {
+        return bindingIdentifier;
+    }
+
+    public ImportSpecifierNode setIdentifier(IdentNode identifier) {
+        if (this.identifier == identifier) {
+            return this;
+        }
+        return new ImportSpecifierNode(this, identifier, bindingIdentifier);
+    }
+
+    public ImportSpecifierNode setBindingIdentifier(IdentNode bindingIdentifier) {
+        if (this.bindingIdentifier == bindingIdentifier) {
+            return this;
+        }
+        return new ImportSpecifierNode(this, identifier, bindingIdentifier);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterImportSpecifierNode(this)) {
+            IdentNode newIdentifier = identifier == null ? null
+                            : (IdentNode) identifier.accept(visitor);
+            return visitor.leaveImportSpecifierNode(
+                            setBindingIdentifier((IdentNode) bindingIdentifier.accept(visitor)).setIdentifier(newIdentifier));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterImportSpecifierNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        if (identifier != null) {
+            identifier.toString(sb, printType);
+            sb.append(" as ");
+        }
+        bindingIdentifier.toString(sb, printType);
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/JsxAttributeNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/JsxAttributeNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class JsxAttributeNode extends Expression {
+
+    private final String name;
+
+    private final Expression value;
+
+    public JsxAttributeNode(String name, Expression value, long token, int finish) {
+        super(token, finish);
+        this.name = name;
+        this.value = value;
+    }
+
+    public JsxAttributeNode(JsxAttributeNode node, String name, Expression value) {
+        super(node);
+        this.name = name;
+        this.value = value;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public Expression getValue() {
+        return value;
+    }
+
+    public JsxAttributeNode setValue(Expression value) {
+        if (this.value == value) {
+            return this;
+        }
+        return new JsxAttributeNode(this, name, value);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterJsxAttributeNode(this)) {
+            Expression newValue = value == null ? null
+                            : (Expression) value.accept(visitor);
+            return visitor.leaveJsxAttributeNode(setValue(newValue));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterJsxAttributeNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append(name);
+        if (value != null) {
+            sb.append('=');
+            value.toString(sb, printType);
+        }
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/JsxElementNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/JsxElementNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+import java.util.Collections;
+import java.util.List;
+
+public class JsxElementNode extends Expression {
+
+    private final String name;
+
+    private final List<Expression> attributes;
+
+    private final List<Expression> children;
+
+    public JsxElementNode(String name, List<Expression> attributes, List<Expression> children, long token, int finish) {
+        super(token, finish);
+        this.name = name;
+        this.attributes = attributes;
+        this.children = children;
+    }
+
+    private JsxElementNode(JsxElementNode node, String name, List<Expression> attributes, List<Expression> children) {
+        super(node);
+        this.name = name;
+        this.attributes = attributes;
+        this.children = children;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public List<Expression> getAttributes() {
+        return Collections.unmodifiableList(attributes);
+    }
+
+    public JsxElementNode setAttributes(List<Expression> attributes) {
+        if (this.attributes == attributes) {
+            return this;
+        }
+        return new JsxElementNode(this, name, attributes, children);
+    }
+
+    public List<Expression> getChildren() {
+        return Collections.unmodifiableList(children);
+    }
+
+    public JsxElementNode setChildren(List<Expression> children) {
+        if (this.children == children) {
+            return this;
+        }
+        return new JsxElementNode(this, name, attributes, children);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterJsxElementNode(this)) {
+            return visitor.leaveJsxElementNode(
+                    setAttributes(Node.accept(visitor, attributes)).
+                    setChildren(Node.accept(visitor, children)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterJsxElementNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append('<').append(name);
+        for (Expression attr : attributes) {
+            sb.append(' ');
+            attr.toString(sb, printType);
+        }
+        if (children.isEmpty()) {
+            sb.append("/>");
+        } else {
+            sb.append('>');
+            for (Expression child : children) {
+                child.toString(sb, printType);
+            }
+            sb.append("</").append(name).append('>');
+        }
+    }
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/Module.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/Module.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/Module.java	Wed Jul 20 10:53:21 2016 +0200
@@ -151,14 +151,18 @@
     private final List<ExportEntry> localExportEntries;
     private final List<ExportEntry> indirectExportEntries;
     private final List<ExportEntry> starExportEntries;
+    private final List<ImportNode> imports;
+    private final List<ExportNode> exports;
 
     public Module(List<String> requestedModules, List<ImportEntry> importEntries, List<ExportEntry> localExportEntries, List<ExportEntry> indirectExportEntries,
-                    List<ExportEntry> starExportEntries) {
+                    List<ExportEntry> starExportEntries, List<ImportNode> imports, List<ExportNode> exports) {
         this.requestedModules = requestedModules;
         this.importEntries = importEntries;
         this.localExportEntries = localExportEntries;
         this.indirectExportEntries = indirectExportEntries;
         this.starExportEntries = starExportEntries;
+        this.imports = imports;
+        this.exports = exports;
     }
 
     public List<String> getRequestedModules() {
@@ -181,9 +185,17 @@
         return starExportEntries;
     }
 
+    public List<ImportNode> getImports() {
+        return imports;
+    }
+
+    public List<ExportNode> getExports() {
+        return exports;
+    }
+
     @Override
     public String toString() {
         return "Module [requestedModules=" + requestedModules + ", importEntries=" + importEntries + ", localExportEntries=" + localExportEntries + ", indirectExportEntries=" +
-                        indirectExportEntries + ", starExportEntries=" + starExportEntries + "]";
+                        indirectExportEntries + ", starExportEntries=" + starExportEntries + ", imports=" + imports + ", exports=" + exports + "]";
     }
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NameSpaceImportNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NameSpaceImportNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+public class NameSpaceImportNode extends Node {
+
+    private final IdentNode bindingIdentifier;
+
+    public NameSpaceImportNode(final long token, final int start, final int finish, final IdentNode bindingIdentifier) {
+        super(token, start, finish);
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    private NameSpaceImportNode(final NameSpaceImportNode node, final IdentNode bindingIdentifier) {
+        super(node);
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    public IdentNode getBindingIdentifier() {
+        return bindingIdentifier;
+    }
+
+    public NameSpaceImportNode setBindingIdentifier(IdentNode bindingIdentifier) {
+        if (this.bindingIdentifier == bindingIdentifier) {
+            return this;
+        }
+        return new NameSpaceImportNode(this, bindingIdentifier);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterNameSpaceImportNode(this)) {
+            return visitor.leaveNameSpaceImportNode(
+                            setBindingIdentifier((IdentNode) bindingIdentifier.accept(visitor)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterNameSpaceImportNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("* as ");
+        bindingIdentifier.toString(sb, printType);
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NamedImportsNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NamedImportsNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+import java.util.Collections;
+import java.util.List;
+
+public class NamedImportsNode extends Node {
+
+    private final List<ImportSpecifierNode> importSpecifiers;
+
+    public NamedImportsNode(final long token, final int start, final int finish, final List<ImportSpecifierNode> importSpecifiers) {
+        super(token, start, finish);
+        this.importSpecifiers = importSpecifiers;
+    }
+
+    private NamedImportsNode(final NamedImportsNode node, final List<ImportSpecifierNode> importSpecifiers) {
+        super(node);
+        this.importSpecifiers = importSpecifiers;
+    }
+
+    public List<ImportSpecifierNode> getImportSpecifiers() {
+        return Collections.unmodifiableList(importSpecifiers);
+    }
+
+    public NamedImportsNode setImportSpecifiers(List<ImportSpecifierNode> importSpecifiers) {
+        if (this.importSpecifiers == importSpecifiers) {
+            return this;
+        }
+        return new NamedImportsNode(this, importSpecifiers);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterNamedImportsNode(this)) {
+            return visitor.leaveNamedImportsNode(setImportSpecifiers(Node.accept(visitor, importSpecifiers)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterNamedImportsNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append('{');
+        for (int i = 0; i < importSpecifiers.size(); i++) {
+            importSpecifiers.get(i).toString(sb, printType);
+            if (i < importSpecifiers.size() - 1) {
+                sb.append(", ");
+            }
+        }
+        sb.append('}');
+    }
+
+}
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/PropertyNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/PropertyNode.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/PropertyNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -25,8 +25,11 @@
 
 package com.oracle.js.parser.ir;
 
+import com.oracle.js.parser.TokenType;
 import com.oracle.js.parser.ir.visitor.NodeVisitor;
 import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+import java.util.Collections;
+import java.util.List;
 
 // @formatter:off
 /**
@@ -46,6 +49,8 @@
     /** Property setter. */
     private final FunctionNode setter;
 
+    private final List<Expression> decorators;
+
     private final boolean isStatic;
 
     private final boolean computed;
@@ -60,7 +65,9 @@
      * @param getter  getter function body
      * @param setter  setter function body
      */
-    public PropertyNode(final long token, final int finish, final Expression key, final Expression value, final FunctionNode getter, final FunctionNode setter, final boolean isStatic, final boolean computed) {
+    public PropertyNode(final long token, final int finish, final Expression key,
+            final Expression value, final FunctionNode getter, final FunctionNode setter,
+            final boolean isStatic, final boolean computed, final List<Expression> decorators) {
         super(token, finish);
         this.key    = key;
         this.value  = value;
@@ -68,9 +75,12 @@
         this.setter = setter;
         this.isStatic = isStatic;
         this.computed = computed;
+        this.decorators = decorators;
     }
 
-    private PropertyNode(final PropertyNode propertyNode, final Expression key, final Expression value, final FunctionNode getter, final FunctionNode setter, final boolean isStatic, final boolean computed) {
+    private PropertyNode(final PropertyNode propertyNode, final Expression key,
+            final Expression value, final FunctionNode getter, final FunctionNode setter,
+            final boolean isStatic, final boolean computed, final List<Expression> decorators) {
         super(propertyNode);
         this.key    = key;
         this.value  = value;
@@ -78,6 +88,7 @@
         this.setter = setter;
         this.isStatic = isStatic;
         this.computed = computed;
+        this.decorators = decorators;
     }
 
     /**
@@ -95,7 +106,8 @@
                 setKey((Expression)key.accept(visitor)).
                 setValue(value == null ? null : (Expression)value.accept(visitor)).
                 setGetter(getter == null ? null : (FunctionNode)getter.accept(visitor)).
-                setSetter(setter == null ? null : (FunctionNode)setter.accept(visitor)));
+                setSetter(setter == null ? null : (FunctionNode)setter.accept(visitor)).
+                setDecorators(Node.accept(visitor, decorators)));
         }
 
         return this;
@@ -146,7 +158,7 @@
         if (this.getter == getter) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
     }
 
     /**
@@ -161,7 +173,7 @@
         if (this.key == key) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
     }
 
     /**
@@ -181,7 +193,7 @@
         if (this.setter == setter) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
     }
 
     /**
@@ -201,8 +213,22 @@
         if (this.value == value) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
-   }
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
+    }
+
+    /**
+     * Get decorators.
+     */
+    public List<Expression> getDecorators() {
+        return Collections.unmodifiableList(decorators);
+    }
+
+    private PropertyNode setDecorators(final List<Expression> decorators) {
+        if (this.decorators == decorators) {
+            return this;
+        }
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
+    }
 
     public boolean isStatic() {
         return isStatic;
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/UnaryNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/UnaryNode.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/UnaryNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -128,6 +128,19 @@
         final String    name      = tokenType.getName();
         final boolean   isPostfix = tokenType == DECPOSTFIX || tokenType == INCPOSTFIX;
 
+        if (tokenType == TokenType.SPREAD_ARRAY || tokenType == TokenType.SPREAD_OBJECT) {
+            sb.append("...");
+            getExpression().toString(sb, printType);
+            return;
+        }
+
+        if (tokenType == TokenType.AWAIT) {
+            // await expression
+            sb.append("await ");
+            getExpression().toString(sb, printType);
+            return;
+        }
+
         boolean rhsParen = tokenType.needsParens(getExpression().tokenType(), false);
 
         if (!isPostfix) {
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/VarNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/VarNode.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/VarNode.java	Wed Jul 20 10:53:21 2016 +0200
@@ -60,6 +60,12 @@
      *  a program node */
     public static final int IS_LAST_FUNCTION_DECLARATION = 1 << 2;
 
+    /** Flag synthetic export var node */
+    public static final int IS_EXPORT = 1 << 3;
+
+    /** Flag synthetic destructuring var node */
+    public static final int IS_DESTRUCTURING = 1 << 4;
+
     /**
      * Constructor
      *
@@ -288,4 +294,12 @@
     public boolean isFunctionDeclaration() {
         return init instanceof FunctionNode && ((FunctionNode)init).isDeclared();
     }
+
+    public boolean isExport() {
+        return getFlag(IS_EXPORT);
+    }
+
+    public boolean isDestructuring() {
+        return getFlag(IS_DESTRUCTURING);
+    }
 }
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/NodeVisitor.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/NodeVisitor.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/NodeVisitor.java	Wed Jul 20 10:53:21 2016 +0200
@@ -38,16 +38,27 @@
 import com.oracle.js.parser.ir.DebuggerNode;
 import com.oracle.js.parser.ir.EmptyNode;
 import com.oracle.js.parser.ir.ErrorNode;
+import com.oracle.js.parser.ir.ExportClauseNode;
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ExportSpecifierNode;
 import com.oracle.js.parser.ir.ExpressionStatement;
 import com.oracle.js.parser.ir.ForNode;
+import com.oracle.js.parser.ir.FromNode;
 import com.oracle.js.parser.ir.FunctionNode;
 import com.oracle.js.parser.ir.IdentNode;
 import com.oracle.js.parser.ir.IfNode;
+import com.oracle.js.parser.ir.ImportClauseNode;
+import com.oracle.js.parser.ir.ImportNode;
+import com.oracle.js.parser.ir.ImportSpecifierNode;
 import com.oracle.js.parser.ir.IndexNode;
 import com.oracle.js.parser.ir.JoinPredecessorExpression;
+import com.oracle.js.parser.ir.JsxAttributeNode;
+import com.oracle.js.parser.ir.JsxElementNode;
 import com.oracle.js.parser.ir.LabelNode;
 import com.oracle.js.parser.ir.LexicalContext;
 import com.oracle.js.parser.ir.LiteralNode;
+import com.oracle.js.parser.ir.NameSpaceImportNode;
+import com.oracle.js.parser.ir.NamedImportsNode;
 import com.oracle.js.parser.ir.Node;
 import com.oracle.js.parser.ir.ObjectNode;
 import com.oracle.js.parser.ir.PropertyNode;
@@ -352,6 +363,30 @@
         return leaveDefault(errorNode);
     }
 
+    public boolean enterExportClauseNode(final ExportClauseNode exportClauseNode) {
+        return enterDefault(exportClauseNode);
+    }
+
+    public Node leaveExportClauseNode(final ExportClauseNode exportClauseNode) {
+        return leaveDefault(exportClauseNode);
+    }
+
+    public boolean enterExportNode(final ExportNode exportNode) {
+        return enterDefault(exportNode);
+    }
+
+    public Node leaveExportNode(final ExportNode exportNode) {
+        return leaveDefault(exportNode);
+    }
+
+    public boolean enterExportSpecifierNode(final ExportSpecifierNode exportSpecifierNode) {
+        return enterDefault(exportSpecifierNode);
+    }
+
+    public Node leaveExportSpecifierNode(final ExportSpecifierNode exportSpecifierNode) {
+        return leaveDefault(exportSpecifierNode);
+    }
+
     /**
      * Callback for entering an ExpressionStatement
      *
@@ -412,6 +447,14 @@
         return leaveDefault(forNode);
     }
 
+    public boolean enterFromNode(final FromNode fromNode) {
+        return enterDefault(fromNode);
+    }
+
+    public Node leaveFromNode(final FromNode fromNode) {
+        return leaveDefault(fromNode);
+    }
+
     /**
      * Callback for entering a FunctionNode
      *
@@ -472,6 +515,30 @@
         return leaveDefault(ifNode);
     }
 
+    public boolean enterImportClauseNode(final ImportClauseNode importClauseNode) {
+        return enterDefault(importClauseNode);
+    }
+
+    public Node leaveImportClauseNode(final ImportClauseNode importClauseNode) {
+        return leaveDefault(importClauseNode);
+    }
+
+    public boolean enterImportNode(final ImportNode importNode) {
+        return enterDefault(importNode);
+    }
+
+    public Node leaveImportNode(final ImportNode importNode) {
+        return leaveDefault(importNode);
+    }
+
+    public boolean enterImportSpecifierNode(final ImportSpecifierNode importSpecifierNode) {
+        return enterDefault(importSpecifierNode);
+    }
+
+    public Node leaveImportSpecifierNode(final ImportSpecifierNode importSpecifierNode) {
+        return leaveDefault(importSpecifierNode);
+    }
+
     /**
      * Callback for entering an IndexNode
      *
@@ -492,6 +559,22 @@
         return leaveDefault(indexNode);
     }
 
+    public boolean enterJsxAttributeNode(final JsxAttributeNode jsxAttributeNode) {
+        return enterDefault(jsxAttributeNode);
+    }
+
+    public Node leaveJsxAttributeNode(final JsxAttributeNode jsxAttributeNode) {
+        return leaveDefault(jsxAttributeNode);
+    }
+
+    public boolean enterJsxElementNode(final JsxElementNode jsxElementNode) {
+        return enterDefault(jsxElementNode);
+    }
+
+    public Node leaveJsxElementNode(final JsxElementNode jsxElementNode) {
+        return leaveDefault(jsxElementNode);
+    }
+
     /**
      * Callback for entering a LabelNode
      *
@@ -532,6 +615,22 @@
         return leaveDefault(literalNode);
     }
 
+    public boolean enterNameSpaceImportNode(final NameSpaceImportNode nameSpaceImportNode) {
+        return enterDefault(nameSpaceImportNode);
+    }
+
+    public Node leaveNameSpaceImportNode(final NameSpaceImportNode nameSpaceImportNode) {
+        return leaveDefault(nameSpaceImportNode);
+    }
+
+    public boolean enterNamedImportsNode(final NamedImportsNode namedImportsNode) {
+        return enterDefault(namedImportsNode);
+    }
+
+    public Node leaveNamedImportsNode(final NamedImportsNode namedImportsNode) {
+        return leaveDefault(namedImportsNode);
+    }
+
     /**
      * Callback for entering an ObjectNode
      *
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/TranslatorNodeVisitor.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/TranslatorNodeVisitor.java	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/TranslatorNodeVisitor.java	Wed Jul 20 10:53:21 2016 +0200
@@ -38,16 +38,27 @@
 import com.oracle.js.parser.ir.DebuggerNode;
 import com.oracle.js.parser.ir.EmptyNode;
 import com.oracle.js.parser.ir.ErrorNode;
+import com.oracle.js.parser.ir.ExportClauseNode;
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ExportSpecifierNode;
 import com.oracle.js.parser.ir.ExpressionStatement;
 import com.oracle.js.parser.ir.ForNode;
+import com.oracle.js.parser.ir.FromNode;
 import com.oracle.js.parser.ir.FunctionNode;
 import com.oracle.js.parser.ir.IdentNode;
 import com.oracle.js.parser.ir.IfNode;
+import com.oracle.js.parser.ir.ImportClauseNode;
+import com.oracle.js.parser.ir.ImportNode;
+import com.oracle.js.parser.ir.ImportSpecifierNode;
 import com.oracle.js.parser.ir.IndexNode;
 import com.oracle.js.parser.ir.JoinPredecessorExpression;
+import com.oracle.js.parser.ir.JsxAttributeNode;
+import com.oracle.js.parser.ir.JsxElementNode;
 import com.oracle.js.parser.ir.LabelNode;
 import com.oracle.js.parser.ir.LexicalContext;
 import com.oracle.js.parser.ir.LiteralNode;
+import com.oracle.js.parser.ir.NameSpaceImportNode;
+import com.oracle.js.parser.ir.NamedImportsNode;
 import com.oracle.js.parser.ir.Node;
 import com.oracle.js.parser.ir.ObjectNode;
 import com.oracle.js.parser.ir.PropertyNode;
@@ -220,6 +231,18 @@
         return enterDefault(errorNode);
     }
 
+    public R enterExportClauseNode(final ExportClauseNode exportClauseNode) {
+        return enterDefault(exportClauseNode);
+    }
+
+    public R enterExportNode(final ExportNode exportNode) {
+        return enterDefault(exportNode);
+    }
+
+    public R enterExportSpecifierNode(final ExportSpecifierNode exportSpecifierNode) {
+        return enterDefault(exportSpecifierNode);
+    }
+
     /**
      * Callback for entering an ExpressionStatement
      *
@@ -250,6 +273,10 @@
         return enterDefault(forNode);
     }
 
+    public R enterFromNode(final FromNode fromNode) {
+        return enterDefault(fromNode);
+    }
+
     /**
      * Callback for entering a FunctionNode
      *
@@ -280,6 +307,18 @@
         return enterDefault(ifNode);
     }
 
+    public R enterImportClauseNode(final ImportClauseNode importClauseNode) {
+        return enterDefault(importClauseNode);
+    }
+
+    public R enterImportNode(final ImportNode importNode) {
+        return enterDefault(importNode);
+    }
+
+    public R enterImportSpecifierNode(final ImportSpecifierNode importSpecifierNode) {
+        return enterDefault(importSpecifierNode);
+    }
+
     /**
      * Callback for entering an IndexNode
      *
@@ -290,6 +329,14 @@
         return enterDefault(indexNode);
     }
 
+    public R enterJsxAttributeNode(final JsxAttributeNode jsxAttributeNode) {
+        return enterDefault(jsxAttributeNode);
+    }
+
+    public R enterJsxElementNode(final JsxElementNode jsxElementNode) {
+        return enterDefault(jsxElementNode);
+    }
+
     /**
      * Callback for entering a LabelNode
      *
@@ -310,6 +357,14 @@
         return enterDefault(literalNode);
     }
 
+    public R enterNameSpaceImportNode(final NameSpaceImportNode nameSpaceImportNode) {
+        return enterDefault(nameSpaceImportNode);
+    }
+
+    public R enterNamedImportsNode(final NamedImportsNode namedImportsNode) {
+        return enterDefault(namedImportsNode);
+    }
+
     /**
      * Callback for entering an ObjectNode
      *
diff -r 2897b651281d -r ba7a8bc42268 graal/com.oracle.js.parser/src/com/oracle/js/parser/resources/Messages.properties
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/resources/Messages.properties	Mon Jun 27 16:29:08 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/resources/Messages.properties	Wed Jul 20 10:53:21 2016 +0200
@@ -84,6 +84,14 @@
 parser.error.expected.binding.identifier=expected BindingIdentifier
 parser.error.expected.from=expected 'from'
 
+# ES7 mode error messages
+parser.error.decorator.method.only=decorators may be used on methods only
+
+# JSX mode error messages
+parser.error.expected.jsx.attribute=Expected attribute value
+parser.error.expected.jsx.child=Expected element child
+parser.error.expected.jsx.name.mismatch=Expected end of element {0} but found {1}
+
 # strict mode error messages
 parser.error.strict.no.with="with" statement cannot be used in strict mode
 parser.error.strict.name="{0}" cannot be used as {1} in strict mode
