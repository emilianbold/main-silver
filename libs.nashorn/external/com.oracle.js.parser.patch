diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/AbstractParser.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/AbstractParser.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/AbstractParser.java	Fri Jun 24 17:00:50 2016 +0200
@@ -88,6 +88,9 @@
     /** Is this parser running under strong mode? */
     protected boolean isStrongMode;
 
+    /** Is this parser parsing module? */
+    protected boolean isModule;
+
     /** What should line numbers be counted from? */
     protected final int lineOffset;
 
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/Lexer.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/Lexer.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/Lexer.java	Fri Jun 24 17:00:50 2016 +0200
@@ -1160,7 +1160,7 @@
                 restoreState(expressionLexer.saveState());
 
                 // scan next middle or tail of the template literal
-                assert ch0 == '}';
+                //assert ch0 == '}';
                 type = TEMPLATE_MIDDLE;
 
                 // Skip over rbrace and record beginning of string content.
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/Parser.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/Parser.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/Parser.java	Fri Jun 24 17:00:50 2016 +0200
@@ -27,6 +27,7 @@
 
 import static com.oracle.js.parser.TokenType.ARROW;
 import static com.oracle.js.parser.TokenType.ASSIGN;
+import static com.oracle.js.parser.TokenType.AT;
 import static com.oracle.js.parser.TokenType.CASE;
 import static com.oracle.js.parser.TokenType.CATCH;
 import static com.oracle.js.parser.TokenType.CLASS;
@@ -36,6 +37,7 @@
 import static com.oracle.js.parser.TokenType.CONST;
 import static com.oracle.js.parser.TokenType.DECPOSTFIX;
 import static com.oracle.js.parser.TokenType.DECPREFIX;
+import static com.oracle.js.parser.TokenType.DEFAULT;
 import static com.oracle.js.parser.TokenType.ELLIPSIS;
 import static com.oracle.js.parser.TokenType.ELSE;
 import static com.oracle.js.parser.TokenType.EOF;
@@ -101,14 +103,21 @@
 import com.oracle.js.parser.ir.DebuggerNode;
 import com.oracle.js.parser.ir.EmptyNode;
 import com.oracle.js.parser.ir.ErrorNode;
+import com.oracle.js.parser.ir.ExportClauseNode;
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ExportSpecifierNode;
 import com.oracle.js.parser.ir.Expression;
 import com.oracle.js.parser.ir.ExpressionList;
 import com.oracle.js.parser.ir.ExpressionStatement;
 import com.oracle.js.parser.ir.ForNode;
+import com.oracle.js.parser.ir.FromNode;
 import com.oracle.js.parser.ir.FunctionNode;
 import com.oracle.js.parser.ir.FunctionNode.Kind;
 import com.oracle.js.parser.ir.IdentNode;
 import com.oracle.js.parser.ir.IfNode;
+import com.oracle.js.parser.ir.ImportClauseNode;
+import com.oracle.js.parser.ir.ImportNode;
+import com.oracle.js.parser.ir.ImportSpecifierNode;
 import com.oracle.js.parser.ir.IndexNode;
 import com.oracle.js.parser.ir.JoinPredecessorExpression;
 import com.oracle.js.parser.ir.LabelNode;
@@ -118,6 +127,8 @@
 import com.oracle.js.parser.ir.Module;
 import com.oracle.js.parser.ir.Module.ExportEntry;
 import com.oracle.js.parser.ir.Module.ImportEntry;
+import com.oracle.js.parser.ir.NameSpaceImportNode;
+import com.oracle.js.parser.ir.NamedImportsNode;
 import com.oracle.js.parser.ir.Node;
 import com.oracle.js.parser.ir.ObjectNode;
 import com.oracle.js.parser.ir.PropertyKey;
@@ -164,6 +175,8 @@
     private static final boolean ES6_DEFAULT_PARAMETER = Options.getBooleanProperty("parser.default.parameter", true);
     private static final boolean ES6_NEW_TARGET = Options.getBooleanProperty("parser.new.target", true);
 
+    private static final boolean ES7_DECORATOR = Options.getBooleanProperty("parser.decorator", true);
+
     /** Current env. */
     private final ScriptEnvironment env;
 
@@ -580,12 +593,19 @@
         }
 
         // Block closing brace.
+        int realFinish;
         if (needsBraces) {
+            expectDontAdvance(RBRACE);
+            // otherwise in case block containing single braced block the inner
+            // block could end somewhere later after comments and spaces
+            realFinish = Token.descPosition(token) + Token.descLength(token);
             expect(RBRACE);
+        } else {
+            realFinish = finish;
         }
 
         final int flags = newBlock.getFlags() | (needsBraces ? 0 : Block.IS_SYNTHETIC);
-        return new Block(blockToken, Math.max(finish, Token.descPosition(blockToken)), flags, newBlock.getStatements());
+        return new Block(blockToken, Math.max(realFinish, Token.descPosition(blockToken)), flags, newBlock.getStatements());
     }
 
     /**
@@ -616,7 +636,7 @@
         // Set up new block. Captures first token.
         final ParserContextBlockNode newBlock = newBlock();
         try {
-            statement(false, false, true, labelledStatement);
+            statement(false, false, true, labelledStatement, Collections.emptyList());
         } finally {
             restoreBlock(newBlock);
         }
@@ -657,6 +677,10 @@
         return env.es6;
     }
 
+    private boolean isES7() {
+        return env.es7;
+    }
+
     private static boolean isArguments(final String name) {
         return ARGUMENTS_NAME.equals(name);
     }
@@ -694,6 +718,7 @@
         case ASSIGN_DIV:
         case ASSIGN_MOD:
         case ASSIGN_MUL:
+        case ASSIGN_EXP:
         case ASSIGN_SAR:
         case ASSIGN_SHL:
         case ASSIGN_SHR:
@@ -892,7 +917,7 @@
 
                 try {
                     // Get the next element.
-                    statement(true, allowPropertyFunction, false, false);
+                    statement(true, allowPropertyFunction, false, false, Collections.emptyList());
                     allowPropertyFunction = false;
 
                     // check for directive prologues
@@ -1005,7 +1030,7 @@
      *     GeneratorDeclaration
      */
     private void statement() {
-        statement(false, false, false, false);
+        statement(false, false, false, false, Collections.emptyList());
     }
 
     /**
@@ -1013,7 +1038,11 @@
      * @param allowPropertyFunction allow property "get" and "set" functions?
      * @param singleStatement are we in a single statement context?
      */
-    private void statement(final boolean topLevel, final boolean allowPropertyFunction, final boolean singleStatement, final boolean labelledStatement) {
+    private void statement(final boolean topLevel, final boolean allowPropertyFunction,
+            final boolean singleStatement, final boolean labelledStatement, List<Expression> decorators) {
+        if (!decorators.isEmpty() && type != CLASS) {
+            throw error(expectMessage(CLASS));
+        }
         switch (type) {
         case LBRACE:
             block();
@@ -1085,11 +1114,12 @@
                 }
                 variableStatement(type, true);
                 break;
-            } else if (ES6_CLASS && type == CLASS && isES6()) {
+            // either it is ES6 class or it starts with @something as is ES7 decorated class
+            } else if (ES6_CLASS && isES6() && (type == CLASS || (ES7_DECORATOR && isES7() && type == AT))) {
                 if (singleStatement) {
                     throw error(AbstractParser.message("expected.stmt", "class declaration"), token);
                 }
-                classDeclaration(false);
+                classDeclaration(false, decorators);
                 break;
             }
             if (env.constAsVar && type == CONST) {
@@ -1133,10 +1163,10 @@
      *   class BindingIdentifier[?Yield] ClassTail[?Yield]
      *   [+Default] class ClassTail[?Yield]
      */
-    private ClassNode classDeclaration(boolean isDefault) {
+    private ClassNode classDeclaration(boolean isDefault, List<Expression> exportDecorators) {
         int classLineNumber = line;
 
-        ClassNode classExpression = classExpression(!isDefault);
+        ClassNode classExpression = classExpression(!isDefault, exportDecorators);
 
         if (!isDefault) {
             VarNode classVar = new VarNode(classLineNumber, classExpression.getToken(), classExpression.getIdent().getFinish(), classExpression.getIdent(), classExpression, VarNode.IS_CONST);
@@ -1149,18 +1179,20 @@
      * ClassExpression[Yield] :
      *   class BindingIdentifier[?Yield]opt ClassTail[?Yield]
      */
-    private ClassNode classExpression(boolean isStatement) {
-        assert type == CLASS;
+    private ClassNode classExpression(boolean isStatement, List<Expression> exportDecorators) {
+        assert type == CLASS || type == AT;
         int classLineNumber = line;
         long classToken = token;
-        next();
+        List<Expression> decorators = new ArrayList<>(exportDecorators);
+        decorators.addAll(decoratorList());
+        expect(CLASS);
 
         IdentNode className = null;
         if (isStatement || type == IDENT) {
             className = getIdent();
         }
 
-        return classTail(classLineNumber, classToken, className);
+        return classTail(classLineNumber, classToken, className, decorators);
     }
 
     private static final class ClassElementKey {
@@ -1209,7 +1241,7 @@
      *   static MethodDefinition[?Yield]
      *   ;
      */
-    private ClassNode classTail(int classLineNumber, long classToken, IdentNode className) {
+    private ClassNode classTail(int classLineNumber, long classToken, IdentNode className, List<Expression> decorators) {
         boolean oldStrictMode = isStrictMode;
         isStrictMode = true;
         try {
@@ -1232,6 +1264,13 @@
                 if (type == RBRACE) {
                     break;
                 }
+
+                List<Expression> methodDecorators;
+                if (type == AT) {
+                    methodDecorators = decoratorList();
+                } else {
+                    methodDecorators = Collections.emptyList();
+                }
                 long classElementToken = token;
                 boolean isStatic = false;
                 if (type == STATIC) {
@@ -1243,7 +1282,7 @@
                     generator = true;
                     next();
                 }
-                PropertyNode classElement = methodDefinition(isStatic, classHeritage != null, generator);
+                PropertyNode classElement = classElement(isStatic, classHeritage != null, generator, methodDecorators);
                 if (classElement.isComputed()) {
                     classElements.add(classElement);
                 } else if (!classElement.isStatic() && classElement.getKeyName().equals("constructor")) {
@@ -1291,7 +1330,7 @@
             }
 
             classElements.trimToSize();
-            return new ClassNode(classLineNumber, classToken, finish, className, classHeritage, constructor, classElements);
+            return new ClassNode(classLineNumber, classToken, finish, className, classHeritage, constructor, classElements, decorators);
         } finally {
             isStrictMode = oldStrictMode;
         }
@@ -1337,11 +1376,11 @@
                         FunctionNode.Kind.NORMAL,
                         classLineNumber,
                         body
-                        ), null, null, false, false);
+                        ), null, null, false, false, Collections.emptyList());
         return constructor;
     }
 
-    private PropertyNode methodDefinition(boolean isStatic, boolean subclass, boolean generator) {
+    private PropertyNode classElement(boolean isStatic, boolean subclass, boolean generator, List<Expression> decorators) {
         final long methodToken = token;
         final int methodLine = line;
         final boolean computed = type == LBRACKET;
@@ -1350,14 +1389,14 @@
         int flags = FunctionNode.IS_METHOD;
         if (!computed) {
             final String name = ((PropertyKey)propertyName).getPropertyName();
-            if (!generator && isIdent && type != LPAREN && name.equals("get")) {
+            if (!generator && isIdent && type != LPAREN && name.equals("get") && (!isES7() || isPropertyName())) {
                 PropertyFunction methodDefinition = propertyGetterFunction(methodToken, methodLine, flags);
                 verifyAllowedMethodName(methodDefinition.key, isStatic, methodDefinition.computed, generator, true);
-                return new PropertyNode(methodToken, finish, methodDefinition.key, null, methodDefinition.functionNode, null, isStatic, methodDefinition.computed);
-            } else if (!generator && isIdent && type != LPAREN && name.equals("set")) {
+                return new PropertyNode(methodToken, finish, methodDefinition.key, null, methodDefinition.functionNode, null, isStatic, methodDefinition.computed, decorators);
+            } else if (!generator && isIdent && type != LPAREN && name.equals("set") && (!isES7() || isPropertyName())) {
                 PropertyFunction methodDefinition = propertySetterFunction(methodToken, methodLine, flags);
                 verifyAllowedMethodName(methodDefinition.key, isStatic, methodDefinition.computed, generator, true);
-                return new PropertyNode(methodToken, finish, methodDefinition.key, null, null, methodDefinition.functionNode, isStatic, methodDefinition.computed);
+                return new PropertyNode(methodToken, finish, methodDefinition.key, null, null, methodDefinition.functionNode, isStatic, methodDefinition.computed, decorators);
             } else {
                 if (!isStatic && !generator && name.equals("constructor")) {
                     flags |= FunctionNode.IS_CLASS_CONSTRUCTOR;
@@ -1368,8 +1407,42 @@
                 verifyAllowedMethodName(propertyName, isStatic, computed, generator, false);
             }
         }
+        // ClassFieldInitializer
+        if (isES7() && type != LPAREN) {
+            // XXX decorators on properties
+            Expression assignment = null;
+            if (type == ASSIGN) {
+                next();
+                assignment = assignmentExpression(false);
+            }
+            endOfLine();
+            return new PropertyNode(methodToken, finish, propertyName, assignment, null, null, isStatic, computed, decorators);
+        }
         PropertyFunction methodDefinition = propertyMethodFunction(propertyName, methodToken, methodLine, generator, flags, computed);
-        return new PropertyNode(methodToken, finish, methodDefinition.key, methodDefinition.functionNode, null, null, isStatic, computed);
+        return new PropertyNode(methodToken, finish, methodDefinition.key, methodDefinition.functionNode, null, null, isStatic, computed, decorators);
+    }
+
+    /**
+     * https://github.com/wycats/javascript-decorators
+     */
+    private List<Expression> decoratorList() {
+        if (!isES7() || !ES7_DECORATOR || type != AT) {
+            return Collections.emptyList();
+        }
+        List<Expression> decorators = new ArrayList<>();
+        for (;;) {
+            next();
+            Expression decorator = leftHandSideExpression();
+            if (decorator == null) {
+                throw error(AbstractParser.message("expected.lvalue", type.getNameOrType()));
+            }
+            // FIXME https://github.com/wycats/javascript-decorators/issues/10 #2
+            decorators.add(decorator);
+            if (type != AT) {
+                break;
+            }
+        }
+        return decorators;
     }
 
     /**
@@ -1389,6 +1462,32 @@
         }
     }
 
+    private boolean isPropertyName() {
+        if (ES6_COMPUTED_PROPERTY_NAME && type == LBRACKET && isES6()) {
+            // computed property
+            return true;
+        }
+
+        switch (type) {
+        case IDENT:
+            return true;
+        case OCTAL_LEGACY:
+            if (isStrictMode) {
+                return false;
+            }
+        case STRING:
+        case ESCSTRING:
+        case DECIMAL:
+        case HEXADECIMAL:
+        case OCTAL:
+        case BINARY_NUMBER:
+        case FLOATING:
+            return true;
+        default:
+            return isIdentifierName();
+        }
+    }
+
     /**
      * block :
      *      { StatementList? }
@@ -1442,6 +1541,9 @@
             if (tokenType != IDENT && tokenType.getKind() != TokenKind.FUTURESTRICT) {
                 throw error(expectMessage(IDENT));
             }
+            if (isModule && "await".equals(ident.getName())) {
+                throw error(AbstractParser.message("strict.name", ident.getName(), contextString), ident.getToken());
+            }
         }
     }
 
@@ -1517,7 +1619,7 @@
             Expression binding = bindingIdentifierOrPattern(contextString);
             final boolean isDestructuring = !(binding instanceof IdentNode);
             if (isDestructuring) {
-                final int finalVarFlags = varFlags;
+                final int finalVarFlags = varFlags | VarNode.IS_DESTRUCTURING;
                 verifyDestructuringBindingPattern(binding, new Consumer<IdentNode>() {
                     public void accept(IdentNode identNode) {
                         verifyIdent(identNode, contextString);
@@ -1768,13 +1870,13 @@
 
         ExpressionStatement expressionStatement = null;
         if (expression != null) {
+            endOfLine();
             expressionStatement = new ExpressionStatement(expressionLine, expressionToken, finish, expression);
             appendStatement(expressionStatement);
         } else {
             expect(null);
-        }
-
-        endOfLine();
+            endOfLine();
+        }
     }
 
     /**
@@ -2564,7 +2666,7 @@
                     appendStatement(catchNode);
                 } finally {
                     restoreBlock(catchBlock);
-                    catchBlocks.add(new Block(catchBlock.getToken(), finish, catchBlock.getFlags() | Block.IS_SYNTHETIC, catchBlock.getStatements()));
+                    catchBlocks.add(new Block(catchBlock.getToken(), Math.max(finish, Token.descPosition(catchBlock.getToken())), catchBlock.getFlags() | Block.IS_SYNTHETIC, catchBlock.getStatements()));
                 }
 
                 // If unconditional catch then should to be the end.
@@ -3047,6 +3149,9 @@
         final Expression propertyName;
         final boolean isIdentifier;
 
+        List<Expression> decorators = decoratorList();
+        boolean method = ES7_DECORATOR && isES7() && !decorators.isEmpty();
+
         boolean generator = false;
         if (ES6_GENERATOR_FUNCTION && type == MUL && isES6()) {
             generator = true;
@@ -3064,11 +3169,11 @@
                 switch (ident) {
                 case "get":
                     final PropertyFunction getter = propertyGetterFunction(getSetToken, functionLine);
-                    return new PropertyNode(propertyToken, finish, getter.key, null, getter.functionNode, null, false, getter.computed);
+                    return new PropertyNode(propertyToken, finish, getter.key, null, getter.functionNode, null, false, getter.computed, decorators);
 
                 case "set":
                     final PropertyFunction setter = propertySetterFunction(getSetToken, functionLine);
-                    return new PropertyNode(propertyToken, finish, setter.key, null, null, setter.functionNode, false, setter.computed);
+                    return new PropertyNode(propertyToken, finish, setter.key, null, null, setter.functionNode, false, setter.computed, decorators);
                 default:
                     break;
                 }
@@ -3087,7 +3192,7 @@
 
         Expression propertyValue;
 
-        if (generator) {
+        if (generator || method) {
             expectDontAdvance(LPAREN);
         }
 
@@ -3113,7 +3218,7 @@
             }
         }
 
-        return new PropertyNode(propertyToken, finish, propertyName, propertyValue, null, null, false, computed);
+        return new PropertyNode(propertyToken, finish, propertyName, propertyValue, null, null, false, computed, decorators);
     }
 
     private PropertyFunction propertyGetterFunction(final long getSetToken, final int functionLine) {
@@ -3460,8 +3565,9 @@
             break;
 
         case CLASS:
-            if (ES6_CLASS && isES6()) {
-                lhs = classExpression(false);
+        case AT:
+            if (ES6_CLASS && isES6() && (type == CLASS || (ES7_DECORATOR && isES7() && type == AT))) {
+                lhs = classExpression(false, Collections.emptyList());
                 break;
             } else {
                 // fall through
@@ -3718,6 +3824,7 @@
         }
 
         if (isStatement) {
+            functionNode.setFlag(FunctionNode.IS_STATEMENT);
             if (topLevel || useBlockScope() || (!isStrictMode && env.functionDeclarationHoisting && env.functionStatement == ScriptEnvironment.FunctionStatementBehavior.ACCEPT)) {
                 functionNode.setFlag(FunctionNode.IS_DECLARED);
             } else if (isStrictMode) {
@@ -3989,7 +4096,8 @@
                 ParserContextFunctionNode currentFunction = lc.getCurrentFunction();
                 if (currentFunction != null) {
                     // declare function-scope variables for destructuring bindings
-                    lc.getFunctionBody(currentFunction).appendStatement(new VarNode(paramLine, Token.recast(paramToken, VAR), pattern.getFinish(), identNode, null));
+                    lc.getFunctionBody(currentFunction).appendStatement(
+                            new VarNode(paramLine, Token.recast(paramToken, VAR), pattern.getFinish(), identNode, null).setFlag(VarNode.IS_DESTRUCTURING));
                     // detect duplicate bounds names in parameter list
                     currentFunction.addParameterBinding(identNode);
                     currentFunction.setSimpleParameterList(false);
@@ -4590,6 +4698,7 @@
         case ASSIGN_DIV:
         case ASSIGN_MOD:
         case ASSIGN_MUL:
+        case ASSIGN_EXP:
         case ASSIGN_SAR:
         case ASSIGN_SHL:
         case ASSIGN_SHR:
@@ -4941,8 +5050,10 @@
      */
     private FunctionNode module(final String moduleName) {
         boolean oldStrictMode = isStrictMode;
+        boolean oldModule = isModule;
         try {
             isStrictMode = true; // Module code is always strict mode code. (ES6 10.2.1)
+            isModule = true;
 
             // Make a pseudo-token for the script holding its start and length.
             int functionStart = Math.min(Token.descPosition(Token.withDelimiter(token)), finish);
@@ -4980,6 +5091,7 @@
             script.setModule(module.createModule());
             return createFunctionNode(script, functionToken, ident, Collections.<IdentNode>emptyList(), FunctionNode.Kind.MODULE, functionLine, programBody);
         } finally {
+            isModule = oldModule;
             isStrictMode = oldStrictMode;
         }
     }
@@ -5000,19 +5112,30 @@
      *      StatementListItem
      */
     private void moduleBody() {
+        // FIXME this decorator handling is not described in spec
+        // yet certain frameworks uses it this way
+        List<Expression> decorators = new ArrayList<>();
         loop: while (type != EOF) {
             switch (type) {
             case EOF:
                 break loop;
             case IMPORT:
                 importDeclaration();
+                decorators.clear();
                 break;
             case EXPORT:
-                exportDeclaration();
+                exportDeclaration(decorators);
+                decorators.clear();
                 break;
+            case AT:
+                if (ES7_DECORATOR && isES7()) {
+                    decorators.addAll(decoratorList());
+                    break;
+                }
             default:
                 // StatementListItem
-                statement(true, false, false, false);
+                statement(true, false, false, false, decorators);
+                decorators.clear();
                 break;
             }
         }
@@ -5039,20 +5162,30 @@
      *     BindingIdentifier
      */
     private void importDeclaration() {
+        final long importToken = token;
         expect(IMPORT);
         ParserContextModuleNode module = lc.getCurrentModule();
         if (type == STRING || type == ESCSTRING) {
             // import ModuleSpecifier ;
             String moduleSpecifier = (String) getValue();
+            LiteralNode<String> specifier = LiteralNode.newInstance(token, finish, moduleSpecifier);
             next();
             module.addModuleRequest(moduleSpecifier);
+            module.addImport(new ImportNode(importToken, Token.descPosition(importToken), finish, specifier));
         } else {
             // import ImportClause FromClause ;
             List<ImportEntry> importEntries;
-            if (type == MUL) {
-                importEntries = Collections.singletonList(nameSpaceImport());
+            ImportClauseNode importClause;
+            final long startToken = token;
+            if (type == MUL) {    
+                NameSpaceImportNode namespaceNode = nameSpaceImport();
+                importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, namespaceNode);
+                importEntries = Collections.singletonList(
+                        ImportEntry.importStarAsNameSpaceFrom(namespaceNode.getBindingIdentifier().getName()));
             } else if (type == LBRACE) {
-                importEntries = namedImports();
+                NamedImportsNode namedImportsNode = namedImports();
+                importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, namedImportsNode);
+                importEntries = convert(namedImportsNode);
             } else if (isBindingIdentifier()) {
                 // ImportedDefaultBinding
                 IdentNode importedDefaultBinding = bindingIdentifier("ImportedBinding");
@@ -5060,28 +5193,37 @@
 
                 if (type == COMMARIGHT) {
                     next();
-                    importEntries = new ArrayList<>();
                     if (type == MUL) {
-                        importEntries.add(nameSpaceImport());
+                        NameSpaceImportNode namespaceNode = nameSpaceImport();
+                        importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, importedDefaultBinding, namespaceNode);
+                        importEntries = new ArrayList<>(2);
+                        importEntries.add(defaultImport);
+                        importEntries.add(ImportEntry.importStarAsNameSpaceFrom(namespaceNode.getBindingIdentifier().getName()));
                     } else if (type == LBRACE) {
-                        importEntries.addAll(namedImports());
+                        NamedImportsNode namedImportsNode = namedImports();
+                        importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, importedDefaultBinding, namedImportsNode);
+                        importEntries = convert(namedImportsNode);
+                        importEntries.add(0, defaultImport);
                     } else {
                         throw error("expected NameSpaceImport or NamedImports");
                     }
                 } else {
+                    importClause = new ImportClauseNode(startToken, Token.descPosition(startToken), finish, importedDefaultBinding);
                     importEntries = Collections.singletonList(defaultImport);
                 }
             } else {
                 throw error("expected ImportClause or ModuleSpecifier");
             }
 
-            String moduleSpecifier = fromClause();
+            FromNode fromNode = fromClause();
+            module.addImport(new ImportNode(importToken, Token.descPosition(importToken), finish, importClause, fromNode));
+            String moduleSpecifier = fromNode.getModuleSpecifier().getValue();
             module.addModuleRequest(moduleSpecifier);
             for (int i = 0; i < importEntries.size(); i++) {
                 module.addImportEntry(importEntries.get(i).withFrom(moduleSpecifier));
             }
         }
-        expect(SEMICOLON);
+        endOfLine();
     }
 
     /**
@@ -5090,7 +5232,8 @@
      *
      * @return imported binding identifier
      */
-    private ImportEntry nameSpaceImport() {
+    private NameSpaceImportNode nameSpaceImport() {
+        final long startToken = token;
         assert type == MUL;
         next();
         long asToken = token;
@@ -5099,7 +5242,7 @@
             throw error("expected 'as'", asToken);
         }
         IdentNode localNameSpace = bindingIdentifier("ImportedBinding");
-        return ImportEntry.importStarAsNameSpaceFrom(localNameSpace.getName());
+        return new NameSpaceImportNode(startToken, Token.descPosition(startToken), finish, localNameSpace);
     }
 
     /**
@@ -5116,10 +5259,11 @@
      * ImportedBinding :
      *     BindingIdentifier
      */
-    private List<ImportEntry> namedImports() {
+    private NamedImportsNode namedImports() {
+        final long startToken = token;
         assert type == LBRACE;
         next();
-        List<ImportEntry> importEntries = new ArrayList<>();
+        List<ImportSpecifierNode> importSpecifiers = new ArrayList<>();
         while (type != RBRACE) {
             boolean bindingIdentifier = isBindingIdentifier();
             long nameToken = token;
@@ -5127,11 +5271,13 @@
             if (type == IDENT && "as".equals(getValue())) {
                 next();
                 IdentNode localName = bindingIdentifier("ImportedBinding");
-                importEntries.add(ImportEntry.importSpecifier(importName.getName(), localName.getName()));
+                importSpecifiers.add(new ImportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, localName, importName));
+                //importEntries.add(ImportEntry.importSpecifier(importName.getName(), localName.getName()));
             } else if (!bindingIdentifier) {
                 throw error("expected BindingIdentifier", nameToken);
             } else {
-                importEntries.add(ImportEntry.importSpecifier(importName.getName()));
+                importSpecifiers.add(new ImportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, importName, null));
+                //importEntries.add(ImportEntry.importSpecifier(importName.getName()));
             }
             if (type == COMMARIGHT) {
                 next();
@@ -5140,14 +5286,15 @@
             }
         }
         expect(RBRACE);
-        return importEntries;
+        return new NamedImportsNode(startToken, Token.descPosition(startToken), finish, importSpecifiers);
     }
 
     /**
      * FromClause :
      *     from ModuleSpecifier
      */
-    private String fromClause() {
+    private FromNode fromClause() {
+        int fromStart = start;
         long fromToken = token;
         String name = (String) expectValue(IDENT);
         if (!"from".equals(name)) {
@@ -5155,8 +5302,9 @@
         }
         if (type == STRING || type == ESCSTRING) {
             String moduleSpecifier = (String) getValue();
+            LiteralNode<String> specifier = LiteralNode.newInstance(token, finish, moduleSpecifier);
             next();
-            return moduleSpecifier;
+            return new FromNode(fromToken, fromStart, finish, specifier);
         } else {
             throw error(expectMessage(STRING));
         }
@@ -5175,36 +5323,51 @@
      *     export default ClassDeclaration[Default]
      *     export default [lookahead !in {function, class}] AssignmentExpression[In] ;
      */
-    private void exportDeclaration() {
+    private void exportDeclaration(List<Expression> decorators) {
+        final long exportToken = token;
         expect(EXPORT);
         ParserContextModuleNode module = lc.getCurrentModule();
+        if (!decorators.isEmpty() && type != DEFAULT && type != CLASS && type != AT) {
+            throw error(expectMessage(CLASS));
+        }
+
         switch (type) {
             case MUL: {
                 next();
-                String moduleRequest = fromClause();
-                expect(SEMICOLON);
+                FromNode from = fromClause();
+                String moduleRequest = from.getModuleSpecifier().getValue();
                 module.addModuleRequest(moduleRequest);
                 module.addStarExportEntry(ExportEntry.exportStarFrom(moduleRequest));
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, from));
+                endOfLine();
                 break;
             }
             case LBRACE: {
-                List<ExportEntry> exportEntries = exportClause();
+                ExportClauseNode exportClause = exportClause();
                 if (type == IDENT && "from".equals(getValue())) {
-                    String moduleRequest = fromClause();
+                    FromNode from = fromClause();
+                    module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, exportClause, from));
+                    String moduleRequest = from.getModuleSpecifier().getValue();
                     module.addModuleRequest(moduleRequest);
+                    List<ExportEntry> exportEntries = convert(exportClause);
                     for (int i = 0; i < exportEntries.size(); i++) {
                         module.addIndirectExportEntry(exportEntries.get(i).withFrom(moduleRequest));
                     }
                 } else {
+                    module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, exportClause));
+                    List<ExportEntry> exportEntries = convert(exportClause);
                     for (int i = 0; i < exportEntries.size(); i++) {
                         module.addLocalExportEntry(exportEntries.get(i));
                     }
                 }
-                expect(SEMICOLON);
+                endOfLine();
                 break;
             }
             case DEFAULT:
                 next();
+                if (!decorators.isEmpty() && type != AT && type != CLASS) {
+                    throw error(expectMessage(CLASS));
+                }
                 Expression assignmentExpression;
                 IdentNode ident;
                 int lineNumber = line;
@@ -5216,8 +5379,10 @@
                         ident = ((FunctionNode) assignmentExpression).getIdent();
                         declaration = true;
                         break;
+                    // this is according to current decorator spec
                     case CLASS:
-                        assignmentExpression = classDeclaration(true);
+                    case AT:
+                        assignmentExpression = classDeclaration(true, decorators);
                         ident = ((ClassNode) assignmentExpression).getIdent();
                         declaration = true;
                         break;
@@ -5227,13 +5392,15 @@
                         declaration = false;
                         break;
                 }
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, assignmentExpression, true));
                 if (ident != null) {
                     module.addLocalExportEntry(ExportEntry.exportDefault(ident.getName()));
                 } else {
                     ident = createIdentNode(Token.recast(rhsToken, IDENT), finish, Module.DEFAULT_EXPORT_BINDING_NAME);
-                    lc.appendStatementToCurrentNode(new VarNode(lineNumber, Token.recast(rhsToken, LET), finish, ident, assignmentExpression));
+                    lc.appendStatementToCurrentNode(new VarNode(lineNumber, Token.recast(rhsToken, LET), finish, ident, assignmentExpression)
+                            .setFlag(VarNode.IS_EXPORT));
                     if (!declaration) {
-                        expect(SEMICOLON);
+                        endOfLine();
                     }
                     module.addLocalExportEntry(ExportEntry.exportDefault());
                 }
@@ -5246,17 +5413,22 @@
                 variableStatement(type, true);
                 for (Statement statement : statements.subList(previousEnd, statements.size())) {
                     if (statement instanceof VarNode) {
+                        module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, (VarNode) statement));
                         module.addLocalExportEntry(ExportEntry.exportSpecifier(((VarNode) statement).getName().getName()));
                     }
                 }
                 break;
-            case CLASS: {
-                ClassNode classDeclaration = classDeclaration(false);
+            // this is according to current decorator spec
+            case CLASS:
+            case AT: {
+                ClassNode classDeclaration = classDeclaration(false, decorators);
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, classDeclaration, false));
                 module.addLocalExportEntry(ExportEntry.exportSpecifier(classDeclaration.getIdent().getName()));
                 break;
             }
             case FUNCTION: {
                 FunctionNode functionDeclaration = (FunctionNode) functionExpression(true, true);
+                module.addExport(new ExportNode(exportToken, Token.descPosition(exportToken), finish, functionDeclaration, false));
                 module.addLocalExportEntry(ExportEntry.exportSpecifier(functionDeclaration.getIdent().getName()));
                 break;
             }
@@ -5279,18 +5451,22 @@
      *
      * @return a list of ExportSpecifiers
      */
-    private List<ExportEntry> exportClause() {
+    private ExportClauseNode exportClause() {
+        final long startToken = token;
         assert type == LBRACE;
         next();
-        List<ExportEntry> exports = new ArrayList<>();
+        List<ExportSpecifierNode> exports = new ArrayList<>();
         while (type != RBRACE) {
-            IdentNode localName = getIdentifierName();
+            long nameToken = token;
+            IdentNode localName = bindingIdentifier("ExportedBinding");
             if (type == IDENT && "as".equals(getValue())) {
                 next();
                 IdentNode exportName = getIdentifierName();
-                exports.add(ExportEntry.exportSpecifier(exportName.getName(), localName.getName()));
+                exports.add(new ExportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, localName, exportName));
+                //exports.add(ExportEntry.exportSpecifier(exportName.getName(), localName.getName()));
             } else {
-                exports.add(ExportEntry.exportSpecifier(localName.getName()));
+                exports.add(new ExportSpecifierNode(nameToken, Token.descPosition(nameToken), finish, localName, null));
+                //exports.add(ExportEntry.exportSpecifier(localName.getName()));
             }
             if (type == COMMARIGHT) {
                 next();
@@ -5299,7 +5475,7 @@
             }
         }
         expect(RBRACE);
-        return exports;
+        return new ExportClauseNode(startToken, Token.descPosition(startToken), finish, exports);
     }
 
     @Override
@@ -5391,4 +5567,28 @@
     private boolean inGeneratorFunction() {
         return lc.getCurrentFunction().getKind() == FunctionNode.Kind.GENERATOR;
     }
+
+    private static List<ImportEntry> convert(NamedImportsNode namedImportsNode) {
+        List<ImportEntry> importEntries = new ArrayList<>(namedImportsNode.getImportSpecifiers().size());
+        for (ImportSpecifierNode s : namedImportsNode.getImportSpecifiers()) {
+            if (s.getIdentifier() != null) {
+                importEntries.add(ImportEntry.importSpecifier(s.getIdentifier().getName(), s.getBindingIdentifier().getName()));
+            } else {
+                importEntries.add(ImportEntry.importSpecifier(s.getBindingIdentifier().getName()));
+            }
+        }
+        return importEntries;
+    }
+
+    private static List<ExportEntry> convert(ExportClauseNode exportClauseNode) {
+        List<ExportEntry> exports = new ArrayList<>(exportClauseNode.getExportSpecifiers().size());
+        for (ExportSpecifierNode s : exportClauseNode.getExportSpecifiers()) {
+            if (s.getExportIdentifier() != null) {
+                exports.add(ExportEntry.exportSpecifier(s.getExportIdentifier().getName(), s.getIdentifier().getName()));
+            } else {
+                exports.add(ExportEntry.exportSpecifier(s.getIdentifier().getName()));
+            }
+        }
+        return exports;
+    }
 }
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextModuleNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextModuleNode.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ParserContextModuleNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -24,6 +24,8 @@
  */
 package com.oracle.js.parser;
 
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ImportNode;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -45,6 +47,9 @@
     private List<ExportEntry> indirectExportEntries = new ArrayList<>();
     private List<ExportEntry> starExportEntries = new ArrayList<>();
 
+    private List<ImportNode> imports = new ArrayList<>();
+    private List<ExportNode> exports = new ArrayList<>();
+
     /**
      * Constructor.
      *
@@ -63,6 +68,14 @@
         return name;
     }
 
+    public void addImport(ImportNode importNode) {
+        imports.add(importNode);
+    }
+    
+    public void addExport(ExportNode exportNode) {
+        exports.add(exportNode);
+    }
+    
     public void addModuleRequest(String moduleRequest) {
         requestedModules.add(moduleRequest);
     }
@@ -84,6 +97,6 @@
     }
 
     public Module createModule() {
-        return new Module(requestedModules, importEntries, localExportEntries, indirectExportEntries, starExportEntries);
+        return new Module(requestedModules, importEntries, localExportEntries, indirectExportEntries, starExportEntries, imports, exports);
     }
 }
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ScriptEnvironment.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ScriptEnvironment.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ScriptEnvironment.java	Fri Jun 24 17:00:50 2016 +0200
@@ -52,6 +52,9 @@
     /** Enable ECMAScript 6 features. */
     final boolean es6;
 
+    /** Enable ECMAScript 7 features. */
+    final boolean es7;
+
     /**
      * Behavior when encountering a function declaration in a lexical context where only statements
      * are acceptable (function declarations are source elements, but not statements).
@@ -93,7 +96,7 @@
 
     final boolean functionDeclarationHoisting;
 
-    private ScriptEnvironment(boolean strict, boolean es6, boolean earlyLvalueError, boolean emptyStatements, boolean syntaxExtensions, boolean scripting, boolean shebang, boolean constAsVar,
+    private ScriptEnvironment(boolean strict, boolean es6, boolean es7, boolean earlyLvalueError, boolean emptyStatements, boolean syntaxExtensions, boolean scripting, boolean shebang, boolean constAsVar,
                     boolean functionDeclarationHoisting, FunctionStatementBehavior functionStatementBehavior, PrintWriter dumpOnError) {
         this.namespace = new Namespace();
         this.err = dumpOnError;
@@ -108,6 +111,7 @@
         this.scripting = scripting;
         this.shebang = shebang;
         this.es6 = es6;
+        this.es7 = es7;
         this.functionDeclarationHoisting = functionDeclarationHoisting;
     }
 
@@ -143,6 +147,7 @@
         private boolean earlyLvalueError = true;
         private boolean emptyStatements;
         private boolean es6 = true;
+        private boolean es7 = false;
         private boolean syntaxExtensions = true;
         private boolean scripting;
         private boolean shebang;
@@ -174,6 +179,11 @@
             return this;
         }
 
+        public Builder es7(boolean es7) {
+            this.es7 = es7;
+            return this;
+        }
+
         public Builder syntaxExtensions(boolean syntaxExtensions) {
             this.syntaxExtensions = syntaxExtensions;
             return this;
@@ -210,7 +220,7 @@
         }
 
         public ScriptEnvironment build() {
-            return new ScriptEnvironment(strict, es6, earlyLvalueError, emptyStatements, syntaxExtensions, scripting, shebang, constAsVar,
+            return new ScriptEnvironment(strict, es6, es7, earlyLvalueError, emptyStatements, syntaxExtensions, scripting, shebang, constAsVar,
                             functionDeclarationHoisting, functionStatementBehavior, dumpOnError);
         }
     }
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenType.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenType.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/TokenType.java	Fri Jun 24 17:00:50 2016 +0200
@@ -64,6 +64,8 @@
     RPAREN         (BRACKET, ")",     0, true),
     MUL            (BINARY,  "*",    13, true),
     ASSIGN_MUL     (BINARY,  "*=",    2, false),
+    EXP            (BINARY,  "**",   13, true),
+    ASSIGN_EXP     (BINARY,  "**=",   2, false),
     ADD            (BINARY,  "+",    12, true),
     INCPREFIX      (UNARY,   "++",   15, true),
     ASSIGN_ADD     (BINARY,  "+=",    2, false),
@@ -102,6 +104,7 @@
     RBRACE         (BRACKET, "}"),
     BIT_NOT        (UNARY,   "~",     14, false),
     ELLIPSIS       (UNARY,   "..."),
+    AT             (UNARY,   "@"),
 
     // ECMA 7.6.1.1 Keywords, 7.6.1.2 Future Reserved Words.
     // All other Java keywords are commented out.
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/BinaryNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/BinaryNode.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/BinaryNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -135,6 +135,7 @@
         case ASSIGN_DIV:
         case ASSIGN_MOD:
         case ASSIGN_MUL:
+        case ASSIGN_EXP:
         case ASSIGN_SAR:
         case ASSIGN_SHL:
         case ASSIGN_SHR:
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ClassNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ClassNode.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ClassNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -39,6 +39,7 @@
     private final Expression classHeritage;
     private final PropertyNode constructor;
     private final List<PropertyNode> classElements;
+    private final List<Expression> decorators;
     private final int line;
 
     /**
@@ -49,13 +50,25 @@
      * @param finish finish
      */
     public ClassNode(final int line, final long token, final int finish, final IdentNode ident, final Expression classHeritage, final PropertyNode constructor,
-                    final List<PropertyNode> classElements) {
+                    final List<PropertyNode> classElements, final List<Expression> decorators) {
         super(token, finish);
         this.line = line;
         this.ident = ident;
         this.classHeritage = classHeritage;
         this.constructor = constructor;
         this.classElements = classElements;
+        this.decorators = decorators;
+    }
+
+    private ClassNode(final ClassNode classNode, final IdentNode ident, final Expression classHeritage, final PropertyNode constructor,
+                    final List<PropertyNode> classElements, final List<Expression> decorators) {
+        super(classNode);
+        this.line = classNode.getLineNumber();
+        this.ident = ident;
+        this.classHeritage = classHeritage;
+        this.constructor = constructor;
+        this.classElements = classElements;
+        this.decorators = decorators;
     }
 
     /**
@@ -65,6 +78,13 @@
         return ident;
     }
 
+    private ClassNode setIdent(final IdentNode ident) {
+        if (this.ident == ident) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * The expression of the {@code extends} clause. Optional.
      */
@@ -72,6 +92,13 @@
         return classHeritage;
     }
 
+    private ClassNode setClassHeritage(final Expression classHeritage) {
+        if (this.classHeritage == classHeritage) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * Get the constructor method definition.
      */
@@ -79,6 +106,13 @@
         return constructor;
     }
 
+    private ClassNode setConstructor(final PropertyNode constructor) {
+        if (this.constructor == constructor) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * Get method definitions except the constructor.
      */
@@ -86,6 +120,27 @@
         return Collections.unmodifiableList(classElements);
     }
 
+    private ClassNode setClassElements(final List<PropertyNode> classElements) {
+        if (this.classElements == classElements) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
+    /**
+     * Get decorators.
+     */
+    public List<Expression> getDecorators() {
+        return Collections.unmodifiableList(decorators);
+    }
+
+    private ClassNode setDecorators(final List<Expression> decorators) {
+        if (this.decorators == decorators) {
+            return this;
+        }
+        return new ClassNode(this, ident, classHeritage, constructor, classElements, decorators);
+    }
+
     /**
      * Returns the line number.
      */
@@ -96,7 +151,14 @@
     @Override
     public Node accept(final NodeVisitor<? extends LexicalContext> visitor) {
         if (visitor.enterClassNode(this)) {
-            return visitor.leaveClassNode(this);
+            IdentNode newIdent = ident == null ? null : (IdentNode) ident.accept(visitor);
+            Expression newClassHeritage = classHeritage == null ? null : (Expression) classHeritage.accept(visitor);
+            PropertyNode newConstructor = constructor == null ? null : (PropertyNode) constructor.accept(visitor);
+            return visitor.leaveClassNode(setIdent(newIdent).
+                    setClassHeritage(newClassHeritage).
+                    setConstructor(newConstructor).
+                    setClassElements(Node.accept(visitor, classElements)).
+                    setDecorators(Node.accept(visitor, decorators)));
         }
 
         return this;
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportClauseNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportClauseNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class ExportClauseNode extends Node {
+
+    private final List<ExportSpecifierNode> exportSpecifiers;
+
+    public ExportClauseNode(final long token, final int start, final int finish, final List<ExportSpecifierNode> exportSpecifiers) {
+        super(token, start, finish);
+        this.exportSpecifiers = exportSpecifiers;
+    }
+
+    private ExportClauseNode(final ExportClauseNode node, final List<ExportSpecifierNode> exportSpecifiers) {
+        super(node);
+        this.exportSpecifiers = exportSpecifiers;
+    }
+
+    public List<ExportSpecifierNode> getExportSpecifiers() {
+        return Collections.unmodifiableList(exportSpecifiers);
+    }
+
+    public ExportClauseNode setExportSpecifiers(List<ExportSpecifierNode> exportSpecifiers) {
+        if (this.exportSpecifiers == exportSpecifiers) {
+            return this;
+        }
+        return new ExportClauseNode(this, exportSpecifiers);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterExportClauseNode(this)) {
+            return visitor.leaveExportClauseNode(setExportSpecifiers(Node.accept(visitor, exportSpecifiers)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterExportClauseNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append('{');
+        for (int i = 0; i < exportSpecifiers.size(); i++) {
+            exportSpecifiers.get(i).toString(sb, printType);
+            if (i < exportSpecifiers.size() - 1) {
+                sb.append(", ");
+            }
+        }
+        sb.append('}');
+    }
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class ExportNode extends Node {
+
+    private final ExportClauseNode exportClause;
+
+    private final FromNode from;
+
+    private final VarNode var;
+
+    private final Expression expression;
+
+    private final boolean isDefault;
+
+    public ExportNode(final long token, final int start, final int finish, final ExportClauseNode exportClause) {
+        this(token, start, finish, exportClause, null, null, null, false);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final FromNode from) {
+        this(token, start, finish, null, from, null, null, false);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final ExportClauseNode exportClause, final FromNode from) {
+        this(token, start, finish, exportClause, from, null, null, false);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final Expression expression, final boolean isDefault) {
+        this(token, start, finish, null, null, null, expression, isDefault);
+    }
+
+    public ExportNode(final long token, final int start, final int finish, final VarNode var) {
+        this(token, start, finish, null, null, var, null, false);
+    }
+
+    private ExportNode(final long token, final int start, final int finish, final ExportClauseNode exportClause,
+            final FromNode from, final VarNode var, final Expression expression, final boolean isDefault) {
+        super(token, start, finish);
+        this.exportClause = exportClause;
+        this.from = from;
+        this.var = var;
+        this.expression = expression;
+        this.isDefault = isDefault;
+    }
+
+    private ExportNode(final ExportNode node, final ExportClauseNode exportClause,
+            final FromNode from, final VarNode var, final Expression expression) {
+        super(node);
+        this.isDefault = node.isDefault;
+
+        this.exportClause = exportClause;
+        this.from = from;
+        this.var = var;
+        this.expression = expression;
+    }
+
+    public ExportClauseNode getExportClause() {
+        return exportClause;
+    }
+
+    public FromNode getFrom() {
+        return from;
+    }
+
+    public VarNode getVar() {
+        return var;
+    }
+
+    public Expression getExpression() {
+        return expression;
+    }
+
+    public boolean isDefault() {
+        return isDefault;
+    }
+
+    public ExportNode setExportClause(ExportClauseNode exportClause) {
+        if (this.exportClause == exportClause) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    public ExportNode setFrom(FromNode from) {
+        if (this.from == from) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    public ExportNode setVar(VarNode var) {
+        if (this.var == var) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    public ExportNode setExpression(Expression expression) {
+        if (this.expression == expression) {
+            return this;
+        }
+        return new ExportNode(this, exportClause, from, var, expression);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterExportNode(this)) {
+            ExportClauseNode newExportClause = exportClause == null ? null
+                    : (ExportClauseNode) exportClause.accept(visitor);
+            FromNode newFrom = from == null ? null
+                    : (FromNode) from.accept(visitor);
+            VarNode newVar = var == null ? null
+                    : (VarNode) var.accept(visitor);
+            Expression newExpression = expression == null ? null
+                    : (Expression) expression.accept(visitor);
+            return visitor.leaveExportNode(
+                    setExportClause(newExportClause).
+                    setFrom(newFrom).
+                    setVar(newVar).
+                    setExpression(newExpression));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterExportNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("export ");
+        if (isDefault) {
+            sb.append("default ");
+        }
+        if (expression != null) {
+            expression.toString(sb, printType);
+            if (expression.isAssignment()) {
+                sb.append(';');
+            }
+        } else {
+            if (exportClause == null) {
+                sb.append("* ");
+            } else {
+                exportClause.toString(sb, printType);
+            }
+            if (from != null) {
+                from.toString(sb, printType);
+            }
+            sb.append(';');
+        }
+    }
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportSpecifierNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ExportSpecifierNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class ExportSpecifierNode extends Node {
+
+    private final IdentNode identifier;
+
+    private final IdentNode exportIdentifier;
+
+    public ExportSpecifierNode(final long token, final int start, final int finish, final IdentNode identifier, final IdentNode exportIdentifier) {
+        super(token, start, finish);
+        this.identifier = identifier;
+        this.exportIdentifier = exportIdentifier;
+    }
+
+    private ExportSpecifierNode(final ExportSpecifierNode node, final IdentNode identifier, final IdentNode exportIdentifier) {
+        super(node);
+        this.identifier = identifier;
+        this.exportIdentifier = exportIdentifier;
+    }
+
+    public IdentNode getIdentifier() {
+        return identifier;
+    }
+
+    public IdentNode getExportIdentifier() {
+        return exportIdentifier;
+    }
+
+    public ExportSpecifierNode setIdentifier(IdentNode identifier) {
+        if (this.identifier == identifier) {
+            return this;
+        }
+        return new ExportSpecifierNode(this, identifier, exportIdentifier);
+    }
+
+    public ExportSpecifierNode setExportIdentifier(IdentNode exportIdentifier) {
+        if (this.exportIdentifier == exportIdentifier) {
+            return this;
+        }
+        return new ExportSpecifierNode(this, identifier, exportIdentifier);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterExportSpecifierNode(this)) {
+            IdentNode newExportIdentifier = exportIdentifier == null ? null
+                    : (IdentNode) exportIdentifier.accept(visitor);
+            return visitor.leaveExportSpecifierNode(
+                    setIdentifier((IdentNode) identifier.accept(visitor)).setExportIdentifier(newExportIdentifier));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterExportSpecifierNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        if (identifier != null) {
+            identifier.toString(sb, printType);
+            sb.append(" as ");
+        }
+        exportIdentifier.toString(sb, printType);
+    }
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FromNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FromNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class FromNode extends Node {
+
+    private final LiteralNode<String> moduleSpecifier;
+
+    public FromNode(final long token, final int start, final int finish, final LiteralNode<String> moduleSpecifier) {
+        super(token, start, finish);
+        this.moduleSpecifier = moduleSpecifier;
+    }
+
+    private FromNode(final FromNode node, final LiteralNode<String> moduleSpecifier) {
+        super(node);
+        this.moduleSpecifier = moduleSpecifier;
+    }
+
+    public LiteralNode<String> getModuleSpecifier() {
+        return moduleSpecifier;
+    }
+
+    public FromNode setModuleSpecifier(LiteralNode<String> moduleSpecifier) {
+        if (this.moduleSpecifier == moduleSpecifier) {
+            return this;
+        }
+        return new FromNode(this, moduleSpecifier);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterFromNode(this)) {
+            return visitor.leaveFromNode(
+                    setModuleSpecifier((LiteralNode<String>) moduleSpecifier.accept(visitor)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterFromNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("from");
+        sb.append(' ');
+        moduleSpecifier.toString(sb, printType);
+    }
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FunctionNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FunctionNode.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/FunctionNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -207,6 +207,9 @@
     /** Does this function use new.target? */
     public static final int USES_NEW_TARGET = 1 << 23;
 
+    /** Is it a statement? */
+    public static final int IS_STATEMENT = 1 << 24;
+
     /**
      * Constructor
      *
@@ -314,6 +317,14 @@
         return Node.accept(visitor, parameters);
     }
 
+    public List<ImportNode> visitImports(final NodeVisitor<? extends LexicalContext> visitor) {
+        return Node.accept(visitor, module.getImports());
+    }
+    
+    public List<ExportNode> visitExports(final NodeVisitor<? extends LexicalContext> visitor) {
+        return Node.accept(visitor, module.getExports());
+    }
+
     /**
      * Get the source for this function
      *
@@ -737,4 +748,8 @@
     public Module getModule() {
         return module;
     }
+
+    public boolean isStatement() {
+        return getFlag(IS_STATEMENT);
+    }
 }
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportClauseNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportClauseNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class ImportClauseNode extends Node {
+
+    private final IdentNode defaultBinding;
+
+    private final NameSpaceImportNode nameSpaceImport;
+
+    private final NamedImportsNode namedImports;
+
+    public ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding) {
+        this(token, start, finish, defaultBinding, null, null);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final NameSpaceImportNode nameSpaceImport) {
+        this(token, start, finish, null, nameSpaceImport, null);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final NamedImportsNode namedImportsNode) {
+        this(token, start, finish, null, null, namedImportsNode);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding, final NameSpaceImportNode nameSpaceImport) {
+        this(token, start, finish, defaultBinding, nameSpaceImport, null);
+    }
+
+    public ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding, final NamedImportsNode namedImports) {
+        this(token, start, finish, defaultBinding, null, namedImports);
+    }
+
+    private ImportClauseNode(long token, int start, int finish, final IdentNode defaultBinding, final NameSpaceImportNode nameSpaceImport, final NamedImportsNode namedImports) {
+        super(token, start, finish);
+        this.defaultBinding = defaultBinding;
+        this.nameSpaceImport = nameSpaceImport;
+        this.namedImports = namedImports;
+    }
+
+    private ImportClauseNode(final ImportClauseNode node, final IdentNode defaultBinding, final NameSpaceImportNode nameSpaceImport, final NamedImportsNode namedImports) {
+        super(node);
+        this.defaultBinding = defaultBinding;
+        this.nameSpaceImport = nameSpaceImport;
+        this.namedImports = namedImports;
+    }
+
+    public IdentNode getDefaultBinding() {
+        return defaultBinding;
+    }
+
+    public NameSpaceImportNode getNameSpaceImport() {
+        return nameSpaceImport;
+    }
+
+    public NamedImportsNode getNamedImports() {
+        return namedImports;
+    }
+
+    public ImportClauseNode setDefaultBinding(IdentNode defaultBinding) {
+        if (this.defaultBinding == defaultBinding) {
+            return this;
+        }
+        return new ImportClauseNode(this, defaultBinding, nameSpaceImport, namedImports);
+    }
+
+    public ImportClauseNode setNameSpaceImport(NameSpaceImportNode nameSpaceImport) {
+        if (this.nameSpaceImport == nameSpaceImport) {
+            return this;
+        }
+        return new ImportClauseNode(this, defaultBinding, nameSpaceImport, namedImports);
+    }
+
+    public ImportClauseNode setNamedImports(NamedImportsNode namedImports) {
+        if (this.namedImports == namedImports) {
+            return this;
+        }
+        return new ImportClauseNode(this, defaultBinding, nameSpaceImport, namedImports);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterImportClauseNode(this)) {
+            IdentNode newDefaultBinding = defaultBinding == null ? null
+                    : (IdentNode) defaultBinding.accept(visitor);
+            NameSpaceImportNode newNameSpaceImport = nameSpaceImport == null ? null
+                    : (NameSpaceImportNode) nameSpaceImport.accept(visitor);
+            NamedImportsNode newNamedImports = namedImports == null ? null
+                    : (NamedImportsNode) namedImports.accept(visitor);
+            return visitor.leaveImportClauseNode(
+                    setDefaultBinding(newDefaultBinding).
+                    setNameSpaceImport(newNameSpaceImport).
+                    setNamedImports(newNamedImports));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterImportClauseNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        if (defaultBinding != null) {
+            defaultBinding.toString(sb, printType);
+            if (nameSpaceImport != null || namedImports != null) {
+                sb.append(',');
+            }
+        }
+
+        if (nameSpaceImport != null) {
+            nameSpaceImport.toString(sb, printType);
+        } else if (namedImports != null) {
+            namedImports.toString(sb, printType);
+        }
+
+    }
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class ImportNode extends Node {
+
+    private final LiteralNode<String> moduleSpecifier;
+
+    private final ImportClauseNode importClause;
+
+    private final FromNode from;
+
+    public ImportNode(final long token, final int start, final int finish, final LiteralNode<String> moduleSpecifier) {
+        this(token, start, finish, moduleSpecifier, null, null);
+    }
+
+    public ImportNode(final long token, final int start, final int finish, final ImportClauseNode importClause, final FromNode from) {
+        this(token, start, finish, null, importClause, from);
+    }
+
+    private ImportNode(final long token, final int start, final int finish, final LiteralNode<String> moduleSpecifier, ImportClauseNode importClause, FromNode from) {
+        super(token, start, finish);
+        this.moduleSpecifier = moduleSpecifier;
+        this.importClause = importClause;
+        this.from = from;
+    }
+
+    private ImportNode(final ImportNode node, final LiteralNode<String> moduleSpecifier, ImportClauseNode importClause, FromNode from) {
+        super(node);
+        this.moduleSpecifier = moduleSpecifier;
+        this.importClause = importClause;
+        this.from = from;
+    }
+
+    public LiteralNode<String> getModuleSpecifier() {
+        return moduleSpecifier;
+    }
+
+    public ImportClauseNode getImportClause() {
+        return importClause;
+    }
+
+    public FromNode getFrom() {
+        return from;
+    }
+
+    public ImportNode setModuleSpecifier(LiteralNode<String> moduleSpecifier) {
+        if (this.moduleSpecifier == moduleSpecifier) {
+            return this;
+        }
+        return new ImportNode(this, moduleSpecifier, importClause, from);
+    }
+
+    public ImportNode setImportClause(ImportClauseNode importClause) {
+        if (this.importClause == importClause) {
+            return this;
+        }
+        return new ImportNode(this, moduleSpecifier, importClause, from);
+    }
+
+    public ImportNode setFrom(FromNode from) {
+        if (this.from == from) {
+            return this;
+        }
+        return new ImportNode(this, moduleSpecifier, importClause, from);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterImportNode(this)) {
+            LiteralNode<String> newModuleSpecifier = moduleSpecifier == null ? null
+                    : (LiteralNode<String>) moduleSpecifier.accept(visitor);
+            ImportClauseNode newImportClause = importClause == null ? null
+                    : (ImportClauseNode) importClause.accept(visitor);
+            FromNode newFrom = from == null ? null
+                    : (FromNode) from.accept(visitor);
+            return visitor.leaveImportNode(
+                    setModuleSpecifier(newModuleSpecifier).
+                    setImportClause(newImportClause).
+                    setFrom(newFrom));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterImportNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("import");
+        sb.append(' ');
+        if (moduleSpecifier != null) {
+            moduleSpecifier.toString(sb, printType);
+        } else {
+            importClause.toString(sb, printType);
+            sb.append(' ');
+            from.toString(sb, printType);
+        }
+        sb.append(';');
+    }
+
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportSpecifierNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/ImportSpecifierNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class ImportSpecifierNode extends Node {
+
+    private final IdentNode identifier;
+
+    private final IdentNode bindingIdentifier;
+
+    public ImportSpecifierNode(final long token, final int start, final int finish, final IdentNode bindingIdentifier, final IdentNode identifier) {
+        super(token, start, finish);
+        this.identifier = identifier;
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    private ImportSpecifierNode(final ImportSpecifierNode node, final IdentNode bindingIdentifier, final IdentNode identifier) {
+        super(node);
+        this.identifier = identifier;
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    public IdentNode getIdentifier() {
+        return identifier;
+    }
+
+    public IdentNode getBindingIdentifier() {
+        return bindingIdentifier;
+    }
+
+    public ImportSpecifierNode setIdentifier(IdentNode identifier) {
+        if (this.identifier == identifier) {
+            return this;
+        }
+        return new ImportSpecifierNode(this, identifier, bindingIdentifier);
+    }
+
+    public ImportSpecifierNode setBindingIdentifier(IdentNode bindingIdentifier) {
+        if (this.bindingIdentifier == bindingIdentifier) {
+            return this;
+        }
+        return new ImportSpecifierNode(this, identifier, bindingIdentifier);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterImportSpecifierNode(this)) {
+            IdentNode newIdentifier = identifier == null ? null
+                    : (IdentNode) identifier.accept(visitor);
+            return visitor.leaveImportSpecifierNode(
+                    setBindingIdentifier((IdentNode) bindingIdentifier.accept(visitor)).setIdentifier(newIdentifier));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterImportSpecifierNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        if (identifier != null) {
+            identifier.toString(sb, printType);
+            sb.append(" as ");
+        }
+        bindingIdentifier.toString(sb, printType);
+    }
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/Module.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/Module.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/Module.java	Fri Jun 24 17:00:50 2016 +0200
@@ -151,14 +151,18 @@
     private final List<ExportEntry> localExportEntries;
     private final List<ExportEntry> indirectExportEntries;
     private final List<ExportEntry> starExportEntries;
+    private final List<ImportNode> imports;
+    private final List<ExportNode> exports;
 
     public Module(List<String> requestedModules, List<ImportEntry> importEntries, List<ExportEntry> localExportEntries, List<ExportEntry> indirectExportEntries,
-                    List<ExportEntry> starExportEntries) {
+                    List<ExportEntry> starExportEntries, List<ImportNode> imports, List<ExportNode> exports) {
         this.requestedModules = requestedModules;
         this.importEntries = importEntries;
         this.localExportEntries = localExportEntries;
         this.indirectExportEntries = indirectExportEntries;
         this.starExportEntries = starExportEntries;
+        this.imports = imports;
+        this.exports = exports;
     }
 
     public List<String> getRequestedModules() {
@@ -181,9 +185,17 @@
         return starExportEntries;
     }
 
+    public List<ImportNode> getImports() {
+        return imports;
+    }
+
+    public List<ExportNode> getExports() {
+        return exports;
+    }
+
     @Override
     public String toString() {
         return "Module [requestedModules=" + requestedModules + ", importEntries=" + importEntries + ", localExportEntries=" + localExportEntries + ", indirectExportEntries=" +
-                        indirectExportEntries + ", starExportEntries=" + starExportEntries + "]";
+                        indirectExportEntries + ", starExportEntries=" + starExportEntries + ", imports=" + imports + ", exports=" + exports + "]";
     }
 }
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NameSpaceImportNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NameSpaceImportNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class NameSpaceImportNode extends Node {
+
+    private final IdentNode bindingIdentifier;
+
+    public NameSpaceImportNode(final long token, final int start, final int finish, final IdentNode bindingIdentifier) {
+        super(token, start, finish);
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    private NameSpaceImportNode(final NameSpaceImportNode node, final IdentNode bindingIdentifier) {
+        super(node);
+        this.bindingIdentifier = bindingIdentifier;
+    }
+
+    public IdentNode getBindingIdentifier() {
+        return bindingIdentifier;
+    }
+
+    public NameSpaceImportNode setBindingIdentifier(IdentNode bindingIdentifier) {
+        if (this.bindingIdentifier == bindingIdentifier) {
+            return this;
+        }
+        return new NameSpaceImportNode(this, bindingIdentifier);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterNameSpaceImportNode(this)) {
+            return visitor.leaveNameSpaceImportNode(
+                    setBindingIdentifier((IdentNode) bindingIdentifier.accept(visitor)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterNameSpaceImportNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append("* as ");
+        bindingIdentifier.toString(sb, printType);
+    }
+
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NamedImportsNode.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/NamedImportsNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.js.parser.ir;
+
+import com.oracle.js.parser.ir.visitor.NodeVisitor;
+import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ *
+ * @author Petr Hejl
+ */
+public class NamedImportsNode extends Node {
+
+    private final List<ImportSpecifierNode> importSpecifiers;
+
+    public NamedImportsNode(final long token, final int start, final int finish, final List<ImportSpecifierNode> importSpecifiers) {
+        super(token, start, finish);
+        this.importSpecifiers = importSpecifiers;
+    }
+
+    private NamedImportsNode(final NamedImportsNode node, final List<ImportSpecifierNode> importSpecifiers) {
+        super(node);
+        this.importSpecifiers = importSpecifiers;
+    }
+
+    public List<ImportSpecifierNode> getImportSpecifiers() {
+        return Collections.unmodifiableList(importSpecifiers);
+    }
+
+    public NamedImportsNode setImportSpecifiers(List<ImportSpecifierNode> importSpecifiers) {
+        if (this.importSpecifiers == importSpecifiers) {
+            return this;
+        }
+        return new NamedImportsNode(this, importSpecifiers);
+    }
+
+    @Override
+    public Node accept(NodeVisitor<? extends LexicalContext> visitor) {
+        if (visitor.enterNamedImportsNode(this)) {
+            return visitor.leaveNamedImportsNode(setImportSpecifiers(Node.accept(visitor, importSpecifiers)));
+        }
+
+        return this;
+    }
+
+    @Override
+    public <R> R accept(TranslatorNodeVisitor<? extends LexicalContext, R> visitor) {
+        return visitor.enterNamedImportsNode(this);
+    }
+
+    @Override
+    public void toString(StringBuilder sb, boolean printType) {
+        sb.append('{');
+        for (int i = 0; i < importSpecifiers.size(); i++) {
+            importSpecifiers.get(i).toString(sb, printType);
+            if (i < importSpecifiers.size() - 1) {
+                sb.append(", ");
+            }
+        }
+        sb.append('}');
+    }
+
+}
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/PropertyNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/PropertyNode.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/PropertyNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -27,6 +27,8 @@
 
 import com.oracle.js.parser.ir.visitor.NodeVisitor;
 import com.oracle.js.parser.ir.visitor.TranslatorNodeVisitor;
+import java.util.Collections;
+import java.util.List;
 
 // @formatter:off
 /**
@@ -46,6 +48,8 @@
     /** Property setter. */
     private final FunctionNode setter;
 
+    private final List<Expression> decorators;
+
     private final boolean isStatic;
 
     private final boolean computed;
@@ -60,7 +64,9 @@
      * @param getter  getter function body
      * @param setter  setter function body
      */
-    public PropertyNode(final long token, final int finish, final Expression key, final Expression value, final FunctionNode getter, final FunctionNode setter, final boolean isStatic, final boolean computed) {
+    public PropertyNode(final long token, final int finish, final Expression key,
+            final Expression value, final FunctionNode getter, final FunctionNode setter,
+            final boolean isStatic, final boolean computed, final List<Expression> decorators) {
         super(token, finish);
         this.key    = key;
         this.value  = value;
@@ -68,9 +74,12 @@
         this.setter = setter;
         this.isStatic = isStatic;
         this.computed = computed;
+        this.decorators = decorators;
     }
 
-    private PropertyNode(final PropertyNode propertyNode, final Expression key, final Expression value, final FunctionNode getter, final FunctionNode setter, final boolean isStatic, final boolean computed) {
+    private PropertyNode(final PropertyNode propertyNode, final Expression key,
+            final Expression value, final FunctionNode getter, final FunctionNode setter,
+            final boolean isStatic, final boolean computed, final List<Expression> decorators) {
         super(propertyNode);
         this.key    = key;
         this.value  = value;
@@ -78,6 +87,7 @@
         this.setter = setter;
         this.isStatic = isStatic;
         this.computed = computed;
+        this.decorators = decorators;
     }
 
     /**
@@ -95,7 +105,8 @@
                 setKey((Expression)key.accept(visitor)).
                 setValue(value == null ? null : (Expression)value.accept(visitor)).
                 setGetter(getter == null ? null : (FunctionNode)getter.accept(visitor)).
-                setSetter(setter == null ? null : (FunctionNode)setter.accept(visitor)));
+                setSetter(setter == null ? null : (FunctionNode)setter.accept(visitor)).
+                setDecorators(Node.accept(visitor, decorators)));
         }
 
         return this;
@@ -146,7 +157,7 @@
         if (this.getter == getter) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
     }
 
     /**
@@ -161,7 +172,7 @@
         if (this.key == key) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
     }
 
     /**
@@ -181,7 +192,7 @@
         if (this.setter == setter) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
     }
 
     /**
@@ -201,8 +212,22 @@
         if (this.value == value) {
             return this;
         }
-        return new PropertyNode(this, key, value, getter, setter, isStatic, computed);
-   }
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
+    }
+
+    /**
+     * Get decorators.
+     */
+    public List<Expression> getDecorators() {
+        return Collections.unmodifiableList(decorators);
+    }
+
+    private PropertyNode setDecorators(final List<Expression> decorators) {
+        if (this.decorators == decorators) {
+            return this;
+        }
+        return new PropertyNode(this, key, value, getter, setter, isStatic, computed, decorators);
+    }
 
     public boolean isStatic() {
         return isStatic;
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/VarNode.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/VarNode.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/VarNode.java	Fri Jun 24 17:00:50 2016 +0200
@@ -60,6 +60,12 @@
      *  a program node */
     public static final int IS_LAST_FUNCTION_DECLARATION = 1 << 2;
 
+    /** Flag synthetic export var node */
+    public static final int IS_EXPORT = 1 << 3;
+
+    /** Flag synthetic destructuring var node */
+    public static final int IS_DESTRUCTURING = 1 << 4;
+
     /**
      * Constructor
      *
@@ -288,4 +294,12 @@
     public boolean isFunctionDeclaration() {
         return init instanceof FunctionNode && ((FunctionNode)init).isDeclared();
     }
+
+    public boolean isExport() {
+        return getFlag(IS_EXPORT);
+    }
+
+    public boolean isDestructuring() {
+        return getFlag(IS_DESTRUCTURING);
+    }
 }
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/NodeVisitor.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/NodeVisitor.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/NodeVisitor.java	Fri Jun 24 17:00:50 2016 +0200
@@ -38,16 +38,25 @@
 import com.oracle.js.parser.ir.DebuggerNode;
 import com.oracle.js.parser.ir.EmptyNode;
 import com.oracle.js.parser.ir.ErrorNode;
+import com.oracle.js.parser.ir.ExportClauseNode;
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ExportSpecifierNode;
 import com.oracle.js.parser.ir.ExpressionStatement;
 import com.oracle.js.parser.ir.ForNode;
+import com.oracle.js.parser.ir.FromNode;
 import com.oracle.js.parser.ir.FunctionNode;
 import com.oracle.js.parser.ir.IdentNode;
 import com.oracle.js.parser.ir.IfNode;
+import com.oracle.js.parser.ir.ImportClauseNode;
+import com.oracle.js.parser.ir.ImportNode;
+import com.oracle.js.parser.ir.ImportSpecifierNode;
 import com.oracle.js.parser.ir.IndexNode;
 import com.oracle.js.parser.ir.JoinPredecessorExpression;
 import com.oracle.js.parser.ir.LabelNode;
 import com.oracle.js.parser.ir.LexicalContext;
 import com.oracle.js.parser.ir.LiteralNode;
+import com.oracle.js.parser.ir.NameSpaceImportNode;
+import com.oracle.js.parser.ir.NamedImportsNode;
 import com.oracle.js.parser.ir.Node;
 import com.oracle.js.parser.ir.ObjectNode;
 import com.oracle.js.parser.ir.PropertyNode;
@@ -352,6 +361,30 @@
         return leaveDefault(errorNode);
     }
 
+    public boolean enterExportClauseNode(final ExportClauseNode exportClauseNode) {
+        return enterDefault(exportClauseNode);
+    }
+
+    public Node leaveExportClauseNode(final ExportClauseNode exportClauseNode) {
+        return leaveDefault(exportClauseNode);
+    }
+
+    public boolean enterExportNode(final ExportNode exportNode) {
+        return enterDefault(exportNode);
+    }
+
+    public Node leaveExportNode(final ExportNode exportNode) {
+        return leaveDefault(exportNode);
+    }
+
+    public boolean enterExportSpecifierNode(final ExportSpecifierNode exportSpecifierNode) {
+        return enterDefault(exportSpecifierNode);
+    }
+
+    public Node leaveExportSpecifierNode(final ExportSpecifierNode exportSpecifierNode) {
+        return leaveDefault(exportSpecifierNode);
+    }
+
     /**
      * Callback for entering an ExpressionStatement
      *
@@ -412,6 +445,14 @@
         return leaveDefault(forNode);
     }
 
+    public boolean enterFromNode(final FromNode fromNode) {
+        return enterDefault(fromNode);
+    }
+
+    public Node leaveFromNode(final FromNode fromNode) {
+        return leaveDefault(fromNode);
+    }
+
     /**
      * Callback for entering a FunctionNode
      *
@@ -472,6 +513,30 @@
         return leaveDefault(ifNode);
     }
 
+    public boolean enterImportClauseNode(final ImportClauseNode importClauseNode) {
+        return enterDefault(importClauseNode);
+    }
+
+    public Node leaveImportClauseNode(final ImportClauseNode importClauseNode) {
+        return leaveDefault(importClauseNode);
+    }
+
+    public boolean enterImportNode(final ImportNode importNode) {
+        return enterDefault(importNode);
+    }
+
+    public Node leaveImportNode(final ImportNode importNode) {
+        return leaveDefault(importNode);
+    }
+
+    public boolean enterImportSpecifierNode(final ImportSpecifierNode importSpecifierNode) {
+        return enterDefault(importSpecifierNode);
+    }
+
+    public Node leaveImportSpecifierNode(final ImportSpecifierNode importSpecifierNode) {
+        return leaveDefault(importSpecifierNode);
+    }
+
     /**
      * Callback for entering an IndexNode
      *
@@ -532,6 +597,22 @@
         return leaveDefault(literalNode);
     }
 
+    public boolean enterNameSpaceImportNode(final NameSpaceImportNode nameSpaceImportNode) {
+        return enterDefault(nameSpaceImportNode);
+    }
+
+    public Node leaveNameSpaceImportNode(final NameSpaceImportNode nameSpaceImportNode) {
+        return leaveDefault(nameSpaceImportNode);
+    }
+
+    public boolean enterNamedImportsNode(final NamedImportsNode namedImportsNode) {
+        return enterDefault(namedImportsNode);
+    }
+
+    public Node leaveNamedImportsNode(final NamedImportsNode namedImportsNode) {
+        return leaveDefault(namedImportsNode);
+    }
+
     /**
      * Callback for entering an ObjectNode
      *
diff -r 4baa8b862456 -r 38267879beee graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/TranslatorNodeVisitor.java
--- a/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/TranslatorNodeVisitor.java	Mon Apr 18 15:25:25 2016 +0200
+++ b/graal/com.oracle.js.parser/src/com/oracle/js/parser/ir/visitor/TranslatorNodeVisitor.java	Fri Jun 24 17:00:50 2016 +0200
@@ -38,16 +38,25 @@
 import com.oracle.js.parser.ir.DebuggerNode;
 import com.oracle.js.parser.ir.EmptyNode;
 import com.oracle.js.parser.ir.ErrorNode;
+import com.oracle.js.parser.ir.ExportClauseNode;
+import com.oracle.js.parser.ir.ExportNode;
+import com.oracle.js.parser.ir.ExportSpecifierNode;
 import com.oracle.js.parser.ir.ExpressionStatement;
 import com.oracle.js.parser.ir.ForNode;
+import com.oracle.js.parser.ir.FromNode;
 import com.oracle.js.parser.ir.FunctionNode;
 import com.oracle.js.parser.ir.IdentNode;
 import com.oracle.js.parser.ir.IfNode;
+import com.oracle.js.parser.ir.ImportClauseNode;
+import com.oracle.js.parser.ir.ImportNode;
+import com.oracle.js.parser.ir.ImportSpecifierNode;
 import com.oracle.js.parser.ir.IndexNode;
 import com.oracle.js.parser.ir.JoinPredecessorExpression;
 import com.oracle.js.parser.ir.LabelNode;
 import com.oracle.js.parser.ir.LexicalContext;
 import com.oracle.js.parser.ir.LiteralNode;
+import com.oracle.js.parser.ir.NameSpaceImportNode;
+import com.oracle.js.parser.ir.NamedImportsNode;
 import com.oracle.js.parser.ir.Node;
 import com.oracle.js.parser.ir.ObjectNode;
 import com.oracle.js.parser.ir.PropertyNode;
@@ -220,6 +229,18 @@
         return enterDefault(errorNode);
     }
 
+    public R enterExportClauseNode(final ExportClauseNode exportClauseNode) {
+        return enterDefault(exportClauseNode);
+    }
+
+    public R enterExportNode(final ExportNode exportNode) {
+        return enterDefault(exportNode);
+    }
+
+    public R enterExportSpecifierNode(final ExportSpecifierNode exportSpecifierNode) {
+        return enterDefault(exportSpecifierNode);
+    }
+
     /**
      * Callback for entering an ExpressionStatement
      *
@@ -250,6 +271,10 @@
         return enterDefault(forNode);
     }
 
+    public R enterFromNode(final FromNode fromNode) {
+        return enterDefault(fromNode);
+    }
+
     /**
      * Callback for entering a FunctionNode
      *
@@ -280,6 +305,18 @@
         return enterDefault(ifNode);
     }
 
+    public R enterImportClauseNode(final ImportClauseNode importClauseNode) {
+        return enterDefault(importClauseNode);
+    }
+
+    public R enterImportNode(final ImportNode importNode) {
+        return enterDefault(importNode);
+    }
+
+    public R enterImportSpecifierNode(final ImportSpecifierNode importSpecifierNode) {
+        return enterDefault(importSpecifierNode);
+    }
+
     /**
      * Callback for entering an IndexNode
      *
@@ -310,6 +347,14 @@
         return enterDefault(literalNode);
     }
 
+    public R enterNameSpaceImportNode(final NameSpaceImportNode nameSpaceImportNode) {
+        return enterDefault(nameSpaceImportNode);
+    }
+
+    public R enterNamedImportsNode(final NamedImportsNode namedImportsNode) {
+        return enterDefault(namedImportsNode);
+    }
+
     /**
      * Callback for entering an ObjectNode
      *
