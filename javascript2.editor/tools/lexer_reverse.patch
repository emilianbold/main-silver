diff -r b23cdf74f25f javascript2.editor/src/org/netbeans/modules/javascript2/editor/lexer/JavaScriptColoringLexer.java
--- a/javascript2.editor/src/org/netbeans/modules/javascript2/editor/lexer/JavaScriptColoringLexer.java	Wed Nov 23 16:52:37 2011 +0100
+++ b/javascript2.editor/src/org/netbeans/modules/javascript2/editor/lexer/JavaScriptColoringLexer.java	Wed Nov 23 17:07:37 2011 +0100
 public final class JavaScriptColoringLexer {
@@ -749,6 +749,61 @@
     }
     return map;
   }
+
+
+  /**
+   * Refills the input buffer.
+   *
+   * @return      <code>false</code>, iff there was new input.
+   * 
+   * @exception   java.io.IOException  if any I/O-Error occurs
+   */
+  private boolean zzRefill() throws java.io.IOException {
+
+    /* first: make room (if you can) */
+    if (zzStartRead > 0) {
+      System.arraycopy(zzBuffer, zzStartRead,
+                       zzBuffer, 0,
+                       zzEndRead-zzStartRead);
+
+      /* translate stored positions */
+      zzEndRead-= zzStartRead;
+      zzCurrentPos-= zzStartRead;
+      zzMarkedPos-= zzStartRead;
+      zzStartRead = 0;
+    }
+
+    /* is the buffer big enough? */
+    if (zzCurrentPos >= zzBuffer.length) {
+      /* if not: blow it up */
+      char newBuffer[] = new char[zzCurrentPos*2];
+      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
+      zzBuffer = newBuffer;
+    }
+
+    /* finally: fill the buffer with new input */
+    int numRead = zzReader.read(zzBuffer, zzEndRead,
+                                            zzBuffer.length-zzEndRead);
+
+    if (numRead > 0) {
+      zzEndRead+= numRead;
+      return false;
+    }
+    // unlikely but not impossible: read 0 characters, but not at end of stream    
+    if (numRead == 0) {
+      int c = zzReader.read();
+      if (c == -1) {
+        return true;
+      } else {
+        zzBuffer[zzEndRead++] = (char) c;
+        return false;
+      }     
+    }
+
+	// numRead < 0
+    return true;
+  }
+
     
   /**
    * Closes the input stream.
@@ -806,7 +861,7 @@
    * Returns the text matched by the current regular expression.
    */
   public final String yytext() {
-    return input.readText().toString();
+    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
   }
 
 
@@ -822,7 +877,7 @@
    * @return the character at position pos
    */
   public final char yycharat(int pos) {
-    return input.readText().charAt(pos);
+    return zzBuffer[zzStartRead+pos];
   }
 
 
@@ -830,7 +885,7 @@
    * Returns the length of the matched text region.
    */
   public final int yylength() {
-    return input.readLength();
+    return zzMarkedPos-zzStartRead;
   }
 
 
@@ -873,7 +928,7 @@
     if ( number > yylength() )
       zzScanError(ZZ_PUSHBACK_2BIG);
 
-    input.backup(number);
+    zzMarkedPos -= number;
   }
 
 
@@ -913,16 +968,31 @@
 
       zzForAction: {
         while (true) {
-
-          zzInput = input.read();
-
-          if(zzInput == LexerInput.EOF) {
-              //end of input reached
+    
+          if (zzCurrentPosL < zzEndReadL)
+            zzInput = zzBufferL[zzCurrentPosL++];
+          else if (zzAtEOF) {
+            zzInput = YYEOF;
+            break zzForAction;
+          }
+          else {
+            // store back cached positions
+            zzCurrentPos  = zzCurrentPosL;
+            zzMarkedPos   = zzMarkedPosL;
+            boolean eof = zzRefill();
+            // get translated positions and possibly new buffer
+            zzCurrentPosL  = zzCurrentPos;
+            zzMarkedPosL   = zzMarkedPos;
+            zzBufferL      = zzBuffer;
+            zzEndReadL     = zzEndRead;
+            if (eof) {
               zzInput = YYEOF;
               break zzForAction;
-              //notice: currently LexerInput.EOF == YYEOF
+            }
+            else {
+              zzInput = zzBufferL[zzCurrentPosL++];
+            }
           }
-
           int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
           if (zzNext == -1) break zzForAction;
           zzState = zzNext;
@@ -931,7 +1001,6 @@
           if ( (zzAttributes & 1) == 1 ) {
             zzAction = zzState;
             zzMarkedPosL = zzCurrentPosL;
-            tokenLength = input.readLength();
             if ( (zzAttributes & 8) == 8 ) break zzForAction;
           }
 
@@ -939,9 +1008,7 @@
       }
 
       // store back cached position
-      if(zzInput != YYEOF) {
-         input.backup(input.readLength() - tokenLength);
-      }
+      zzMarkedPos = zzMarkedPosL;
 
       switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
         case 5: 
@@ -1038,14 +1105,9 @@
         default: 
           if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
             zzAtEOF = true;
-if(input.readLength() > 0) {
-            // backup eof
-            input.backup(1);
-            //and return the text as error token
-            return JsTokenId.UNKNOWN_TOKEN;
-} else {
-    return null;
-}
+              {
+                return JsTokenId.UNKNOWN_TOKEN;
+              }
           } 
           else {
             zzScanError(ZZ_NO_MATCH);
